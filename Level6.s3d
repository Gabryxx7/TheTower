#define STATUS_ELEVATOR_MOVING 0
#define STATUS_ELEVATOR_ARRIVED 1
#define STATUS_LEVEL_STARTED 2
#define STATUS_LEVEL_ENDING 3

/*
 * This level is strictly related to Level1; most of the things were copied and pasted. Comments will be on the parts that are different
 */
class Level6
{
	var mTexture;
	var mIsVRon;
	var mDebugVrOn;
	
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	var mTimeToEnd;
	
	var mLevelStatus;
	
	var mInputManager;
	var mAnimator;
	var mSoundManager;
	
	var mCamera;
	var cameraPosition;
	
	var mLight0;
	var mLight1;
	var mLight2;
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	var mLight0Diffuse;
	var mLight1Diffuse;
	var mLight2Diffuse;
	
	var mMainRoom;
	var mElevator;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;
	
	var mOpenglTranslationOffset;
	var mPreviousOpenglTranslationOffset;
	
	var mControllersArray;
	var mGuns;
	
	var mDrawingShader;

	var mBulletsArray;
	var mEnemySpeed;
	var mEnemyLaserSpeed;
	var mEnemyLaserMesh;
	
	var mTargets;
	var mBossStageMeshes;
	var mAnimatingTargets;
	var mCurrentStage;
	
	var mControllersBeingUsedIndex;
	
	var mCounterPositions;
	var mCounterBox;
	var mCounterRandomMeshes;
	var mCounter;
	var mLastCounterUpdate;
	var mCounterShader;
	var mBorderShader;
	
	var mApplyPostProcessing;
	var mPostProcessingBlurShader;
	var mPostProcessingBlurShaderPasses;
	var mPostProcessingBlurTimer;
	
	var mDebugController;
	var mDebugControllerHidden;
	var mDebugKeyHit;
	
	var mTranslateFactor;
		
	var mWallsHolesObjs;
	var mWallsHolesLife;
	
	var mCameraHudObj;
	var mCameraHit;
	var mCameraHudColorAnimId;
	var mCameraHitBoxObj;
	var mCameraHitBoxSize;
	var mCameraHitBoxHeight;
	
	var mCameraHudLife;
	var mLife;
	var mDefaultLife;
	var mGunsEventTriggers;
	var mPowerSphereRadius;
	var mIsCameraInsideTrigger;
	var mIsControllerInsideTrigger;
	
	var mTimeBeforeReset;
	var mLostTime;
	var mLastCounter;
	var mLightColorTransitionId;
	
	// Private functions
	HandleGuns();
	UpdateWallHoles();
	CheckPickupGuns();
	UpdateLasers(targets);
	UpdateEnemies(targets);
	UpdateStageStatus();
	CounterKeyboardTesting();
	UpdateCounter(num, toRandomPos);
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset, prevLightDiffuse);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	GetOpenglTransformOffset();
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	SetupOpenglLights();
	GetLightDiffuse();
	GetLevelPreview();
	GetLevelName();
	ApplyPostProcessing(postProcessingShader, passes, postProcessingShaderParametersStrings, postProcessingShaderParameters);	
	
	CreateMeshesBossStage();
	
	CreateTargetsStage0(numTargets);
	CreateTargetsStage1(numTargets);
	CreateTargetsBossStage();
	DrawHUD(eye);
	GenerateEnemies();
};

function Level6::Level6(isVRon, inputManager, soundManager)
{
	mIsVRon = isVRon;
	mDebugVrOn = true;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	
	mTranslateFactor = [0, 0, -20 * SCALE_FACTOR];
	
	mEnding = false;
	mIsLevelCompleted = false;
	mTimeToEnd = 2500;
		
	mAnimator = Animator();
	
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH*1.25, ROOM_SIDE_WALL_WIDTH*1.25, ROOM_HEIGHT*1.25, true, 1, 2);
	mMainRoom.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);
	
	mDrawingShader = CVmShaderProgram("drawingShader.glsl");
	mCounterShader = CVmShaderProgram("void main(void) { gl_Position = ftransform(); }", "uniform vec3 color; uniform float alpha; void main (void) { gl_FragColor = vec4(color, alpha); }", true);
	mBorderShader = CvmShaderProgram("SimpleColorSHader.glsl");
		
	mApplyPostProcessing = false;
	mPostProcessingBlurShader = CVmShaderProgram("postProcessingBlurShader.glsl");
	mPostProcessingBlurShaderPasses = 1;
	mPostProcessingBlurTimer = 0;
		
	mControllersBeingUsedIndex = {};	
	mControllersArray = {};	
	
	mGunsEventTriggers = {};
	var size = 8*SCALE_FACTOR;
	var cornerx = mMainRoom.GetRoomWidth()/2;
	var cornerz = mMainRoom.GetRoomDepth()/2;
	var offy = 5*SCALE_FACTOR;

	mIsCameraInsideTrigger = false;
	mIsControllerInsideTrigger = {false, false};
	mPowerSphereRadius = 2*SCALE_FACTOR;
	var gunSphereMesh = CvmNewMesh(VRP_SPHERE, 30, mPowerSphereRadius, 1);
	aadd(mGunsEventTriggers, {CvmObj(gunSphereMesh)});
	mGunsEventTriggers[0][0].SetPosition([cornerx-size, offy, cornerz-size*2] + mTranslateFactor);
	aadd(mGunsEventTriggers, {CvmObj(gunSphereMesh)});
	mGunsEventTriggers[1][0].SetPosition([-cornerx+size/2, offy, -cornerz] + mTranslateFactor);
	aadd(mGunsEventTriggers, {CvmObj(gunSphereMesh)});
	mGunsEventTriggers[2][0].SetPosition([-cornerx+size/2, offy, cornerz-size*2] + mTranslateFactor);
	aadd(mGunsEventTriggers, {CvmObj(gunSphereMesh)});
	mGunsEventTriggers[3][0].SetPosition([cornerx-size, offy, -cornerz] + mTranslateFactor);
	aadd(mGunsEventTriggers, {CvmObj(gunSphereMesh)});
	mGunsEventTriggers[4][0].SetPosition([0, offy, -mMainRoom.GetRoomWidth()/2+size] + mTranslateFactor);
	
	var mLaserLength = 1.5;
	var mLaserWidth = 0.035;
	var mLaserMesh = CvmNewMesh(VRP_CYLINDER, 30, mLaserWidth*SCALE_FACTOR, -mLaserLength*SCALE_FACTOR, 1);
	var mLaserMeshSphere = CvmNewMesh(VRP_SPHERE, 30, 0.08*SCALE_FACTOR, 1);
	var recSize = [0.02*SCALE_FACTOR, 0.2*SCALE_FACTOR, 0.4*SCALE_FACTOR];
	var mLaserMeshRectangle = CVmNewMesh(VRP_BOX, 1, [-recSize.x/2, -recSize.y/2, -recSize.z/2], [recSize.x/2, recSize.y/2, recSize.z/2]);
	mLaserMesh.Rotate(90,1,0,0);
	
	mGuns = {};
	var shootingDelay = 100.0;
	var recoil = 0.2*SCALE_FACTOR;
	var bulletDistance = 1000;
	var bulletLife = 5000;
	var bulletSpeed = 25;
	aadd(mGuns, Gun("Weapons/V2/SciFiGun.AAM", shootingDelay, recoil, mLaserMesh, bulletSpeed/2, bulletDistance, bulletLife, [1,0,0], 3, 0, true, mAnimator, 991));
	aadd(mGuns, Gun("Weapons/V2/SciFiGun.AAM", shootingDelay, recoil, mLaserMesh, bulletSpeed/2, bulletDistance, bulletLife, [1,0,0], 3, 0, true, mAnimator, 991));	
//	aadd(mGuns, Gun("Weapons/V2/bGUN02h.AAM", shootingDelay*3, recoil, mLaserMeshRectangle, bulletSpeed, bulletDistance, bulletLife, [0,0,1], 0.75, 2, true, mAnimator, 3000));
//	aadd(mGuns, Gun("Weapons/V1/SciFiGun.AAM", shootingDelay, recoil, mLaserMesh, bulletSpeed/2, bulletDistance, bulletLife, [1,0,0], 3, 0, true, mAnimator, 991));
//	aadd(mGuns, Gun("Weapons/V1/SciFiGun.AAM", shootingDelay, recoil, mLaserMesh, bulletSpeed/2, bulletDistance, bulletLife, [1,0,0], 3, 0, true, mAnimator, 991));

	foreach(var gun in mGuns){
		aadd(mControllersBeingUsedIndex, 0);
	}		
	
//	var gun1 = Gun("Weapons/V1/SciFiGun.AAM", shootingDelay, recoil, mLaserMesh, bulletSpeed/2, bulletDistance, bulletLife, [1,0,0], 3, 0, true, mAnimator, 900);
	var gun1 = Gun("Weapons/V2/SciFiGun.AAM", shootingDelay, recoil, mLaserMesh, bulletSpeed/2, bulletDistance, bulletLife, [1,0,0], 3, 0, true, mAnimator, 900);
	gun1.CreatePickupPoint(mGunsEventTriggers[0][0].GetPosition(), 0, [1,0,0]);	
	aadd(mGunsEventTriggers[0], gun1);	
		
	var colors = GenerateColors(0.025);
//	gun1 = Gun("Weapons/V1/MachineGun.AAM", shootingDelay/3, recoil, mLaserMeshSphere, bulletSpeed, bulletDistance, bulletLife, colors, 0.5, 0, false, mAnimator, 2000);
	gun1 = Gun("Weapons/V2/MachineGun.AAM", shootingDelay/3, recoil, mLaserMeshSphere, bulletSpeed, bulletDistance, bulletLife, colors, 0.5, 0, false, mAnimator, 2000);
	gun1.CreatePickupPoint(mGunsEventTriggers[1][0].GetPosition(), 0, [1,0,0]);	
	aadd(mGunsEventTriggers[1], gun1);	
	
//	gun1 = Gun("Weapons/V1/bGUN02h.AAM", shootingDelay*3, recoil, mLaserMeshRectangle, bulletSpeed, bulletDistance, bulletLife, [0,0,1], 0.75, 2, true, mAnimator, 3000);
	gun1 = Gun("Weapons/V2/bGUN02h.AAM", shootingDelay*3, recoil, mLaserMeshRectangle, bulletSpeed, bulletDistance, bulletLife, [0,0,1], 0.75, 2, true, mAnimator, 3000);
	gun1.CreatePickupPoint(mGunsEventTriggers[2][0].GetPosition(), 0, [1,0,0]);	
	aadd(mGunsEventTriggers[2], gun1);	
	
//	gun1 = Gun("Weapons/V1/bGUN03h.AAM", shootingDelay*3, recoil, mLaserMeshSphere, bulletSpeed, bulletDistance, bulletLife, [0,1,0], 0.35, 1, false, mAnimator, 4000);
	gun1 = Gun("Weapons/V2/bGUN03h.AAM", shootingDelay*3, recoil, mLaserMeshSphere, bulletSpeed, bulletDistance, bulletLife, [0,1,0], 0.35, 1, false, mAnimator, 4000);
	gun1.CreatePickupPoint(mGunsEventTriggers[3][0].GetPosition(), 0, [1,0,0]);
	aadd(mGunsEventTriggers[3], gun1);	
	
	gun1 = CvmObj(CvmNewMesh("Vive_Controller_Mesh/Exported/Full_Body/vr_controller_vive_1_5.aam"));
	gun1.SetPosition(mGunsEventTriggers[4][0].GetPosition());
	mAnimator.CreateRotatingTransition(gun1, 0, 360, [0,1,0], 2, true, false);
	aadd(mGunsEventTriggers[4], gun1);	
	
	if(mIsVRon)
	{
		aadd(mControllersArray, mInputManager.GetController(1));
		aadd(mControllersArray, mInputManager.GetController(2));
		mGuns[0].LinkToController(mControllersArray[0]);
		mGuns[1].LinkToController(mControllersArray[1]);
	}
	else if(mDebugVrOn)
	{
		aadd(mControllersArray, ViveController(1));
		aadd(mControllersArray, ViveController(2));
		mGuns[0].LinkToController(mControllersArray[0]);
		mGuns[1].LinkToController(mControllersArray[1]);
				
		mDebugController = mControllersArray[0];
		mDebugControllerHidden = false;
		mDebugKeyhit = false;
	}
	
	mCounter = 0;
	mLastCounterUpdate = 0;
	mCounterPositions = {};
	var cubeSizes = 2.5 *SCALE_FACTOR;
	var cubeSpacing = 0.15 *SCALE_FACTOR;
	var numberSpacing = 1*SCALE_FACTOR;
	mCounterBox = [6*(cubeSizes+cubeSpacing)/2, 10*(cubeSizes+cubeSpacing)/2, 6*(cubeSizes+cubeSpacing)/2];
	var digitWidth = 6*(cubeSizes+cubeSpacing)-cubeSpacing;
	var counterMesh = CVmNewMesh(VRP_BOX, 1, [-cubeSizes/2, -cubeSizes/2, 0], [cubeSizes/2, cubeSizes/2, 0], cubeSizes);
	mCounterRandomMeshes = {};
	aadd(mCounterPositions, [digitWidth/2+numberSpacing/2, 8*SCALE_FACTOR, -mMainRoom.GetRoomWidth()/2-cubeSizes]+mTranslateFactor);
	aadd(mCounterPositions, mCounterPositions[0]-[digitWidth+numberSpacing,0,0]);
	aadd(mCounterRandomMeshes, RandomMeshes(counterMesh, 54, mCounterBox, mCounterPositions[0], [0.8,0.2,0.2], cubeSizes, cubeSpacing, -1));
	aadd(mCounterRandomMeshes, RandomMeshes(counterMesh, 54, mCounterBox, mCounterPositions[1], [0.2,0.4,1], cubeSizes,cubeSpacing, -1));
	UpdateCounter(0, false);

	mBulletsArray = {};	
	mWallsHolesObjs = {};
	mWallsHolesLife = 5000;
	mCurrentStage = 0;
	
	mEnemyLaserSpeed = 15;
	mEnemySpeed = 5.0;
	mEnemyLaserMesh = CvmNewMesh(VRP_CYLINDER, 30, mLaserWidth*SCALE_FACTOR, -mLaserLength*SCALE_FACTOR, 1);
	
	CreateMeshesBossStage();
	GenerateEnemies();
	
	mCameraHit = false;
	mCameraHudColorAnimId = 9876;
	mCameraHitBoxSize = 0.45*SCALE_FACTOR;
	mCameraHitBoxHeight = 4.0 * SCALE_FACTOR;
	mCameraHitBoxObj = CvmObj(CVmNewMesh(VRP_BOX, 1, [-mCameraHitBoxSize/2, -mCameraHitBoxHeight/2, -mCameraHitBoxSize], [mCameraHitBoxSize/2, mCameraHitBoxHeight/2, mCameraHitBoxSize]));	
	
	var txt = CVmText();
	txt.Load("+");
	txt.SetColor(1,1,0);
	
	mCameraHudLife = CvmText();
	mDefaultLife = 2;
	mLife = mDefaultLife;
	mCameraHudLife.Load(str(mLife));
	
	var obj1 = CvmObj();
	var obj2 = CvmObj();
	obj1.LinkToText(txt);	
	obj2.LinkToText(mCameraHudLife);
	
	mCameraHudObj = CVmObj();	
	mCameraHudObj.AddChild(obj1,0,0,0);	
	mCameraHudObj.AddChild(obj2, 0.7, 0,0);
	mCameraHudObj.SetScale(0.07, 0.1, 0.0);
	
	mAnimatingTargets = {};
	mTimeBeforeReset = 3000;
	mLostTime = -1;
	mLastCounter = 0;
	mLightColorTransitionId = 8957;
}


 
 function Level6::Init(lights, lightsDiffuse, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
		
//	mLight0Diffuse = [1, 1, 1];
//	mLight1Diffuse = [0.612865, 0.0750434, 1.08279];
//	mLight2Diffuse = [0.172785, 1.00443, 0.488585];
	mLight0Diffuse = [1, 1, 1];
	mLight1Diffuse = [1.02546, 0.509065, 0.903289];
	mLight2Diffuse = [0.0861419, 0.488434, 1.27123];
	
	mLight0 = lights[0];
	mLight0.SetDiffuse(mLight0Diffuse.x, mLight0Diffuse.y, mLight0Diffuse.z);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetDiffuse(mLight1Diffuse.x, mLight1Diffuse.y, mLight1Diffuse.z);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetDiffuse(mLight2Diffuse.x, mLight2Diffuse.y, mLight2Diffuse.z);
	mLight2.Enable();
	
		
	mElevator = elevator;
	
	mCamera = mInputManager.GetActiveCamera();
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 1.5;
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	mLight1.SetPosition(mLight1.GetPosition() - [0, mElevatorTravelDistance, 0]);
	mLight2.SetPosition(mLight2.GetPosition() - [0, mElevatorTravelDistance, 0]);
	
	mLight0Position = mLight0.GetPosition();
	mLight1Position = mLight1.GetPosition();
	mLight2Position = mLight2.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
	
	mCameraYoffset = mElevatorTravelDistance / mElevatorTravelTime;
	mPreviousOpenglTranslationOffset = mOpenglTranslationOffset; 
	mOpenglTranslationOffset.y += mElevatorTravelDistance;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
	
	// I move the room a bit so that the elevator is completely in the center of the room
	mMainRoom.Translate(-mElevator.GetRoomDepth() / 2.0 + 3.0 * SCALE_FACTOR, 0, -mElevator.GetRoomWidth() / 2.0);
	
	// I set now the position of a text that needed to know where the elevator was
//	mFrontText.SetPosition([0, 7.0 * SCALE_FACTOR, mMainRoom.GetRoomDepth()/2 - 0.1 * SCALE_FACTOR -mElevator.GetRoomWidth() / 2.0] + mTranslateFactor);
//	mBackText.SetPosition(mElevatorFinalPosition + [0.1 * SCALE_FACTOR, 1 * SCALE_FACTOR, -0.1 * SCALE_FACTOR]);
//	mLeftText.SetPosition([mMainRoom.GetRoomWidth()/2 - 2.1 * SCALE_FACTOR, 7.0 * SCALE_FACTOR, -mElevator.GetRoomWidth() / 2.0] + mTranslateFactor);
	
	mAnimator.CreateLightColorTransition(GL_LIGHT1, lightsDiffuse[1], mLight1Diffuse, mElevatorTravelTime);
	mAnimator.CreateLightColorTransition(GL_LIGHT2, lightsDiffuse[2], mLight2Diffuse, mElevatorTravelTime);
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */


/*
 * Render method
 */
function Level6::Render()
{	
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);	
	
	mElevator.Draw();
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_ENDING:		
		case STATUS_LEVEL_STARTED:
		{		
			mMainRoom.Draw();
			
			if(len(mTargets) > 0){
				foreach(var target in mTargets[0])
					target.Draw();				
			}
			
			if(len(mAnimatingTargets) > 0){
				foreach(var target in mAnimatingTargets)
					target.Draw();				
			}
				
			mCounterShader.Start();
				mCounterShader.SetParameter("alpha", 1.0);

				foreach(var bullet in mBulletsArray){
					mCounterShader.SetParameter("color", bullet.GetColor());
					bullet.Draw();	
				}
				
//				mCameraHitBoxObj.DrawBoundingBox();
				
				mCounterShader.SetParameter("color", [0,0,0]);
				foreach(var wallHole in mWallsHolesObjs)
					wallHole[0].Draw();
			
				for(var i = 0; i < len(mCounterRandomMeshes); i++){
					foreach(var obj in mCounterRandomMeshes[i].GetObjs()){
						mCounterShader.SetParameter("color", mCounterRandomMeshes[i].GetColor());
						obj.Draw();
						mCounterShader.SetParameter("color", [0,0,0]);
						glLineWidth(2.0);
						obj.Draw(VR_BBOX_ONLY);
					}			
				}
				
				
			mCounterShader.Stop();
			
			
			for(var i = 0; i < len(mGuns); i++){
				if(mGuns[i].IsDestroyed() && (mIsVrOn || mDebugVrOn)){
					mControllersArray[i].Draw();
				}
				else{
					mGuns[i].Draw();
				}
			}
				
			foreach(var trigger in mGunsEventTriggers){
				trigger[1].Draw();
				
				mBorderShader.Start();
					mBorderShader.SetParameter("alpha", 0.15);
					mBorderShader.SetParameter("outlinecolor", [1,1,0]);
					mBorderShader.SetParameter("outline", 0);
					glCullFace (GL_FRONT);
					trigger[0].SetScale(1.05, 1.05, 1.05);
					trigger[0].Draw();
					mBorderShader.SetParameter("alpha", 0.12);
					mBorderShader.SetParameter("outline", 1);
					mBorderShader.SetParameter("diffuse", [0.5,0.5,1]);
					glCullFace (GL_BACK);  
					trigger[0].SetScale(1,1,1);
					trigger[0].Draw();
				mBorderShader.Stop();
			}
			
			break;
		}
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level6::UpdateLogic(dt)
{
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	// Debug function used to change the color of the lights in the room when certain keys are pressed
	UpdateLightsColor(&mLight1Diffuse, &mLight2Diffuse);
	
	cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	// I put the controller in front of the camera, for the debugging purposes, if VR isn't on
	if(!mIsVRon && mDebugVrOn)
	{
		mControllersArray[0].SetRotationMatrix(MatrixInverse_4(mCamera.GetRotationMatrix()));
		mControllersArray[1].SetRotationMatrix(MatrixInverse_4(mCamera.GetRotationMatrix()));
		mControllersArray[0].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR - [0.5*SCALE_FACTOR,0,0]);
		mControllersArray[1].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR + [0.5*SCALE_FACTOR,0,0]);	
	}
	else if(!mIsVrOn && !mDebugVrOn){
		for(var i = 0; i < len(mGuns); i++){
			mGuns[i].SetRotationMatrix(MatrixInverse_4(mCamera.GetRotationMatrix()));
			mGuns[i].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 1.2 * SCALE_FACTOR + [-0.5*(i-len(mGuns)/2)*SCALE_FACTOR,-0.5*SCALE_FACTOR,0]);
			
		}
	}
	
//	mCameraHitBoxObj.SetPosition(cameraPosition-[0,0.1*SCALE_FACTOR,0]);
	mCameraHitBoxObj.SetPosition(cameraPosition - [0, mCameraHitBoxHeight / 4.0, 0]);
	
	CounterKeyboardTesting();
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING: 
		{			
			if(mAnimator.HaveTransition(GL_LIGHT1, 5))
				mLight1Diffuse = mAnimator.GetCurrentStateInTransition(GL_LIGHT1, 5);
			if(mAnimator.HaveTransition(GL_LIGHT2, 5))
				mLight2Diffuse = mAnimator.GetCurrentStateInTransition(GL_LIGHT2, 5);
			
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();

			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2.0)
			{
				mLight0Position = [-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + mTranslateFactor;
				mLight1Position = [0, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + mTranslateFactor;
				mLight2Position = [0, 10.0 * SCALE_FACTOR, -20.0 * SCALE_FACTOR] + mTranslateFactor;
				
				mLight0.SetPosition(mLight0Position);
				mLight1.SetPosition(mLight1Position);
				mLight2.SetPosition(mLight2Position);
			}
			
			mOpenglTranslationOffset.y -= mCameraYoffset * dt;
			
		    mOpenglTranslationOffset.x += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
		    mOpenglTranslationOffset.y += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
			
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
				
				mOpenglTranslationOffset = mPreviousOpenglTranslationOffset;
			}
	
			break;
		}		
		case STATUS_ELEVATOR_ARRIVED:
		{
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{				
			HandleGuns();   
			UpdateWallHoles();
			CheckPickupGuns();	
			UpdateLasers(mTargets[0]);
			
			if(mAnimator.HaveTransition(mLightColorTransitionId, 6))
				mLight0Diffuse = mAnimator.GetCurrentStateInTransition(mLightColorTransitionId, 6);
				
			if(mAnimator.HaveTransition(mLightColorTransitionId+1, 6))
				mLight1Diffuse = mAnimator.GetCurrentStateInTransition(mLightColorTransitionId+1, 6);
				
			if(mAnimator.HaveTransition(mLightColorTransitionId+2, 6))
				mLight2Diffuse = mAnimator.GetCurrentStateInTransition(mLightColorTransitionId+2, 6);
				
			if(mLostTime > 0){					
				if(GetTime() - mLostTime > mTimeBeforeReset/mLastCounter){	
					--mCounter;
					UpdateCounter(mCounter, true);
					mLostTime = GetTime();
										
					if(mCounter <= 0){
						mLostTime = -1;	
						GenerateEnemies();
						foreach(var target in mTargets[0])
							target.Create();
					}								
				}
			}		
		 	else{
    			UpdateEnemies(mTargets[0]);    			
		 		UpdateStageStatus();		
			}
			
			if(mApplyPostProcessing)
    		{
    			if(GetTime() - mPostProcessingBlurTimer > 0.1)
    			{
    				mPostProcessingBlurTimer = GetTime();
    				mPostProcessingBlurShaderPasses++;
    				
    				if(mPostProcessingBlurShaderPasses >= 30)
		    			mApplyPostProcessing = false;
    			}
    		}    		
			break;
		}
		// Case where the level is ending: the only thing missing is the player inside the elevator
		case STATUS_LEVEL_ENDING:
		{			
			HandleGuns();   
			UpdateWallHoles();
			CheckPickupGuns();	
			UpdateLasers();
				
			// I check if the player goes inside the elevator. Note: I'm not checking that he enter from the doors; he can pass through walls right now
			if(mElevator.IsPointInElevator(cameraPosition) && !mEnding)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				// If the player is in, I start the timer to end the level
				mEnding = true;
				mEndTimer = GetTime();
			}
			
			// If the game is ending and it's been a while (so the doors of the elevator are closed now), I save the fact that the level has been completed
			if(mEnding && GetTime() - mEndTimer > mTimeToEnd)
				mIsLevelCompleted = true;
			
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}

/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level6::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	if(intersectedPlane == -1 || intersectedPlane == -2)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
		
	isWall = true;
	
	return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level6::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level6::GetOpenglTransformOffset()
{
	return mOpenglTranslationOffset; 
}

function Level6::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

function Level6::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, mLight0Diffuse); 
	glLight(GL_LIGHT1, GL_DIFFUSE, mLight1Diffuse); 
	glLight(GL_LIGHT2, GL_DIFFUSE, mLight2Diffuse);
}

function Level6::GetLightDiffuse(){
	return {mLight0Diffuse, mLight1Diffuse, mLight2Diffuse};
}

function Level6::GetLevelPreview(){
	return CVmTexture("Level6Prev.png");;
}

function Level6::GetLevelName(){
	return "War";
}

function Level6::ApplyPostProcessing(postProcessingShader, passes, postProcessingShaderParametersStrings, postProcessingShaderParameters)
{
	var hasToApplyBlur = mApplyPostProcessing;
	
	if(hasToApplyBlur)
	{
		postProcessingShader = mPostProcessingBlurShader;
		
		var viewport = array(4);
		viewport = glget(GL_VIEWPORT);
		
		var screenWidth = viewport[2];
		var screenHeight = viewport[3];
		
		aadd(postProcessingShaderParametersStrings, "resolution");
		aadd(postProcessingShaderParameters, [screenWidth, screenHeight]);
		
		passes = mPostProcessingBlurShaderPasses;
	}
	
	return hasToApplyBlur;
}

function Level6::UpdateCounter(num, toRandomPos){
	var digits = {};
	if(num > 9){
		aadd(digits, num/10);
		aadd(digits, num%10);
	}
	else{
		aadd(digits, 0);
		aadd(digits, num);
	}
	
	for(var j = 0; j < len(mCounterRandomMeshes); j++){
		var finalPos = mCounterRandomMeshes[j].GenerateFinalPositions(digits[j], mCounterPositions[j]);
		var objs = mCounterRandomMeshes[j].GetObjs();
		for(var i = 0; i < len(objs); i++){				
			objs[i].SetRotation(0,1,0,0);
			objs[i].SetRotation(0,0,1,0);
			objs[i].SetRotation(0,0,0,1);
			if(toRandomPos){
				var randomPos = mCounterRandomMeshes[j].GenerateRandomPositions(mCounterBox, mCounterPositions[len(mCounterRandomMeshes)-j-1]); 
				mAnimator.CreateTransition(objs[i], objs[i].GetPosition(), {randomPos,finalPos[i]}, 0.1, false, 1);
			}else
				mAnimator.CreateTransition(objs[i], objs[i].GetPosition(), finalPos[i], 0.2, false, 1);
		}
	}
}

function Level6::CounterKeyboardTesting(){
	var updated = false;
	var toRandomPos = false;
	if(KeyPressed("0")){			
		if(GetTime() - mLastCounterUpdate > 150){
			mCounter = (mCounter+1) % 100;
			mLastCounterUpdate = GetTime();	
			updated = true;		
			toRandomPos = true;
		}			
	}
	else if(KeyPressed("9")){
		if(GetTime() - mLastCounterUpdate > 150){
			mCounter = (mCounter-1 >= 0) ? mCounter-1 : mCounter;
			mLastCounterUpdate = GetTime();	
			updated = true;		
			toRandomPos = true;		
		}
	}else if(KeyPressed("2")){
		if(GetTime() - mLastCounterUpdate > 150){
			mCounter = (mCounter+1) % 100;
			mLastCounterUpdate = GetTime();	
			updated = true;				
		}
		
	}else if(KeyPressed("1")){
		if(GetTime() - mLastCounterUpdate > 150){
			mCounter = (mCounter-1 >= 0) ? mCounter-1 : mCounter;
			mLastCounterUpdate = GetTime();	
			updated = true;				
		}
	}	
	
	if(updated)
		UpdateCounter(mCounter, toRandomPos);
}

function Level6::CreateTargetsStage0(numTargets){
	var targets = {};
	var cubeSizes = 4*SCALE_FACTOR;	
	
	for(var i = 0; i < numTargets; i++){		
		var chosenMesh;
		switch(Rand(2)){
			case 0:{
				chosenMesh = CVmNewMesh(VRP_BOX, 1, [-cubeSizes/2, -cubeSizes/2, 0], [cubeSizes/2, cubeSizes/2, 0], cubeSizes);
				AddToonShaderToMesh(chosenMesh, [1,1,1], [1,1,0], [0.4, 0.4, 0.4], 100, 0, 2, SCALE_FACTOR, 1.0);
				break;				
			}case 1:{
				chosenMesh = CVmNewMesh(VRP_PYRAMID, 4, cubeSizes*1.25, cubeSizes*1.25);
				AddToonShaderToMesh(chosenMesh, [1,1,1], [1,1,0], [0.4, 0.4, 0.4], 100, 0, 2, SCALE_FACTOR, 1.0);
				break;				
			}case 2:{
				chosenMesh = CVmNewMesh(VRP_SPHERE, 10, cubeSizes, 1);
				AddToonShaderToMesh(chosenMesh, [1,1,1], [1,1,0], [0.4, 0.4, 0.4], 100, 0, 2, SCALE_FACTOR, 1.0);
				break;				
			}
		}
		var targetObj = CVmObj(chosenMesh);
		
		var roomPos = mMainRoom.GetPosition();		
		var roomWidth = mMainRoom.GetRoomWidth();
		var roomHeight = mMainRoom.GetRoomHeight();
		var roomDepth = mMainRoom.GetRoomDepth();
		
		var posX = (roomPos.x - roomWidth / 2.0) + Rand(roomWidth - 10.0 * SCALE_FACTOR);
		var posY = (roomPos.y - roomHeight / 2.0 +  5.0 * SCALE_FACTOR) + Rand(roomHeight - 10.0 * SCALE_FACTOR);
		var posZ = (roomPos.z) + Rand(roomDepth - 10.0 * SCALE_FACTOR);
		
		targetObj.SetPosition([posX, posY, posZ]);
		aadd(targets, Target(targetObj, 2, 500, [1,1,0], [1,0,0], [1,0,0], mEnemySpeed*1.4, false, false, true, true, mEnemyLaserSpeed/2, mEnemyLaserMesh, 20, 5000, mAnimator));
	}
	return targets;
}


function Level6::CreateTargetsStage1(numTargets){
	var targets = {};
	// Creating random star things
	for(var i = 0; i < numTargets; i++)
	{
		// To create the star object I use a function from the "Utils" file
		var color1 = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		var starObj = CreateStarThing(mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y, null, null, color1, [1,1,1]);		
		aadd(targets, Target(starObj, 5, 3000+(i*600), [1,1,1], [1,0,0], [1,0,0], mEnemySpeed, true, true, true, false, mEnemyLaserSpeed, mEnemyLaserMesh, 20, 5000, mAnimator));
	}
	
	return targets;
}


function Level6::CreateMeshesBossStage(){
	mBossStageMeshes = {};
//	var cubeSizes = 6*SCALE_FACTOR;
//	var bossMesh = CVmNewMesh(VRP_BOX, 1, [-cubeSizes/2, -cubeSizes/2, 0], [cubeSizes/2, cubeSizes/2, 0], cubeSizes);
	for(var i = 0; i < 4; i++){	
		var chosenMesh;
		var color;
		switch(i){
			case 0:{
				chosenMesh = CVmNewMesh("Enemies/S1.AAM");
				chosenMesh.Scale(1.1, 1.1, 1.1);
				color = [0.2,0.1,1];
//				AddToonShaderToMesh(chosenMesh, [1,1,1], [1,0,0], [0.4, 0.4, 0.4], 50, 0, 2, SCALE_FACTOR, 1.0);
				break;				
			}case 1:{
				chosenMesh = CVmNewMesh("Enemies/S2.AAM");
				chosenMesh.Scale(0.2, 0.2, 0.2);
				color = [1,1,0];
//				AddToonShaderToMesh(chosenMesh, [1,1,1], [0,1,0], [0.4, 0.4, 0.4], 50, 0, 2, SC3ALE_FACTOR, 1.0);
				break;				
			}case 2:{
				chosenMesh = CVmNewMesh("Enemies/S3.AAM");
				chosenMesh.Scale(0.2, 0.2, 0.2);
				color = [0,1,0.2];
//				AddToonShaderToMesh(chosenMesh, [1,1,1], [0,0,0], [0.4, 0.4, 0.4], 50, 0, 2, SCALE_FACTOR, 1.0);
				break;				
			}case 3:{
				chosenMesh = CVmNewMesh("Enemies/S5.AAM");
				chosenMesh.Scale(0.1, 0.1, 0.1);
				color = [0,1,1];
//				AddToonShaderToMesh(chosenMesh, [1,1,1], [0,0,0], [0.4, 0.4, 0.4], 50, 0, 2, SCALE_FACTOR, 1.0);
				break;				
			}
		}
		chosenMesh.ShaderAdd("SimpleColorShader.glsl", 0);
		chosenMesh.ShaderSetParameter(0,"diffuse", 0, color);
		chosenMesh.ShaderSetParameter(0,"alpha", 0, 1.0);
		chosenMesh.ShaderSetParameter(0,"outlinecolor", 0, [0,0,0]);
		chosenMesh.ShaderActivate(true);
//		aadd(targetsMeshes, Target(CVmObj(chosenMesh), 30, 2500, color, [1,0,0], color, mEnemySpeed*2, true, true, true, false, mEnemyLaserSpeed*2, mEnemyLaserMesh, 20, 5000, mAnimator, true));	
		aadd(mBossStageMeshes, chosenMesh);		
	}
	
	return mBossStageMeshes;
}


function Level6::CreateTargetsBossStage(){
	var targets = {};
	foreach(var mesh in mBossStageMeshes){		
		var color = [0,0,0];
		mesh.ShaderGetUniformValue(0, 0, "diffuse", &color, null);
		aadd(targets, Target(CVmObj(mesh), 30, 2500, color, [1,0,0], color, mEnemySpeed*2, true, true, true, false, mEnemyLaserSpeed*2, mEnemyLaserMesh, 20, 5000, mAnimator, true));
	}
	
	return targets;	
}

function Level6::DrawHUD(eye){
	if(!mIsVrOn)
		mCameraHudObj.SetPosition(-0.99,-0.99,0.0);
	else{
		if(eye == 1)
			mCameraHudObj.SetPosition(-0.35,-0.40,0.0);
		else if(eye == 2){
			mCameraHudObj.SetPosition(-0.46,-0.40,0.0);			
		}
	}
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[4], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable( GL_LIGHTING );
    
    
	var color = mAnimator.GetCurrentStateInTransition(mCameraHudColorAnimId, 6);
	var alpha = mAnimator.GetCurrentStateInTransition(mCameraHudColorAnimId+1, 6);
	if(color == Void || alpha == Void){
		color = [1,1,1];
		alpha = 0.0;			
	}
	
	mCameraHudObj.Draw();
    
    glBegin(GL_QUADS);
	    glColor(color.r, color.g, color.b, alpha);
	    glVertex(-1.0, -1.0);
	    glVertex(1.0, -1.0);
	    glVertex(1.0, 1.0);
	    glVertex(-1.0, 1.0);
	glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}

function Level6::GenerateEnemies(){
	mTargets = {};
	aadd(mTargets, CreateTargetsStage0(10));
	aadd(mTargets, CreateTargetsBossStage());
	aadd(mTargets, CreateTargetsStage1(6));	
}



/*
 * This method works the same as the one in Level1, except for the array of controllers used to check the points
 */
function Level6::HandleGuns()
{
	if(KeyPressed("z")){		
		mGuns[0].Destroy();
		mControllersArray[0].GetObj().SetScale([0,0,0]);
	}	
	
	if(KeyPressed("x")){		
		mGuns[1].Destroy();
		mControllersArray[1].GetObj().SetScale([0,0,0]);
	}	
				
	// Now I check if the player is drawing; I first check if he pressed a button
	var gunsBullets = {};
	for(var i = 0; i < len(mGuns); i++){
		var gun = mGuns[i];
		gun.UpdateGun();
		
		if(!gun.IsDestroyed()){
			var isPressing = (mIsVrOn || mDebugVrOn) ? mInputManager.IsPressingPrimaryButton(mControllersArray[i].GetIndex()) : mInputManager.IsPressingPrimaryButton();
						
			if(isPressing){
				if(gun.IsSingleShot()){
					if(mControllersBeingUsedIndex[i] == 0){
						mControllersBeingUsedIndex[i] = i+1;
						aadd(gunsBullets, gun.Shoot());	
					}			
				}
				else{
					aadd(gunsBullets, gun.Shoot());	
				}			
			}
			else if(mControllersBeingUsedIndex[i] != 0){
				mControllersBeingUsedIndex[i] = 0;
			}		
		}
		else if(gun.IsDestroyed() && (mDebugVrOn || mIsVrON)){
			if(mControllersArray[i].GetObj().GetScale() == [0,0,0])
				mAnimator.CreateScalingTransition(mControllersArray[i].GetObj(), [0.01, 0.01, 0.01], [1,1,1], 0.25, false);					
		}
	}
	
	foreach(var gunBullets in gunsBullets){
		if(gunBullets != Void){
			foreach(var bullet in gunBullets){
				if(bullet != Void){
					aadd(mBulletsArray, bullet);
				}
			}		
		}
	}
}

function Level6::CheckPickupGuns(){
	if(mIsVrOn || mDebugVrOn){
		var isControllerInsideOneTrigger = {};
		var isControllerNearOneTrigger = {};	
		foreach(var gun in mGuns){
			aadd(isControllerInsideOneTrigger, false);
			aadd(isControllerNearOneTrigger, false);
		}	
			
		for(var i = 0; i < len(mControllersArray); i++){
			var controller = mControllersArray[i];
			foreach(var trigger in mGunsEventTriggers){
				var distance = Modulus(trigger[0].GetPosition()-controller.GetPosition());
				if(distance <= mPowerSphereRadius*1.5){
					isControllerNearOneTrigger[i] = true;
					if(distance <= mPowerSphereRadius){
						isControllerInsideOneTrigger[i] = true;								
						if(!mIsControllerInsideTrigger[i]){
							mIsControllerInsideTrigger[i] = true;
							if(trigger[1].__GetName() == "GUN"){
								if(mGuns[i].IsDestroyed()){
									mGuns[i].Recreate();
									mGuns[i].SwitchGunAnimation(mControllersArray[i].GetObj());	
								}else{
									mGuns[i].SwitchGunAnimation();								
								}
								mGuns[i].Copy(trigger[1]);
								mGuns[i].LinkToController(controller);	
							}
							else{
								if(!mGuns[i].IsDestroyed()){
									mGuns[i].Destroy();
									if(mIsVrON || mDebugVrOn){
										mControllersArray[i].GetObj().SetScale([0,0,0]);				
									}								
								}								
							}	
						}							
					}
				}
			}
		}
		
		for(var i = 0; i < len(mGuns); i++){
			if(mGuns[i].IsDestroyed() && (mIsVrOn || mDebugVrOn)){
				mControllersArray[i].SetActionAvailable(isControllerNearOneTrigger[i]);
			}
			else{
				mGuns[i].SetActionAvailable(isControllerNearOneTrigger[i]);
			}
		}
		
		for(var i = 0; i < len(isControllerInsideOneTrigger); i++){
			mIsControllerInsideTrigger[i] = isControllerInsideOneTrigger[i];
		}
	}
	else{
		var isInside = false;
		var isNear = false;
		foreach(var trigger in mGunsEventTriggers){
			var distance = Modulus(trigger[0].GetPosition()-cameraPosition);
			if(distance <= mPowerSphereRadius*2.6){				
				isNear = true;
				if(distance <= mPowerSphereRadius*1.8){
					isInside = true;								
					if(!mIsCameraInsideTrigger){	
						if(trigger[1].__GetName() == "GUN"){
							foreach(var gun in mGuns){
								gun.SwitchGunAnimation();	
								gun.Copy(trigger[1]);							
							}							
						}
						else{
							foreach(var gun in mGuns){
								gun.Destroy();								
							}						
						}
					}							
				}
			}
		}
		
		foreach(var gun in mGuns){
			if(gun.IsDestroyed()){
				gun.SetActionAvailable(isNear);				
			}
		}		
					
		mIsCameraInsideTrigger = isInside;
	}
}

function Level6::UpdateWallHoles(){
	for(var i = 0; i < len(mWallsHolesObjs); i++){
		var wallHole = mWallsHolesObjs[i];
		if(GetTime() - wallHole[1] > mWallsHolesLife){
			adel(mWallsHolesObjs,i);
		}
	}
}

function Level6::UpdateLasers(targets){
	var stageTargets = targets == Void ? {} : targets;
	for(var i = 0; i < len(mBulletsArray); i++){
		var bulletObj = mBulletsArray[i].GetObj();
		var bulletMaxLife = mBulletsArray[i].GetMaxLife();
		var bulletShotTIme = mBulletsArray[i].GetShotTime();
		var bulletPower = mBulletsArray[i].GetPower();
		var isEnemyBullet = mBulletsArray[i].IsEnemy();
		
		var isPointValid = mMainRoom.IsPointInRoom(bulletObj.GetPosition()) && !mElevator.IsPointInElevator(bulletObj.GetPosition());
		
		if(!isPointValid){
			
			var contactPoint;
			var normal;
			var isWall;
			
			// I have to find out the direction of the bullet; I do so considering another point of the bullet and subtracting with the origin
			var direction = Norm(bulletObj.GetPosition() - bulletObj.LocalToWorld([0, 0, -1]));
			
			var rayStart;
			var rayEnd;
			
			// To find the intersection I consider an infinite ray along the direction of the bullet, but there is a problem: if we're intersecting
		    // with the elevator, the ray must go in the opposite direction, otherwise it basically finds the intersection not in the wall
		    // the bullet hit but as if it passed through the wall and hit the wall after it
			if(mElevator.IsPointInElevator(bulletObj.GetPosition()))
			{
				rayStart = bulletObj.GetPosition() + direction * mCamera.GetZFar();
				rayEnd = bulletObj.GetPosition() - direction * mCamera.GetZFar();
			}
			else
			{
				rayStart = bulletObj.GetPosition() - direction * mCamera.GetZFar();
				rayEnd = bulletObj.GetPosition() + direction * mCamera.GetZFar();
			}
			
			// I check the intersection with a wall, using as raycast the ray that starts at the point of the laser cone and ends
			// at the base of the cone
			IsPointedPositionValid(rayStart, rayEnd, &contactPoint, &normal, &isWall);
			
			// If a contact point was found, I use that point
			if(contactPoint != Void)
			{
				// I move the point a bit towards the laser original direction, otherwise the hole object intersects the wall
				contactPoint = contactPoint + direction * 0.1 * SCALE_FACTOR;
				
				var holeObj = CvmObj(CvmNewMesh(VRP_CIRCLE, 30, 0.05*SCALE_FACTOR, 1));
				
				// Since the center of the box is at its feet, moving it at the coordinates of the previous point and then applying the rotation works perfectly
				holeObj.SetPosition(contactPoint);
				
				// I check the normal vector in order to rotate the circle accordingly
				if(abs(normal.x) == 1)
					holeObj.SetRotation(90, 0, 0, 1);
				else if(abs(normal.z) == 1)
					holeObj.SetRotation(90, 1, 0, 0);
				else
					holeObj.SetRotation(0, 0, 1, 0);
					
				aadd(mWallsHolesObjs, {holeObj, GetTime()});
			}

			adel(mBulletsArray, i);
		}
		else if(GetTime() - bulletShotTIme > bulletMaxLife){
			adel(mBulletsArray, i);
		}
		else if(isEnemyBullet){
//			var cameraHasBeenHit = mCameraHitBoxObj.IsCollidingBBox(bulletObj);
			var rayStart = bulletObj.GetPosition();
			var rayEnd = bulletObj.LocalToWorld([0, 1 * SCALE_FACTOR, 0]);
			
			var cameraHasBeenHit = mCameraHitBoxObj.IsColliding(rayStart, rayEnd);

			if(cameraHasBeenHit){
				outputln("CAMERA HAS BEEN HIT");
				mCameraHit = true;
				mLife--;
				mAnimator.CreateGenericTransition(mCameraHudColorAnimId, [1,1,1], {[1,0,0], [1,1,1]}, 0.4);
				mAnimator.CreateGenericTransition(mCameraHudColorAnimId+1, 0, {0.3, 0}, 0.4);
				
				mApplyPostProcessing = true;
				mPostProcessingBlurTimer = GetTime();
				mPostProcessingBlurShaderPasses = 0;
				
				if(mLife <= 0){
					mLife = mDefaultLife;
					
					foreach(var target in mTargets[0]){
						target.Kill();
						aadd(mAnimatingTargets, target);
					}
					mAnimator.CreateGenericTransition(mLightColorTransitionId, mLight0Diffuse, {[1,0,0], mLight0Diffuse}, mTimeBeforeReset/1000);
					mAnimator.CreateGenericTransition(mLightColorTransitionId+1, mLight1Diffuse, {[1,0,0], mLight1Diffuse}, mTimeBeforeReset/1000);
					mAnimator.CreateGenericTransition(mLightColorTransitionId+2, mLight2Diffuse, {[1,0,0], mLight2Diffuse}, mTimeBeforeReset/1000);
					mLastCounter = mCounter;
					mLostTime = GetTime();
					
				}
				mCameraHudLife.Load(str(mLife));
			}    				
		}
		else if(!isEnemyBullet){    				
    		for(var j = 0; j < len(stageTargets); j++)
    		{		    			
    			var target = stageTargets[j];    			
    			var hasBeenHit = target.IsCollidingBBox(bulletObj);
    			
    			if(hasBeenHit) //if the laser hit something or has been in the system for too long
				{
					adel(mBulletsArray, i);    					
					
					if(target.Hit() && target.RemoveLife(bulletPower) <= 0){
						outputln("ENEMY KILLED");
						target.Kill();
    					mCounter = (mCounter + 1) % 100;
						UpdateCounter(mCounter, false);	
					}
				}    
    		}
		}
	}
}

function Level6::UpdateEnemies(targets){
	var stageTargets = targets == Void ? {} : targets;
	for(var i = 0; i < len(stageTargets); i++)
	{    			  
		var target = stageTargets[i];		
//		var enemyBullet = target.Shoot(cameraPosition);
		var enemyBullet = target.Shoot(mCameraHitBoxObj.GetPosition());
		if(enemyBullet != Void){
			aadd(mBulletsArray, enemyBullet);	
		}    			
		
		target.Update(mMainRoom);
		
		if(target.IsDead())
			adel(stageTargets, i);
	}
	
	for(var i = 0; i < len(mAnimatingTargets); i++){
		if(mAnimatingTargets[i].IsDead())
			adel(mAnimatingTargets, i);
	}
}


function Level6::UpdateStageStatus(){
	if(len(mTargets[0]) < 1){
		mCurrentStage++;
		adel(mTargets, 0);
		if(len(mTargets) <= 0){
			outputln("ALL TARGETS KILLED");
			var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
			var rightDoorPos = mElevator.GetRightDoor().GetPosition();
			
			mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
			mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
			foreach(var gun in mGuns){
				gun.Destroy();
			}
			if(mIsVrON || mDebugVrOn){
				mControllersArray[0].GetObj().SetScale([0,0,0]);
				mControllersArray[1].GetObj().SetScale([0,0,0]);					
			}
			mLevelStatus = STATUS_LEVEL_ENDING;
		}
		else{
			foreach(var target in mTargets[0])
				target.Create();
		}
	}	
}