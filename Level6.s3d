#define STATUS_ELEVATOR_MOVING 0
#define STATUS_ELEVATOR_ARRIVED 1
#define STATUS_LEVEL_STARTED 2
#define STATUS_LEVEL_ENDING 3

#define STAGE_0 0
#define STAGE_1 1
#define STAGE_2 2

/*
 * This level is strictly related to Level1; most of the things were copied and pasted. Comments will be on the parts that are different
 */
class Level6
{
	var mTexture;
	var mIsVRon;
	var mDebugVrOn;
	
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	var mTimeToEnd;
	
	var mLevelStatus;
	
	var mInputManager;
	var mAnimator;
	var mSoundManager;
	
	var mCamera;
	var cameraPosition;
	
	var mLight0;
	var mLight1;
	var mLight2;
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	var mLight0Diffuse;
	var mLight1Diffuse;
	var mLight2Diffuse;
	
	var mMainRoom;
	var mElevator;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;
	
	var mOpenglTranslationOffset;
	var mPreviousOpenglTranslationOffset;
	
	var mControllersArray;
	var mGunsObj;
	
	var mDrawingShader;
	var mLinesTimeVariable;

	var mAllLasersArrays;
	var mPistolsLaserArray;
	var mEnemyLaserArray;
	var mLaserMaxDistance;
	var mLaserMesh;
	var mLaserTestObj;
	var mLaserLength;
	var mLaserWidth;
	var mLaserSpeed;
	var mEnemyLaserSpeed;
	
	var mEnemySpeed;
	
	var mLastShoot;
	var mShootingDelay;
	
	var mTargets;
	var mCurrentTargets;
	
	var mControllersBeingUsedIndex;
	
	var mCounterPositions;
	var mCounterBox;
	var mCounterRandomMeshes;
	var mCounter;
	var mLastCounterUpdate;
	var mCounterShader;
	
//	var mFrontText;
//	var mBackText; 
//	var mLeftText; 
	
	var mDebugController;
	var mDebugControllerHidden;
	var mDebugKeyHit;
	
	var mTranslateFactor;
	
	var mShootingGun;
	var mGunRotation;
	var mShootingAnimTime;
	var mShootingAnimationTimes;
	var mShootingOffsets;
	var mShootingDepth;
	var mIsControllerShooting;
	var mControllerShotTime;
	var mControllerAnimId;
	
	var mCurrentStage;
	
	// Private functions
	HandleLasers();
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset, prevLightDiffuse);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall, isLaser);
	GetOpenglTransformOffset();
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	SetupOpenglLights();
	GetLightDiffuse();
	GetLevelPreview();
	GetLevelName();
	UpdateCounter(num, toRandomPos);
};

function Level6::Level6(isVRon, inputManager, soundManager)
{		
	mTexture = CVmTexture("Level2Prev.png");
	mIsVRon = isVRon;
	mDebugVrOn = false;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	
	mTranslateFactor = [0, 0, -20 * SCALE_FACTOR];
	
	mEnding = false;
	mIsLevelCompleted = false;
	mTimeToEnd = 2500;
		
	mAnimator = Animator();
	
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH - 25 * SCALE_FACTOR, ROOM_SIDE_WALL_WIDTH - 25 * SCALE_FACTOR, ROOM_HEIGHT, true, 1, 2);
	mMainRoom.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);
	
	mDrawingShader = CVmShaderProgram("drawingShader.glsl");
	mCounterShader = CVmShaderProgram("void main(void) { gl_Position = ftransform(); }", "uniform vec3 color; void main (void) { gl_FragColor = vec4(color, 1.0); }", true);
	mLinesTimeVariable = 0;
	mShootingGun = 0;
		
	mControllersBeingUsedIndex = {0, 0};
	
	mControllersArray = {};
		
	mGunsObj = {};
	aadd(mGunsObj, CvmObj(CVmNewMesh("scifiGun/SciFiGun.AAM")));
	aadd(mGunsObj, CvmObj(CVmNewMesh("scifiGun/SciFiGun.AAM")));
	mGunsObj[0].SetScale(0.03,0.03,0.03);
	mGunsObj[1].SetScale(0.03,0.03,0.03);
	
	if(mIsVRon)
	{
		var controller1 = mInputManager.GetController(1);
		var controller2 = mInputManager.GetController(2);
		controller1.SetCustomMesh(CVmNewMesh("scifiGun/SciFiGun.AAM"), 0.1);
		controller2.SetCustomMesh(CVmNewMesh("scifiGun/SciFiGun.AAM"), 0.1);
		aadd(mControllersArray, controller1);
		aadd(mControllersArray, controller2);
	}
	else if(mDebugVrOn)
	{
		mGunsObj[0].GetMesh().Rotate(90,0,1,0);
		mGunsObj[1].GetMesh().Rotate(90,0,1,0);
		aadd(mControllersArray, ViveController(1, mGunsObj[0]));
		aadd(mControllersArray, ViveController(2, mGunsObj[1]));
		
		mDebugController = mControllersArray[0];
		mDebugControllerHidden = false;
		mDebugKeyhit = false;
	}
	else{
		mGunRotation = {90, 90};
	}
	
	mCounter = 0;
	mLastCounterUpdate = 0;
	mCounterPositions = {};
	var cubeSizes = 1.5 *SCALE_FACTOR;
	var cubeSpacing = 0.20 *SCALE_FACTOR;
	var numberSpacing = 0.8*SCALE_FACTOR;
	mCounterBox = [6*(cubeSizes+cubeSpacing)/2, 10*(cubeSizes+cubeSpacing)/2, 6*(cubeSizes+cubeSpacing)/2];
	var digitWidth = 6*(cubeSizes+cubeSpacing)-cubeSpacing;
	var counterMesh = CVmNewMesh(VRP_BOX, 1, [-cubeSizes/2, -cubeSizes/2, 0], [cubeSizes/2, cubeSizes/2, 0], cubeSizes);
	mCounterRandomMeshes = {};
	aadd(mCounterPositions, [digitWidth/2+numberSpacing/2, 6*SCALE_FACTOR, -mMainRoom.GetRoomWidth()/2-cubeSizes]+mTranslateFactor);
	aadd(mCounterPositions, mCounterPositions[0]-[digitWidth+numberSpacing,0,0]);
	aadd(mCounterRandomMeshes, RandomMeshes(counterMesh, 54, mCounterBox, mCounterPositions[0], [0.8,0.2,0.2], cubeSizes, cubeSpacing, -1));
	aadd(mCounterRandomMeshes, RandomMeshes(counterMesh, 54, mCounterBox, mCounterPositions[1], [0.2,0.4,1], cubeSizes,cubeSpacing, -1));
	UpdateCounter(0, false);

	mLastShoot = 0;
	mShootingDelay = 150.0;
	mShootingDepth = 4*SCALE_FACTOR;
	mIsControllerShooting = {false, false};
	mControllerShotTime = {0,0};
	mControllerAnimId = {12345, 54321};
	
	
	mPistolsLaserArray = {};
	mEnemyLaserArray = {};
	mAllLasersArrays = {};
	aadd(mAllLasersArrays, mPistolsLaserArray);
	aadd(mAllLasersArrays, mEnemyLaserArray);
	
	mLaserMaxDistance = 500;
	mLaserLength = 0.65;
	mLaserWidth = 0.025;
	mLaserMesh = CvmNewMesh(VRP_CYLINDER, 30, mLaserWidth*SCALE_FACTOR, -mLaserLength*SCALE_FACTOR, 1);
	mLaserMesh.Rotate(90,1,0,0);
	mLaserTestObj = CvmObj(mLaserMesh);
	mLaserSpeed = 1;
	mEnemyLaserSpeed = mLaserSpeed*15;
	mEnemySpeed = 5.0;
	
	mTargets = {};
	mCurrentTargets = {};
	var targetsNumber = 10;
	var stage0targetsNumber = 3;
		
//	var enemyLaserMesh = CvmNewMesh(VRP_SPHERE, 30, 0.3*SCALE_FACTOR, 1);
	var enemyLaserMesh = CvmNewMesh(VRP_CYLINDER, 30, mLaserWidth*SCALE_FACTOR, -mLaserLength*SCALE_FACTOR, 1);
	
	// Creating random star things
	for(var i = 0; i < targetsNumber; i++)
	{	
		// Creating 2 random colors to change over time
		var color1 = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		var color2 = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		
		// To create the star object I use a function from the "Utils" file
		var starObj = CreateStarThing(mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y, null, null, color1, [1,1,1]);

//		var cubeSizes = 3*SCALE_FACTOR;
//		var mesh = CVmNewMesh(VRP_BOX, 1, [-cubeSizes/2, -cubeSizes/2, 0], [cubeSizes/2, cubeSizes/2, 0], cubeSizes);
//		AddToonShaderToMesh(mesh, [1,1,1], [1,1,1], [0.4, 0.4, 0.4], 50, 0, 2, SCALE_FACTOR, 1.0);		
//		var starObj = CVmObj(mesh);
		
		var roomPos = mMainRoom.GetPosition();
		var roomWidth = mMainRoom.GetRoomWidth();
		var roomHeight = mMainRoom.GetRoomHeight();
		var roomDepth = mMainRoom.GetRoomDepth();
		
		var posX = (roomPos.x - roomWidth / 2.0) + Rand(roomWidth - 10.0 * SCALE_FACTOR);
		var posY = (roomPos.y - roomHeight / 2.0 +  5.0 * SCALE_FACTOR) + Rand(roomHeight - 10.0 * SCALE_FACTOR);
		var posZ = (roomPos.z) + Rand(roomDepth - 10.0 * SCALE_FACTOR);
		
		var time = 140.0 + (Rand(1) == 1 ? (Rand(10) / 2.0) : -(Rand(10) / 2.0));
		var rotationAxis = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
	
		// Creating the transitions
		mAnimator.CreateRotatingTransition(starObj, 0, 360, rotationAxis, 5.0 + Rand(5) / 2.0, true, false);
		starObj.SetPosition([posX, posY, posZ]);
		
		var targetObject = Target(starObj, 3, 2500, [1,1,1], [1,0,0], mEnemySpeed, mEnemyLaserSpeed, enemyLaserMesh, 20, mAnimator);
		
		aadd(mTargets, targetObject);
		
		if(i < stage0targetsNumber)
			aadd(mCurrentTargets, mTargets[i]);
	}
	
	mCurrentStage = 0;
	
	// Creating texts object for the scene
//	mFrontText = Text("If you can't find your hands,\nmaybe you're looking in the wrong place", 2.0);
//	mFrontText.Rotate(180, 0, 1, 0);
}


 
 function Level6::Init(lights, lightsDiffuse, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Diffuse = [1, 1, 1];
	mLight1Diffuse = [0.612865, 0.0750434, 1.08279];
	mLight2Diffuse = [0.172785, 1.00443, 0.488585];
	
	mLight0 = lights[0];
	mLight0.SetDiffuse(mLight0Diffuse.x, mLight0Diffuse.y, mLight0Diffuse.z);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetDiffuse(mLight1Diffuse.x, mLight1Diffuse.y, mLight1Diffuse.z);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetDiffuse(mLight2Diffuse.x, mLight2Diffuse.y, mLight2Diffuse.z);
	mLight2.Enable();
	
		
	mElevator = elevator;
	
	mCamera = mInputManager.GetActiveCamera();
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 1.5;
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	mLight1.SetPosition(mLight1.GetPosition() - [0, mElevatorTravelDistance, 0]);
	mLight2.SetPosition(mLight2.GetPosition() - [0, mElevatorTravelDistance, 0]);
	
	mLight0Position = mLight0.GetPosition();
	mLight1Position = mLight1.GetPosition();
	mLight2Position = mLight2.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
	
	mCameraYoffset = mElevatorTravelDistance / mElevatorTravelTime;
	mPreviousOpenglTranslationOffset = mOpenglTranslationOffset; 
	mOpenglTranslationOffset.y += mElevatorTravelDistance;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
	
	// I move the room a bit so that the elevator is completely in the center of the room
	mMainRoom.Translate(-mElevator.GetRoomDepth() / 2.0 + 3.0 * SCALE_FACTOR, 0, -mElevator.GetRoomWidth() / 2.0);
	
	// I set now the position of a text that needed to know where the elevator was
//	mFrontText.SetPosition([0, 7.0 * SCALE_FACTOR, mMainRoom.GetRoomDepth()/2 - 0.1 * SCALE_FACTOR -mElevator.GetRoomWidth() / 2.0] + mTranslateFactor);
//	mBackText.SetPosition(mElevatorFinalPosition + [0.1 * SCALE_FACTOR, 1 * SCALE_FACTOR, -0.1 * SCALE_FACTOR]);
//	mLeftText.SetPosition([mMainRoom.GetRoomWidth()/2 - 2.1 * SCALE_FACTOR, 7.0 * SCALE_FACTOR, -mElevator.GetRoomWidth() / 2.0] + mTranslateFactor);
	
	mAnimator.CreateLightColorTransition(GL_LIGHT1, lightsDiffuse[1], mLight1Diffuse, mElevatorTravelTime);
	mAnimator.CreateLightColorTransition(GL_LIGHT2, lightsDiffuse[2], mLight2Diffuse, mElevatorTravelTime);
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */


/*
 * Render method
 */
function Level6::Render()
{	
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);	
	
	mElevator.Draw();

	// Drawing the controllers and their duplicates. If any controller is invisible, the draw will have no effect
	if(mIsVrOn || mDebugVrOn){
		for(var i = 0; i < len(mControllersArray); i++)
			mControllersArray[i].Draw();		
	}
	
	
	if(!mIsVrOn && !mDebugVrOn){
		mGunsObj[0].Draw();
		mGunsObj[1].Draw();	
	}
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_ENDING:
		case STATUS_LEVEL_STARTED:
		{
			mMainRoom.Draw();
			
			mLinesTimeVariable += 0.01;
			
			foreach(var target in mCurrentTargets)
				target.Draw();
			
			mCounterShader.Start();
				mCounterShader.SetParameter("color", [1,0,0]);
//				mLaserTestObj.Draw();
				foreach(var laser in mPistolsLaserArray)
					laser.Draw();
					
				foreach(var enemyLaser in mEnemyLaserArray)
					enemyLaser.Draw();
					
				for(var i = 0; i < len(mCounterRandomMeshes); i++){
					foreach(var obj in mCounterRandomMeshes[i].GetObjs()){
						mCounterShader.SetParameter("color", mCounterRandomMeshes[i].GetColor());
						obj.Draw();
						mCounterShader.SetParameter("color", [0,0,0]);
						glLineWidth(2.0);
						obj.Draw(VR_BBOX_ONLY);
					}			
				}
			mCounterShader.Stop();
			
			
			// Drawing the texts
//			mFrontText.Draw();
//			mBackText.Draw();
//			mLeftText.Draw();

			break;
		}
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level6::UpdateLogic(dt)
{
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	// Debug function used to change the color of the lights in the room when certain keys are pressed
	UpdateLightsColor(&mLight1Diffuse, &mLight2Diffuse);
	
	cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	// I put the controller in front of the camera, for the debugging purposes, if VR isn't on
	if(!mIsVRon && mDebugVrOn)
	{
		mLaserTestObj.SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR);
		mControllersArray[0].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR - [0.5*SCALE_FACTOR,0,0]);
		mControllersArray[1].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR + [0.5*SCALE_FACTOR,0,0]);	
		
		if(KeyPressed("Y"))
		{
			if(!mDebugKeyHit)
			{
				if(mDebugControllerHidden)
					mDebugController.Unhide();
				else
					mDebugController.Hide();
					
				mDebugControllerHidden = !mDebugControllerHidden;
				mDebugKeyHit = true;
			}
		}
		else
			mDebugKeyHit = false;

		
		static var rotX = 0;
		static var rotY = 0;
		static var rotZ = 0;
			
		if(KeyPressed("J"))
			rotX += 1;
		
		if(KeyPressed("L"))
			rotX -= 1;
			
		if(KeyPressed("I"))
			rotY += 1;
		
		if(KeyPressed("K"))
			rotY -= 1;
			
		if(KeyPressed("U"))
			rotZ += 1;
		
		if(KeyPressed("O"))
			rotZ -= 1;
		
		mDebugController.SetRotation(90, 0, 1, 0);
		mDebugController.Rotate(rotY, 1, 0, 0);
		mDebugController.Rotate(rotX, 0, 1, 0);
		mDebugController.Rotate(rotZ, 0, 0, 1);
	}
	
	if(!mIsVrOn && !mDebugVrOn){
		mGunsObj[0].SetRotationMatrix(MatrixInverse_4(mCamera.GetRotationMatrix()));
		mGunsObj[1].SetRotationMatrix(MatrixInverse_4(mCamera.GetRotationMatrix()));
		mGunsObj[0].Rotate(mGunRotation[0],0,1,0);
		mGunsObj[1].Rotate(mGunRotation[1],0,1,0);
		mGunsObj[0].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 1.2 * SCALE_FACTOR + [-0.5*SCALE_FACTOR,-0.5*SCALE_FACTOR,0]);
		mGunsObj[1].SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 1.2 * SCALE_FACTOR + [0.5*SCALE_FACTOR,-0.5*SCALE_FACTOR,0]);
	}
	
	var updated = false;
		var toRandomPos = false;
		if(KeyPressed("0")){			
			if(GetTime() - mLastCounterUpdate > 150){
				mCounter = (mCounter+1) % 100;
				mLastCounterUpdate = GetTime();	
				updated = true;		
				toRandomPos = true;
			}			
		}
		else if(KeyPressed("9")){
			if(GetTime() - mLastCounterUpdate > 150){
				mCounter = (mCounter-1 >= 0) ? mCounter-1 : mCounter;
				mLastCounterUpdate = GetTime();	
				updated = true;		
				toRandomPos = true;		
			}
		}else if(KeyPressed("2")){
			if(GetTime() - mLastCounterUpdate > 150){
				mCounter = (mCounter+1) % 100;
				mLastCounterUpdate = GetTime();	
				updated = true;				
			}
			
		}else if(KeyPressed("1")){
			if(GetTime() - mLastCounterUpdate > 150){
				mCounter = (mCounter-1 >= 0) ? mCounter-1 : mCounter;
				mLastCounterUpdate = GetTime();	
				updated = true;				
			}
		}		
//		else if(GetTime() - mLastCounterUpdate > 1000){
//			mCounter = (mCounter+1) % 100;
//			mLastCounterUpdate = GetTime();	
//			updated = true;		
//			toRandomPos = true;		
//			outputln("yolo");
//		}
		
		if(updated)
			UpdateCounter(mCounter, toRandomPos);
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING: 
		{			
			if(mAnimator.HaveTransition(GL_LIGHT1, 5))
				mLight1Diffuse = mAnimator.GetCurrentStateInTransition(GL_LIGHT1, 5);
			if(mAnimator.HaveTransition(GL_LIGHT2, 5))
				mLight2Diffuse = mAnimator.GetCurrentStateInTransition(GL_LIGHT2, 5);
			
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();

			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2.0)
			{
				mLight0Position = [-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + mTranslateFactor;
				mLight1Position = [0, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + mTranslateFactor;
				mLight2Position = [0, 10.0 * SCALE_FACTOR, -20.0 * SCALE_FACTOR] + mTranslateFactor;
				
				mLight0.SetPosition(mLight0Position);
				mLight1.SetPosition(mLight1Position);
				mLight2.SetPosition(mLight2Position);
			}
			
			mOpenglTranslationOffset.y -= mCameraYoffset * dt;
			
		    mOpenglTranslationOffset.x += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
		    mOpenglTranslationOffset.y += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
			
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
				
				mOpenglTranslationOffset = mPreviousOpenglTranslationOffset;
			}
	
			break;
		}		
		case STATUS_ELEVATOR_ARRIVED:
		{
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{			
    		HandleLasers();
    		
    		foreach(var lasersArray in mAllLasersArrays){
	    		for(var i = 0; i < len(lasersArray); i++)
	    		{
	    			var laserObj = lasersArray[i];
	    			var contactPoint;
	    			var normal;
	    			var isWall;
	    			
	//    			var hasItWall = IsPointedPositionValid(startPoint, endPoint, &contactPoint, &normal, &isWall, true);
	    			var isPointValid = mMainRoom.IsPointInRoom(laserObj.GetPosition()) && !mElevator.IsPointInElevator(laserObj.GetPosition());
	    			
	    			if(!isPointValid){
						adel(lasersArray, i);
	    			}
	    		}    		
    		}
    		
    		if(len(mCurrentTargets) == 0)
    		{
    			mCurrentStage++;
    			var targetsNumber;
    			
    			switch(mCurrentStage)
    			{
    				case STAGE_1:
					{
						targetsNumber = 4;
						break;
					}
					case STAGE_2:
					{
						targetsNumber = 8;
						break;
					}
    			}
    			
    			for(var i = 0; i < targetsNumber; i++)
				{
					aadd(mCurrentTargets, mTargets[i]);
					mCurrentTargets[i].ResetLife();
				}
    		}
    		
    		for(var i = 0; i < len(mCurrentTargets); i++)
    		{
    			var target = mCurrentTargets[i];    			
    			var hasBeenHit = false;
    			
    			for(var j = 0; j < len(mPistolsLaserArray) && !hasBeenHit; j++)
    			{
    				hasBeenHit = target.IsCollidingBBox(mPistolsLaserArray[j]);
    				
    				if(hasBeenHit)
    				{
    					adel(mPistolsLaserArray, j);    					
    					
    					if(target.Hit() && target.RemoveLife() <= 0)
    					{
    						target.Kill();
	    					mCounter = (mCounter + 1) % 100;
							UpdateCounter(mCounter, false);	
						}
    				}  
    			}
    			  			
	  			if(mCurrentStage != STAGE_0)
	  			{
	    			var enemyLaser = target.HandleEnemyLaser(cameraPosition);
	    			
	    			if(enemyLaser != Void){
	    				aadd(mEnemyLaserArray, enemyLaser);	
	    			}
				}
				
				target.Update(mMainRoom);
				
				if(target.IsDead())
					adel(mCurrentTargets, i);	
    		}
    		
    		
			
			for(var i = 0; i < len(mIsControllerShooting); i++){				
				if(mIsControllerShooting[i]){
					if(GetTime()-mControllerShotTime[i] <= mShootingDelay){
						if(!mIsVrOn && !mDebugVrOn){
							var gun = mGunsObj[i];
							var center = gun.LocalToWorld([0, 0, 0]);
							var tip = gun.LocalToWorld([-1, 0, 0]);
							gun.Translate((tip-center)*mAnimator.GetCurrentStateInTransition(mControllerAnimId[i],6));
						}
						else{
							var controller = mControllersArray[i];
							controller.Translate(-controller.GetDirection()*mAnimator.GetCurrentStateInTransition(mControllerAnimId[i],6));
						}
					}
					else{
						mIsControllerShooting[i] = false;
					}			
				}
			}
			break;
		}
		// Case where the level is ending: the only thing missing is the player inside the elevator
		case STATUS_LEVEL_ENDING:
		{
			// I check if the player goes inside the elevator. Note: I'm not checking that he enter from the doors; he can pass through walls right now
			if(mElevator.IsPointInElevator(cameraPosition) && !mEnding)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				// If the player is in, I start the timer to end the level
				mEnding = true;
				mEndTimer = GetTime();
			}
			
			// If the game is ending and it's been a while (so the doors of the elevator are closed now), I save the fact that the level has been completed
			if(mEnding && GetTime() - mEndTimer > mTimeToEnd)
				mIsLevelCompleted = true;
			
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}

/*
 * This method works the same as the one in Level1, except for the array of controllers used to check the points
 */
function Level6::HandleLasers()
{
	// Now I check if the player is drawing; I first check if he pressed a button
	if(mIsVrOn || mDebugVrOn){
//		var usingController1 = mInputManager.IsPressingPrimaryButton(1);
//		var usingController2 = mInputManager.IsPressingPrimaryButton(2);
		var usingController1 = KeyPressed("Z");
		var usingController2 = KeyPressed("X");
		
		var firstTimeUsingController1 = usingController1 && mControllersBeingUsedIndex[0] == 0;
		var firstTimeUsingController2 = mIsVRon && usingController2 && mControllersBeingUsedIndex[1] == 0;
			 
		if(firstTimeUsingController1 || firstTimeUsingController2)
		{				
			var index;
			
			if(firstTimeUsingController1)
			{
				index = 0;
				mControllersBeingUsedIndex[index] = 1;
			}
			else
			{
				index = 1;
				mControllersBeingUsedIndex[index] = 2;
			}
			
			var controller = mControllersArray[index];
			
			mIsControllerShooting[index] = true;
			mControllerShotTime[index] = GetTime();			
			mAnimator.CreateGenericTransition(mControllerAnimId[index], 0, {mShootingDepth,0}, mShootingDelay/1000, 2);
			
			var laserObj = CvmObj(mLaserMesh);
			laserObj.SetRotationMatrix(controller.GetRotationMatrix());
			mAnimator.CreateTransition(laserObj, controller.GetPosition(), controller.GetPosition()+controller.GetDirection()*mLaserMaxDistance, mLaserSpeed, false,0);
			
			aadd(mPistolsLaserArray, laserObj);
		}
		// Case where the user stopped pressing a trigger
		else
		{
			// If when the user stopped pressing the trigger of the first controller, I update the fact that the controller is not being used anymore
			if(!usingController1 && mControllersBeingUsedIndex[0] != 0)
				mControllersBeingUsedIndex[0] = 0;
			
			if(!usingController2 && mControllersBeingUsedIndex[1] != 0)
				mControllersBeingUsedIndex[1] = 0;
		}	
	}
	else{
		if(mInputManager.IsPressingPrimaryButton() && GetTime() - mLastShoot > mShootingDelay){
			mShootingGun = (mShootingGun+1)%2;
			mLastShoot = GetTime();			
			mIsControllerShooting[mShootingGun] = true;
			mControllerShotTime[mShootingGun] = GetTime();			
			mAnimator.CreateGenericTransition(mControllerAnimId[mShootingGun], 0, {mShootingDepth,0}, mShootingDelay/2000, 2);
			
			var startPoint = mGunsObj[mShootingGun].GetPosition();
			var laserObj = CvmObj(mLaserMesh);
			laserObj.SetRotationMatrix(mGunsObj[mShootingGun].GetRotationMatrix());
			laserObj.Rotate(mGunRotation[mShootingGun],0,1,0);
			var center = mGunsObj[mShootingGun].LocalToWorld([0, 0, 0]);
			var tip = mGunsObj[mShootingGun].LocalToWorld([1, 0, 0]);
			mAnimator.CreateTransition(laserObj, startPoint, startPoint+(tip-center)*mLaserMaxDistance, mLaserSpeed ,false,0);
			aadd(mPistolsLaserArray, laserObj);
		}	
	}
}

/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level6::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall, isLaser)
{
	var intersectedPlane = -1;

	intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	if(intersectedPlane == -1 || intersectedPlane == -2)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
		
	isWall = true;
	
	if(isLaser != Void && isLaser)
	{
//		outputln(intersectedPlane);
		print({"rayOrigin", "rayEnd", "intersectedPlane"}, {rayOrigin, rayEnd, intersectedPlane});
		return intersectedPlane != -1;
	}
	else
		return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level6::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level6::GetOpenglTransformOffset()
{
	return mOpenglTranslationOffset; 
}

function Level6::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

function Level6::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, mLight0Diffuse); 
	glLight(GL_LIGHT1, GL_DIFFUSE, mLight1Diffuse); 
	glLight(GL_LIGHT2, GL_DIFFUSE, mLight2Diffuse);
}

function Level6::GetLightDiffuse(){
	return {mLight0Diffuse, mLight1Diffuse, mLight2Diffuse};
}

function Level6::GetLevelPreview(){
	return mTexture;
}

function Level6::GetLevelName(){
	return "Ghost";
}

function Level6::UpdateCounter(num, toRandomPos){
	var digits = {};
	if(num > 9){
		aadd(digits, num/10);
		aadd(digits, num%10);
	}
	else{
		aadd(digits, 0);
		aadd(digits, num);
	}
	
	for(var j = 0; j < len(mCounterRandomMeshes); j++){
		var finalPos = mCounterRandomMeshes[j].GenerateFinalPositions(digits[j], mCounterPositions[j]);
		var objs = mCounterRandomMeshes[j].GetObjs();
		for(var i = 0; i < len(objs); i++){				
			objs[i].SetRotation(0,1,0,0);
			objs[i].SetRotation(0,0,1,0);
			objs[i].SetRotation(0,0,0,1);
			if(toRandomPos){
				var randomPos = mCounterRandomMeshes[j].GenerateRandomPositions(mCounterBox, mCounterPositions[len(mCounterRandomMeshes)-j-1]); 
				mAnimator.CreateTransition(objs[i], objs[i].GetPosition(), {randomPos,finalPos[i]}, 0.2, false, 1);
			}else
				mAnimator.CreateTransition(objs[i], objs[i].GetPosition(), finalPos[i], 0.2, false, 1);
		}
	}
}