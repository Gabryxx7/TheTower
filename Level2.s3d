//#include <Utils.s3d>

#define PIT_WIDTH 25.0 * SCALE_FACTOR
#define PIT_HEIGHT 1000.0 * SCALE_FACTOR

class Level2
{
	var mIsVRon;
	var mControllersArray;
	var debugVrOn;
	
	var mDebugController;
	var mDebugControllerHidden;
	var mDebugKeyHit;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	var mTimeToEnd;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	var mLight0Diffuse;
	var mLight1Diffuse;
	var mLight2Diffuse;

	
	// "Room" object that contains the whole room
	var mMainRoom;
	var mElevatorWall;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
	var mSpotShader;
	var mToonShader;
	var mAlphaShader;
	
	// Booleans that indicate whether the elevator has appeared and if it's already open or not
	var mIsElevatorPresent;
	var mIsElevatorOpen;
	
	// "Room" object that represent the elevator
	var mElevator;
	var mPitRoom;
	
	var pathAnim;
	var testo;
	
	var paths;
	var musicCircle;
	var musicCircleStepped;
	var musicCircleRadius;
	var musicCirclePosition;
	var randomShapes;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;	
	var mOpenglTranslationOffset;	
	var mPreviousOpenglTranslationOffset;
	
	var floorObj;	
	var numpadObj;
	var numpadPos;
	var codeNumbers;
	var typedNumbers;
	var numpadClearTime;
	var numpadClearNeeded;
	var doorUnlocked;
	
	var box;
	
	var mController1;
	var mController2;
	
	var animStarted;
	
	var timeFromLastSound;
	var timeFromLastClick;
	var musicPlaying;
		
	// Private functions
	ResetNumpad();
	GenerateFloorTiles(tilesSize, spaceSize, tilesThickness);
			
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	GetElevator();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	GetOpenglTransformOffset();
 	SetOpenglTransformOffset(mOpenglTranslationOffset);
 	SetupOpenglLights();
	GetLevelPreview();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function Level2::Level2(isVRon, inputManager, soundManager)
{
	mIsVRon = isVRon;	
	debugVrOn = false;
	
	mControllersArray = {};
		
	if(mIsVRon)
	{
		aadd(mControllersArray, mInputManager.GetController(1));
		aadd(mControllersArray, mInputManager.GetController(2));
	}
	else if(debugVrOn)
	{
		// If no VR is on, I create a debug controller, needed to check collisions. It will work just like a real controller, for the logic of the game I mean
		mDebugController = ViveController(1);
		mDebugControllerHidden = false;
		mDebugKeyHit = false;
		aadd(mControllersArray, mDebugController);
	}
	
	mEnding = false;
	mIsLevelCompleted = false;
	mTimeToEnd = 2500;
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 3.0;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	mIsElevatorPresent = false;
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH, ROOM_SIDE_WALL_WIDTH, ROOM_HEIGHT, true, 1, 2, true, false, false);
	mPitRoom = Room(ROOM_FAR_WALL_WIDTH , PIT_HEIGHT, ROOM_SIDE_WALL_WIDTH, true, 0, 0, false);	
	mPitRoom.Rotate(-90, 1, 0, 0);	
	
	var halfWidth = ROOM_FAR_WALL_WIDTH/2;
	var halfHeight = ROOM_SIDE_WALL_WIDTH/2;
	
	mPitRoom.GetObj().SetPosition(0, -PIT_HEIGHT, 0);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	mSpotShader = CVmShaderProgram("spotShader.glsl");	
	mToonShader = CVmShaderProgram("toonShader.glsl");	
	mAlphaShader = CVmShaderProgram("colorModulatorShader.glsl");	
	
//	testo = Text("Chaos cannot exist without order\nWhere order, cannot exist without chaos");
	testo = CVmObj();
	var txt = CVmText("Chaos cannot exist without order...",0,0,"Walkway bold", 0);
	var line = CVmObj();	
	line.LinkToText(txt);	
	line.SetRotation(90,0,1,0);
	testo.AddChild(line,-ROOM_FAR_WALL_WIDTH/2+0.1*SCALE_FACTOR, ROOM_HEIGHT/2-2*SCALE_FACTOR, 30*SCALE_FACTOR);
	txt = CVmText("Order cannot exist without chaos...",0,0,"Walkway bold", 0);
	line = CVmObj();
	line.LinkToText(txt);
	line.SetRotation(-90,0,1,0);
	
	testo.AddChild(line,ROOM_FAR_WALL_WIDTH/2-0.1*SCALE_FACTOR, ROOM_HEIGHT/2-2*SCALE_FACTOR, -30*SCALE_FACTOR);
	// Adding each text to its portal room
	testo.SetScale([1, 1, 1]);
	
	///// NUMBER PAD GENERATION /////
	var buttonsSize = [0.75 * SCALE_FACTOR, 0.1 * SCALE_FACTOR]; //width x thickness
	var buttonsSpacing = 0.04 * SCALE_FACTOR;
	var unpressedColor = [0.7,0.7,0.7];
	var pressedColor = [0,0.8,0.0];
	var wrongColor = [0.8,0.0,0.0];
	var buttonsTextColor = [0.0,0.0,0.0];
	var clearingColor = [0.8,0.8,0];
	numpadObj = VirtualKeyboard(mAnimator, "123\n456\n789\nC0 ", buttonsSize.x, buttonsSpacing, buttonsSize.y, unpressedColor, pressedColor, wrongColor, clearingColor, buttonsTextColor, null, null, null, null);	
//	numpadObj = VirtualKeyboard(mAnimator, "qwertyuiop\nasdfghjkl\nzxcvbnm ", buttonsSize.x, buttonsSpacing, buttonsSize.y, unpressedColor, pressedColor, wrongColor, clearingColor, buttonsTextColor, null, null, null,  numpadPos, numpadHolderSize);	
/////////////////////////////////////////////////////////
	
	
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}

 
 function Level2::Init(lights, elevator, openglTranslationOffset)
{	
	mOpenglTranslationOffset = openglTranslationOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Position = [-10.0 * SCALE_FACTOR, -50 * SCALE_FACTOR, 10.0 * SCALE_FACTOR];
	mLight1Position =[20.0 * SCALE_FACTOR, 6 * SCALE_FACTOR, -10.0 * SCALE_FACTOR];
	mLight2Position =[-10.0 * SCALE_FACTOR, 6 * SCALE_FACTOR, 20.0 * SCALE_FACTOR];
	mLight0Diffuse = [0.5,0.5,1];
	mLight1Diffuse = [1,0,0];
	mLight2Diffuse = [1,1,1];
	
	// Setting up the lights of the scene. They're both positional lights
	mLight0 = lights[0];
	mLight0.SetPosition(mLight0Position);
	mLight0.SetDiffuse(mLight0Diffuse.x, mLight0Diffuse.y, mLight0Diffuse.z);
	mLight0.Enable();	
	
	// This second light is used only to render the portal's rooms, so it gets moved around. The initial position isn't really relevant
	mLight1 = lights[1];
	mLight1.SetPosition(mLight1Position);
	mLight1.SetDiffuse(mLight1Diffuse.x, mLight1Diffuse.y, mLight1Diffuse.z);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition(mLight2Position);
	mLight2.SetDiffuse(mLight2Diffuse.x, mLight2Diffuse.y, mLight2Diffuse.z);
	mLight2.Enable();	
		
	mElevator = elevator;
	mElevator.SetLightsRange(0,2);
	
	var mElevatorWallMeshes = {};
	aadd(mElevatorWallMeshes, CVmNewMesh(VRP_PLANE, 1, [-ROOM_FAR_WALL_WIDTH/2, -(ROOM_HEIGHT/2 - mElevator.GetRoomHeight()/2), 0], [ROOM_FAR_WALL_WIDTH/2, +(ROOM_HEIGHT/2 - mElevator.GetRoomHeight()/2), 0], 2, 2));
	aadd(mElevatorWallMeshes, CVmNewMesh(VRP_PLANE, 1, [-(ROOM_FAR_WALL_WIDTH/2-mElevator.GetRoomWidth()/2)/2, -(mElevator.GetRoomHeight())/2, 0], [(ROOM_FAR_WALL_WIDTH/2-mElevator.GetRoomWidth()/2)/2, +(mElevator.GetRoomHeight())/2, 0], 2, 2));
	mElevatorWall = CVmObj();
	mElevatorWall.AddChild(CVmObj(mElevatorWallMeshes[0]), 0, (ROOM_HEIGHT/2 + mElevator.GetRoomHeight()/2),-ROOM_SIDE_WALL_WIDTH/2);
	mElevatorWall.AddChild(CVmObj(mElevatorWallMeshes[1]), (ROOM_FAR_WALL_WIDTH/2+mElevator.GetRoomWidth()/2)/2, mElevator.GetRoomHeight()/2, -ROOM_SIDE_WALL_WIDTH/2);
	mElevatorWall.AddChild(CVmObj(mElevatorWallMeshes[1]), -(ROOM_FAR_WALL_WIDTH/2+mElevator.GetRoomWidth()/2)/2, mElevator.GetRoomHeight()/2, -ROOM_SIDE_WALL_WIDTH/2);
	for(var i = 0; i < len(mElevatorWallMeshes); i++){		
		AddToonShaderToMesh(mElevatorWallMeshes[i], [0.5, 0.5, 0.5], [1, 1, 1], [0.0, 0.0, 0.0], 0, 0, 2, SCALE_FACTOR, 1.0);
	}
	
	mElevator.SetPosition([mElevator.GetPosition().x, mElevator.GetPosition().y, -ROOM_SIDE_WALL_WIDTH/2-mElevator.GetRoomHeight()+0.3*SCALE_FACTOR]);
	mCamera.SetPosition([mCamera.GetPosition().x, mCamera.GetPosition().y, -ROOM_SIDE_WALL_WIDTH/2-mElevator.GetRoomHeight()/2] - mOpenglTranslationOffset);
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	var lightPos = mLight1.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
//	mAnimator.CreateTransition(mLight1, lightPos + [0, -100, 0], lightPos, 20.0, false);
	
	mCameraYoffset = mElevatorTravelDistance / mElevatorTravelTime;

	mPreviousOpenglTranslationOffset = mOpenglTranslationOffset; 

	mOpenglTranslationOffset.y += mElevatorTravelDistance;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
//	///// CONTAINER BOX GENERATION /////
//	var boxBordersThickness =  0.5*SCALE_FACTOR;
//	var boxWidth = ROOM_SIDE_WALL_WIDTH/2 - boxBordersThickness - (0.1*SCALE_FACTOR);
//	var boxHeight = ROOM_HEIGHT/2 - boxBordersThickness - (0.1*SCALE_FACTOR);
//	var boxThickness = 10*SCALE_FACTOR;
//	var boxPosition = [0, 0, mMainRoom.GetPosition().z + ROOM_SIDE_WALL_WIDTH - boxThickness*2 - boxBordersThickness - (0.1*SCALE_FACTOR)];
//	box = GlassBox(boxWidth, boxHeight, boxThickness,  boxBordersThickness);
//	box.SetPosition(boxPosition);
	/////////////////////////////////////////////////////////
	
	///// PATHS + RANDOM MESHES GENERATION /////
	var tilesSize = [2.75 * SCALE_FACTOR, 0.25 * SCALE_FACTOR]; //width x height
	var tilesSpacing =  0.25 * SCALE_FACTOR;
	var tileMesh = CVmNewMesh(VRP_BOX, 1, [-tilesSize.x/2, -tilesSize.y/2, 0], [tilesSize.x/2, tilesSize.y/2, 0], tilesSize.x);
	var elevatorFrontPosition = [mElevatorFinalPosition.x, mElevatorFinalPosition.y - mElevator.GetRoomHeight()/2, mElevatorFinalPosition.z+mElevator.GetRoomWidth()+(tilesSize.x+tilesSpacing*3)];	
	var startingTilesPos = elevatorFrontPosition + [0, 0, 0];	
	
	var randomMeshesLimits = [ROOM_FAR_WALL_WIDTH/2 - 2*SCALE_FACTOR, ROOM_HEIGHT, ROOM_SIDE_WALL_WIDTH/2 - 1*SCALE_FACTOR];
	var randomMeshesPos = [0,-ROOM_HEIGHT-1*SCALE_FACTOR,-ROOM_SIDE_WALL_WIDTH/2+1*SCALE_FACTOR];
	var cubeSizes = 0.80 *SCALE_FACTOR;
	var randomMeshNumber = 100; //MUST BE AT LEAST 52 (13*4 boxes to form an 8 is the maximum amount of cubes needed)
	
	randomShapes = {};
	paths = {};
	
	var soundsRange = [0,6];
	
	//From leftmost to rightmost		
	startingTilesPos = elevatorFrontPosition + [(tilesSize.x+tilesSpacing), 0, 0];
	aadd(paths, TilesPath(tileMesh, [-1,4,-2,5,-1,5,-1,4,-2,4,-2,8,-2,6,-1,5,-1,7,-2,5,-2,6,-1,7,-2,2,-1,1], tilesSize.x, tilesSpacing, startingTilesPos, [0.0,0.65,0.0], [0,1,0], soundsRange));	 //GREEN
	
	startingTilesPos = elevatorFrontPosition + [(tilesSize.x+tilesSpacing), 0, 0];
	aadd(paths, TilesPath(tileMesh, [2,-1,1,-2,5,-1,4,-2,17,-2,2,-1,4], tilesSize.x, tilesSpacing, startingTilesPos, [0.0,0.65,0.65], [0,1,1], soundsRange));//LIGHT BLUE
	
	startingTilesPos = elevatorFrontPosition + [0, 0, 0];
	aadd(paths, TilesPath(tileMesh, [10,-1,4,-2,12,-2,4,-1,7,-2,-2,7,-1,4,-2,12,-2,3], tilesSize.x, tilesSpacing, startingTilesPos, [0.65,0.0,0.0], [1,0,0], soundsRange));//RED
	
	startingTilesPos = elevatorFrontPosition + [-(tilesSize.x+tilesSpacing), 0, 0];
	aadd(paths, TilesPath(tileMesh, [2,-2,1,-1,5,-2,4,-1,17,-1,2,-2,4], tilesSize.x, tilesSpacing, startingTilesPos, [0.65,0.65,0.65], [1,1,1], soundsRange));//WHITE;
	
	startingTilesPos = elevatorFrontPosition + [-(tilesSize.x+tilesSpacing), 0, 0];
	aadd(paths, TilesPath(tileMesh, [-2,4,-1,5,-2,5,-2,4,-1,4,-1,8,-1,6,-2,5,-2,7,-1,5,-1,6,-2,7,-1,2,-2,1], tilesSize.x, tilesSpacing, startingTilesPos, [0.0,0.0,0.65], [0,0,1], soundsRange)); //BLUE
	
	//Adding as many randomObjects as the number of tilesPaths
	for(var i = 0; i < len(paths); i++){
		var selectedMesh = Rand(3);
		var mesh;
		switch(selectedMesh){
			case 0: mesh = CVmNewMesh(VRP_BOX, 1, [-cubeSizes/2, -cubeSizes/2, 0], [cubeSizes/2, cubeSizes/2, 0], cubeSizes);
				break;
			case 1: mesh = CVmNewMesh(VRP_PYRAMID, 4, cubeSizes*1.25, cubeSizes*1.25);
				break;
			case 2: mesh = CVmNewMesh(VRP_SPHERE, 10, cubeSizes * 0.80, 1);
				break;
			case 3: mesh = CVmNewMesh(VRP_CYLINDER, 10, cubeSizes * 0.70, cubeSizes,1);
				break;
		}
		
		
		aadd(randomShapes, RandomMeshes(mesh, randomMeshNumber, randomMeshesLimits, randomMeshesPos, paths[i].GetSteppedColor()));
	}
	
	/////// NUMPAD SCREEN SETTING AND POSITIONING /////
	var numpadButtonsSize = numpadObj.GetButtonsSize();
	var numpadButtonsThickness = numpadObj.GetButtonsThickness();
	numpadPos = [(mElevatorFinalPosition.x + mElevator.GetRoomWidth()/2) + (numpadButtonsSize*1.5), mElevatorFinalPosition.y + 4*numpadButtonsSize, mElevatorFinalPosition.z + mElevator.GetRoomWidth()+(numpadButtonsThickness*1.4)];
 	var numpadHolderSize = [numpadButtonsSize*len(paths), mElevator.GetRoomHeight()+0.15*SCALE_FACTOR, numpadButtonsThickness*1.5];
	numpadObj.CreateHolder(numpadHolderSize);
	numpadObj.SetMaxCharOnScreen(len(paths));
	numpadObj.SetPosition(numpadPos);
	/////////////////////////////////////////////////////////7
	
	codeNumbers = {};
	var finalPositions;
	var cubeNums = CubeNumbers();
	var numPosOffset = len(randomShapes)/2;
	var numberPosition;
	for(var i = 0; i < len(randomShapes); i++){
		numberPosition = [(13*cubeSizes)*(numPosOffset--), ROOM_HEIGHT/2-3.5*SCALE_FACTOR, ROOM_FAR_WALL_WIDTH/2 - 3*SCALE_FACTOR];
		for(var j = 0; j < randomMeshNumber; j++){
			aadd(randomShapes[i].GetFinalAngles(),[0, 0, 0]);
			aadd(randomShapes[i].GetAnimationsVector(),[0, 0, 0]);	
		}
		
		var randNumb;
		var alreadyPresent = true;
		while(alreadyPresent){
			randNumb = Rand(9);
			alreadyPresent = false;
			for(var k = 0; k < len(codeNumbers); k++){
				if(randNumb == codeNumbers[k]){
					alreadyPresent = true;
					break;					
				}	
			}	
			
			if(!alreadyPresent){				
				aadd(codeNumbers, randNumb);	
			}		
		}
		finalPositions = cubeNums.GenerateNumberPositions(codeNumbers[i], numberPosition);
		
		var j = 0;
		while(len(randomShapes[i].GetFinalPos()) < len(randomShapes[i].GetObjs())){	
			aadd(randomShapes[i].GetFinalPos(),[finalPositions[j].x, finalPositions[j].y, finalPositions[j].z]);	
					
			if(j+1 == len(finalPositions))
				j = 0;
			else
				j += 1;
		}		
	}	
	
	output("\n\n\nCodice:  ");
	outputln(codeNumbers);
	
	typedNumbers = {};
	doorUnlocked = false;
	numpadClearNeeded = 0;
	/////////////////////////////////////////////////////////
	
	musicCircleRadius = 5*SCALE_FACTOR;
	musicCircle = CVmObj((CVmNewMesh(VRP_CYLINDER, 20, musicCircleRadius, tilesSize.y,1)));
	musicCirclePosition = [0, -tilesSize.y*2, 0];
	musicCircle.SetPosition(musicCirclePosition);
	musicCircleStepped = false;
	
	timeFromLastSound = 0;
	timeFromLastClick = 0;
	musicPlaying = false;
	pathAnim = false;
	animStarted = false;
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */

/*
 * Render method
 */
function Level2::Render()
{				
	// Move the lights back to their original position, because if the user previously teleported their position will be wrong
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
 	// I put the controller in front of the camera, for the debugging purposes, if VR isn't on
	if(!mIsVRon)
	{
		if(debugVrOn)
			mDebugController.SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR);
		
		// I also check if Y is pressed: this hides/unhides the debug controller
		if(KeyPressed("Y"))
		{
			if(!mDebugKeyHit)
			{
				if(mDebugControllerHidden)
					mDebugController.Unhide();
				else
					mDebugController.Hide();
					
				mDebugControllerHidden = !mDebugControllerHidden;
				mDebugKeyHit = true;
			}
		}
		else
			mDebugKeyHit = false;
	}
	

	foreach(var controller in mControllersArray)
		controller.Draw();
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_ENDING:
		case STATUS_LEVEL_STARTED:
		{
			// The first thing we need to do is draw the portals. Since they are peculiar, it is best to draw them first, otherwise there might be glitches
//			DrawAllPortals();
			mPitRoom.Draw();
			
			mMainRoom.Draw();
			mElevatorWall.Draw();
			
			var tilesObjs;
			var steppedTilesObjs;
			
			mSpotShader.Start();							
				mSpotShader.SetParameter("offset", 0.02 * SCALE_FACTOR);
				mSpotShader.SetParameter("SCALE_FACTOR", SCALE_FACTOR);
				mSpotShader.SetParameter("color", [0.0, 0.0, 0.0]);	
						
				for(var j = 0; j < len(paths); j++){
					tilesObjs = paths[j].GetTilesObjs();
					steppedTilesObjs = paths[j].GetSteppedTilesObjs();
					
					mSpotShader.SetParameter("outlineColor", paths[j].GetColor());														
						for(var i = 0; i < len(tilesObjs); i++){
							if(!pathAnim){
								mSpotShader.SetParameter("stepped", false);
								mSpotShader.SetParameter("outline", false);
								tilesObjs[i].Draw();
								
								mSpotShader.SetParameter("outline", true);
								tilesObjs[i].Draw();
							}
						}
						mSpotShader.SetParameter("outlineColor", paths[j].GetSteppedColor());
						for(var i = 0; i < len(steppedTilesObjs); i++){
							mSpotShader.SetParameter("stepped", true);	
							mSpotShader.SetParameter("outline", false);						
							steppedTilesObjs[i].Draw();
							
							mSpotShader.SetParameter("outline", true);						
							steppedTilesObjs[i].Draw();
						}	
						
						if(musicCircleStepped)
							mSpotShader.SetParameter("outlineColor", [1,1,0]);
						else
							mSpotShader.SetParameter("outlineColor", [0.7,0.7,0]);
						mSpotShader.SetParameter("stepped", true);	
						mSpotShader.SetParameter("outline", false);
						musicCircle.Draw();	
						mSpotShader.SetParameter("outline", true);
						musicCircle.Draw();					
				}
				
				var cubesObjs;
				for(var j = 0; j < len(randomShapes); j++){
					cubesObjs = randomShapes[j].GetObjs();
						
					mSpotShader.SetParameter("outlineColor", randomShapes[j].GetColor());
					mSpotShader.SetParameter("offset", 0.01 * SCALE_FACTOR);		
					for(var i = 0; i < len(cubesObjs); i++){
						mSpotShader.SetParameter("stepped", true);	
						mSpotShader.SetParameter("outline", false);
						cubesObjs[i].Draw();
						
						mSpotShader.SetParameter("outline", true);
						cubesObjs[i].Draw();
					}			
				}
			mSpotShader.Stop();	
		}
	}

	// The elevator is always present, so it's always drawn
	mElevator.Draw();
	testo.Draw();
	numpadObj.DrawHolder();
	numpadObj.DrawScreenText();	
	numpadObj.DrawScreen();			
	numpadObj.DrawPressedButtons();
	numpadObj.DrawUnpressedButtons();
			
//	mAlphaShader.Start();
//		mAlphaShader.SetParameter("time", 0);
//		mAlphaShader.SetParameter("alpha", 0.3);
//		mAlphaShader.SetParameter("startingColor", [0.6, 0.6, 1]);
//		mAlphaShader.SetParameter("finalColor", [0.6, 0.6, 1]);
//		box.Draw([1,0,0,0,0,0], 0);
//	mAlphaShader.Stop();
	
	if(mIsVRon){
		mController1.Draw();
		mController2.Draw();
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level2::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		case STATUS_ELEVATOR_MOVING: 
		{			
		    // I make sure that the camera doesn't go out of the elevator while it's going up
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();
	
			// I check if the elevator is halfway through the transtition; if this is the case, I change its lights range for the rendering (but only
			// if I didn't do so already)
			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2 && mElevator.GetLightsRange().y < 1)
				 mElevator.SetLightsRange(1,2);
			
			mOpenglTranslationOffset.y -= mCameraYoffset * dt;
			
		    mOpenglTranslationOffset.x += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
		    mOpenglTranslationOffset.y += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
			
			// I check if the elevator reached its destination, and if this is so I open the door and change status
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
				
				mOpenglTranslationOffset = mPreviousOpenglTranslationOffset;
			}
	
			break;
		}		
		// This is the case where the elevator arrived, BUT the player is still inside
		case STATUS_ELEVATOR_ARRIVED:
		{
			// I check if the player goes out from the elevator. Note: I'm not checking that he exits from the doors; he can pass through walls right now.
			// If the player comes out, I close the doors and change status
			//Since the elevator is outside of the room, I must be sure that the level start when he is actually insie the main room
			//otherwise he would be stuck in the space between the elevator exit and the main room. which is considered outside of the room
			var elevatorEntrancePos = mElevator.GetPosition().z + mElevator.GetRoomWidth();
			if(!mElevator.IsPointInElevator(cameraPosition) && !(cameraPosition.z > elevatorEntrancePos - 2*SCALE_FACTOR && cameraPosition.z < elevatorEntrancePos + 2*SCALE_FACTOR))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			if(!animStarted){
				var time;
				animStarted = true;
				var cubePos;
				
				for(var j = 0; j < len(randomShapes); j++){		
					for(var i = 0; i < len(randomShapes[j].GetObjs()); i++){
						time = (Rand(13)+ 11) / 5;
						mAnimator.CreateRotatingTransition(randomShapes[j].GetObjs()[i], Rand(360), Rand(360), [Rand(1),Rand(1),Rand(1)], time-0.5, true, false);
						time = (Rand(13)+ 11) / 5;	
						cubePos	= randomShapes[j].GetObjs()[i].GetPosition();	
						mAnimator.CreateRotationAroundPointTransition(randomShapes[j].GetObjs()[i], cubePos, cubePos - [(Rand(1)+1) / (Rand(1)+2) * SCALE_FACTOR, (Rand(1)+1) / (Rand(1)+2) * SCALE_FACTOR, (Rand(1)+1) / (Rand(1)+2) * SCALE_FACTOR], time,  true, true, Rand(1) == 1);
					}	
				}
			}
			
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{
			// I make sure that the player stay's inside the room and outside of the elevator
			if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition) && !mMainRoom.IsPointInRoom(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var stepDistance = pathAnim ? 8*SCALE_FACTOR : 3*SCALE_FACTOR;				
			var tilePos;
			var tilesObjs;
			var steppedTilesObjs;
			var originaLength;
			for(var j = 0; j < len(paths); j++){
				tilesObjs = paths[j].GetTilesObjs();
				steppedTilesObjs = paths[j].GetSteppedTilesObjs();

				originaLength = len(tilesObjs);
				
				for(var i = 0; i < len(tilesObjs); i++){			
					tilePos = tilesObjs[i].GetPosition();
					if(cameraPosition.x < tilePos.x + stepDistance && cameraPosition.x > tilePos.x - stepDistance && cameraPosition.z < tilePos.z + stepDistance && cameraPosition.z  > tilePos.z - stepDistance){
						if(pathAnim)
							mAnimator.CreateTransition(tilesObjs[i], tilesObjs[i].GetPosition() + [0, -10*SCALE_FACTOR, 0], tilesObjs[i].GetPosition(), 0.25, false);
							
						aadd(steppedTilesObjs, tilesObjs[i]);
						if(timeFromLastSound > 0.25 && MUSICFX_ON){
							mSoundManager.PlaySound(paths[j].GetNextSoundIndex(), true, 1);
							timeFromLastSound = 0;
						}

						adel(tilesObjs, i);
						i = 0;
					}
				}
						
				if(originaLength != len(tilesObjs) && len(tilesObjs) < 1){
					randomShapes[j].StartAnimation();
					if(j == 0){		
							outputln("\nGREEN ANIMATION STARTED");				
						}
						else if(j == 1){
							outputln("\nLIGHT BLUE  ANIMATION STARTED");					
						}
						else if(j == 2){
							outputln("\nRED ANIMATION STARTED");				
						}
						else if(j == 3){
							outputln("\nWHITE ANIMATION STARTED");				
						}
						else if(j == 4){
							outputln("\nBLUE ANIMATION STARTED");				
						}
				}
				
				//Workaround for the mAnimator diagonal transition bug
				//I'll start first the animation on the x axis, then the one on the Y axis and in the end the one on the z axis
				//so that the movement are computed correctly for every direction
				if(paths[j].HasBeenWalked() && j < len(randomShapes) && randomShapes[j].IsAnimating()){	
					var time;
					var cubesObjs = randomShapes[j].GetObjs();
					var objsAnimations = randomShapes[j].GetAnimationsVector();
					var startAngle = randomShapes[j].GetOriginalAngles();
					var finalAngle = randomShapes[j].GetFinalAngles();
					var finalPos = randomShapes[j].GetFinalPos();
					var objPos;
					var checkOffs = 0.5*SCALE_FACTOR; //The position is never perfect
					var completedAnimations = 0;
					
					for(var i = 0; i < len(cubesObjs); i++){
						objPos = cubesObjs[i].GetPosition();
						time = (Rand(10)+ 11) / 5;
												
						if(objsAnimations[i].x == 0){	
//							mAnimator.RemoveTransitionByObject(randomShapes[j].GetObjs()[i], 3);	//The animation is starting so I remove the rotation around a point animation
							objsAnimations[i].x = 1;
							mAnimator.CreateTransition(cubesObjs[i], [objPos.x, objPos.y, objPos.z], [finalPos[i].x, objPos.y, objPos.z], time, false);
							cubesObjs[i].SetRotation(startAngle[i].x, 1,0,0);
							time = (Rand(10)+ 11) / 5;
							mAnimator.CreateRotatingTransition(cubesObjs[i], startAngle[i].x, finalAngle[i].x, [1,0,0], time-0.5, false, false);
						}
						else if(objPos.x < finalPos[i].x + checkOffs && objPos.x > finalPos[i].x - checkOffs && objsAnimations[i].y == 0){
							objsAnimations[i].y = 1;
							mAnimator.CreateTransition(cubesObjs[i], [finalPos[i].x, objPos.y, objPos.z], [finalPos[i].x, finalPos[i].y, objPos.z], time, false);
							cubesObjs[i].SetRotation(startAngle[i].y, 0,1,0);
							time = (Rand(10)+ 11) / 5;
							mAnimator.CreateRotatingTransition(cubesObjs[i], startAngle[i].y, finalAngle[i].y, [0,1,0], time-0.5, false, false);
						}						
						else if(objPos.y < finalPos[i].y + checkOffs && objPos.y > finalPos[i].y - checkOffs && objsAnimations[i].z == 0){
							objsAnimations[i].z = 1;
							mAnimator.CreateTransition(cubesObjs[i], [finalPos[i].x, finalPos[i].y, objPos.z], [finalPos[i].x, finalPos[i].y, finalPos[i].z], time, false);
							cubesObjs[i].SetRotation(startAngle[i].z, 0,0,1);
							time = (Rand(10)+ 11) / 5;
							mAnimator.CreateRotatingTransition(cubesObjs[i], startAngle[i].z, finalAngle[i].z, [0,0,1], time-0.5, false, false);
						}						
						else if(objPos.z < finalPos[i].z + checkOffs && objPos.z > finalPos[i].z - checkOffs && objsAnimations[i].z == 1){
							completedAnimations++;
						}
					}
					
					
					if(completedAnimations >= len(cubesObjs)){
						randomShapes[j].StopAnimation();						
						if(j == 0){		
							outputln("\nGREEN ANIMATION COMPLETED");				
						}
						else if(j == 1){
							outputln("\nLIGHT BLUE  ANIMATION COMPLETED");					
						}
						else if(j == 2){
							outputln("\nRED ANIMATION COMPLETED");				
						}
						else if(j == 3){
							outputln("\nWHITE ANIMATION COMPLETED");				
						}
						else if(j == 4){
							outputln("\nBLUE ANIMATION COMPLETED");				
						}
					}
				}
			}				
			
			if(numpadClearNeeded > 0){
				numpadClearTime += dt;
				if(numpadClearTime > 0.5){
					numpadClearTime = 0;
					ResetNumpad();
					numpadClearNeeded = 0;					
				}
			}				
			
			var pressedButton = "";
			//If the player is close to the numpad
			if(!doorUnlocked && numpadObj.IsCameraInKeyboardRange(cameraPosition, 8 * SCALE_FACTOR) && numpadClearNeeded == 0){			   	
			   	
				if(mIsVRon){
					mControllersArray[0].SetActionAvailable(true);	
					mControllersArray[1].SetActionAvailable(true);	
					if(numpadClearNeeded == 0 && !doorUnlocked){
						var vrPressedButton1 = pressedButton = numpadObj.TouchedButton(mControllersArray[0].GetPosition());
						var vrPressedButton2 = pressedButton = numpadObj.TouchedButton(mControllersArray[1].GetPosition());						
					 	var vrPointedButton1 = numpadObj.PointedButton(mControllersArray[0], mControllersArray[0].GetPosition(), false);											
					 	var vrPointedButton2 = numpadObj.PointedButton(mControllersArray[1], mControllersArray[1].GetPosition(), false);	
						var vrPressedButton = (vrPressedButton1 == "") ? vrPressedButton2 : vrPressedButton1;
						if(mInputManager.IsPressingPrimaryButton() && timeFromLastClick > 0.25){
							timeFromLastClick = 0;	
							pressedButton = (vrPointedButton1 == "") ? vrPointedButton2 : vrPointedButton1;
							if(pressedButton != "" && pressedButton != " "){
								numpadObj.PressButton(pressedButton, pressedButton == "c"? false : true);		
								numpadObj.AnimateButton(pressedButton);	
								mInputManager.VibrateController((vrPointedButton1 == "") ? 1 : 0, 100);						
							}
						}
						else if(timeFromLastClick > 0.4){
							timeFromLastClick = 0;
							pressedButton = (vrPressedButton1 == "") ? vrPressedButton2 : vrPressedButton1;	
							numpadObj.PressButton(pressedButton, pressedButton == "c" ? false : true);	
							mInputManager.VibrateController((vrPointedButton1 == "") ? 1 : 0, 100);								
						}
					}			
				}
				else if(debugVrOn){
					mDebugController.SetActionAvailable(true);
					if(numpadClearNeeded == 0 && !doorUnlocked){
						var vrPressedButton = numpadObj.TouchedButton(mDebugController.GetPosition(), dt);	
						var pointed = numpadObj.PointedButton(mDebugController, mDebugController.GetPosition(), false);	
						if(mInputManager.IsPressingPrimaryButton() && timeFromLastClick > 0.25){
							timeFromLastClick = 0;
							pressedButton = pointed;
							if(pressedButton != "" && pressedButton != " "){
								numpadObj.PressButton(pressedButton, pressedButton == "c" ? false : true);		
								numpadObj.AnimateButton(pressedButton);								
							}						
						}
						else if(timeFromLastClick > 0.4){	
							timeFromLastClick = 0;	
							pressedButton = vrPressedButton;	
							numpadObj.PressButton(pressedButton, pressedButton == "c" ? false : true);						
						}	
					}
				}
				else {
					 var pointedButton = numpadObj.PointedButton(mCamera, cameraPosition, true);
					 var pressedKey = Keyboard();
					
					if(pressedKey != "" && pressedKey != " "){
						if(asc(pressedKey) > 47 && asc(pressedKey) <= 48+9 || pressedKey == "c"){	
							pressedButton = pressedKey;				
						}
					}
					else if(mInputManager.IsPressingPrimaryButton() && timeFromLastClick > 0.25){
						timeFromLastClick = 0;
						pressedButton = pointedButton;	
					}
					
					if(pressedButton != "" && pressedButton != " "){		
						numpadObj.PressButton(pressedButton, pressedButton == "c" ? false : true);
						numpadObj.AnimateButton(pressedButton);				
					}
				}
			}
			else{
				if(mIsVRon){
					mControllersArray[0].SetActionAvailable(false);	
					mControllersArray[1].SetActionAvailable(false);						
				}			
				else if(debugVrOn){
					mDebugController.SetActionAvailable(false);	
				}
				Keyboard(); //Needed to process the input even when not close to the numpad. Otherwise it will go in a queue and will be processed as soon as I get closer to the numpad
			}	
			
			
			if(pressedButton != "" && pressedButton != " "){
				if(asc(pressedButton) > 47 && asc(pressedButton) <= 48+9){
					aadd(typedNumbers, val(pressedButton));
				}
				else if(pressedButton == "c"){
					numpadObj.FadePressedButtonsColor(numpadObj.GetSecondaryColor(), numpadObj.GetUnpressedButtonColor());
					numpadClearNeeded = 2;
					numpadClearTime = 0;
				}			
			}
			
			//If all the numbers have been typed 		
			if(len(typedNumbers) == len(codeNumbers)){
				var correctNumbers = 0;
				for(var i = 0; i < len(typedNumbers); i++){
					if(typedNumbers[i] == codeNumbers[i])
						correctNumbers++;
				}
				
				if(correctNumbers == len(typedNumbers)){
					doorUnlocked = true;
					outputln("Well done mate! (mofo)");
					
					var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
					var rightDoorPos = mElevator.GetRightDoor().GetPosition();
					
					mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
					mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
					
					// I switch status
					mLevelStatus = STATUS_LEVEL_ENDING;
					numpadObj.PressAllButtons();
					numpadObj.AnimatePressedButtons();
					numpadObj.FadePressedButtonsColor(numpadObj.GetPressedButtonColor(), numpadObj.GetPressedButtonColor() + [0.15, 0.3, 0.15]);
				}else if(numpadClearNeeded == 0){ //If the code was wrong and the numpad is NOT already being cleared, I'll set it as needed to clear
					outputln("Wrong Code!! ");
					numpadObj.FadePressedButtonsColor(numpadObj.GetWrongCodeColor(), numpadObj.GetUnpressedButtonColor());
					doorUnlocked = false;
					numpadClearNeeded = 1;
					numpadClearTime = 0;
				}
			}		
			
			if(numpadClearNeeded > 0 && numpadClearTime == 0){				
				numpadObj.AnimatePressedButtons();
			}
						
			var time = (Rand(10)+ 11) / 5;
			var objPos;
			var musicRadius = musicCircleRadius*1.7; 
			var distanceFromCircle = sqrt((cameraPosition.x-musicCirclePosition.x)*(cameraPosition.x-musicCirclePosition.x) + (cameraPosition.z-musicCirclePosition.z)*(cameraPosition.z-musicCirclePosition.z));
			//Distance from circle, if it is close to circles I switch music starting with volume = 0
			if(distanceFromCircle  < musicRadius*musicRadius){
				if(!musicPlaying){
					musicPlaying = true;
					mSoundManager.SetMusic("sounds/Deadmau5 Ft Rob Swire - Ghosts n Stuff.mp3", 0, false);
					mSoundManager.PlayMusic();
				}
				var volume = musicRadius*musicRadius - distanceFromCircle;
				mSoundManager.SetMusicVolume(volume);
			}else if(distanceFromCircle  < musicRadius*musicRadius*1.5){ //If it's further I'll switch to the calm music with high volume that gets lower when getting closer to the outer circle
				if(musicPlaying){				
					musicPlaying = false;
					mSoundManager.SetMusic("sounds/Nexus - Tranquility.mp3", 1, true, 1.0);
					mSoundManager.PlayMusic();	
				}			
				var volume = 1-(musicRadius*musicRadius*1.5 - distanceFromCircle);
				mSoundManager.SetMusicVolume(volume);
			} 
			
			if(distanceFromCircle  < musicCircleRadius*musicCircleRadius && !musicCircleStepped){
				musicCircleStepped = true;
				mAnimator.CreateTransition(musicCircle, musicCirclePosition, musicCirclePosition - [0,0.5*SCALE_FACTOR,0], 0.7, false);
				for(var j = 0; j < len(randomShapes); j++){
					if(!paths[j].HasBeenWalked()){
						for(var i = 0; i < len(randomShapes[j].GetObjs()); i++){
							objPos = randomShapes[j].GetObjs()[i].GetPosition();
							time = (Rand(13)+ 11) / 5;
							mAnimator.CreateRotatingTransition(randomShapes[j].GetObjs()[i], Rand(360), Rand(360), [Rand(1),Rand(1),Rand(1)], time-0.5, true, false);
							time = (Rand(100)+ 50) / 7;
							var randomSpeed = (Rand(9)+1);
							var rotationRadius = 10*SCALE_FACTOR;
							var startingPosx = objPos.x;
							var startingPosz = objPos.z;
							if(Modulus(objPos - [musicCirclePosition.x, objPos.y, musicCirclePosition.z]) > ROOM_SIDE_WALL_WIDTH/2-5*SCALE_FACTOR){
								startingPosx = objPos.x > 0 ? objPos.x - rotationRadius : objPos.x + rotationRadius;
								startingPosz = objPos.z > 0 ? objPos.z - rotationRadius : objPos.z + rotationRadius;								
							}
							mAnimator.CreateRotationAroundPointTransition(randomShapes[j].GetObjs()[i], [startingPosx, objPos.y, startingPosz], [musicCirclePosition.x, objPos.y, musicCirclePosition.z], time*randomSpeed, true, true, Rand(1) == 1);
						}					
					}
				}
			}
			
			if(distanceFromCircle > musicCircleRadius*musicCircleRadius && musicCircleStepped){
				musicCircleStepped = false;
				mAnimator.CreateTransition(musicCircle, musicCirclePosition - [0,0.5*SCALE_FACTOR,0], musicCirclePosition, 0.7, false);
				for(var j = 0; j < len(randomShapes); j++){
					if(!paths[j].HasBeenWalked()){
						for(var i = 0; i < len(randomShapes[j].GetObjs()); i++){
							objPos = randomShapes[j].GetObjs()[i].GetPosition();
							time = (Rand(13)+ 11) / 5;
							mAnimator.CreateRotatingTransition(randomShapes[j].GetObjs()[i], Rand(360), Rand(360), [Rand(1),Rand(1),Rand(1)], time-0.5, true, false);
							time = (Rand(9)+ 11) / 5;			
							mAnimator.CreateRotationAroundPointTransition(randomShapes[j].GetObjs()[i], objPos, objPos - [(Rand(2)+1) / (Rand(1)+2) * SCALE_FACTOR, (Rand(2)+1) / (Rand(1)+2) * SCALE_FACTOR, (Rand(2)+1) / (Rand(1)+2) * SCALE_FACTOR], time,  true, true, Rand(1) == 1);
						}						
					}
				}
			}
			break;
		}
		
		// Case where the level is ending: the only thing missing is the player inside the elevator
		case STATUS_LEVEL_ENDING:
		{
			// I check if the player goes inside the elevator. Note: I'm not checking that he enter from the doors; he can pass through walls right now
			if(mElevator.IsPointInElevator(cameraPosition) && !mEnding)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				// If the player is in, I start the timer to end the level
				mEnding = true;
				mEndTimer = GetTime();
			}
			
			// If the game is ending and it's been a while (so the doors of the elevator are closed now), I save the fact that the level has been completed
			if(mEnding && GetTime() - mEndTimer > mTimeToEnd)
				mIsLevelCompleted = true;
			
			break;
		}
	}
	
	timeFromLastClick = (timeFromLastClick > 1) ? timeFromLastClick : timeFromLastClick += dt;
	timeFromLastSound = (timeFromLastSound > 1) ? timeFromLastSound : timeFromLastSound += dt;
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}

function Level2::ResetNumpad(){		
	numpadObj.UnpressAllButtons();	
			
	while(len(typedNumbers) > 0){
		adel(typedNumbers,0);
	}							
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level2::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level2::GetOpenglTransformOffset()
{
	return mOpenglTranslationOffset; 
}

function Level2::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

/*
 * Method called by the GameManager to check if the level is completed
 */
function Level2::GetElevator()
{
	return mElevator;
}

/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level2::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	// Checking intersections with the main room
	intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	// If no valid intersection was found, I check the floor, but since it's not present in the room I check collisions with the plane that has as normal
	// the one that points up from the ground
	if(intersectedPlane == -1)
	{
		normal = [0, 1, 0];
		contactPoint = FindIntersectionInPlane(rayOrigin, rayEnd, [0, 0, 0], normal);
		
		// If a in intersection was found, I procede
		if(contactPoint != Void)
		{
			// I need to check if the position found is in the room; since the plane is infinite, the intersection could be anywhere. To make sure that
			// we check the point correctly, I move the point up a little bit for the check
			contactPoint.y += 1 * SCALE_FACTOR;
			
			// If the point is in the room, it's a valid point
			if(mMainRoom.IsPointInRoom(contactPoint))
			{
				intersectedPlane = 0;
				contactPoint.y -= 1 * SCALE_FACTOR;
			}
		}
	}
		
	// Checking collision with the back wall; like the floor, it's not present in the room object, so I check intersection with the plane that is in that position
	if(intersectedPlane == -1)
	{
		var pos = mElevatorWall.GetPosition();
		pos.z = -mMainRoom.GetRoomDepth() / 2.0;
		
		normal = [0, 0, 1];
		contactPoint = FindIntersectionInPlane(rayOrigin, rayEnd, pos, normal);
		
		// If the intersection was found, the point is not valid
		if(contactPoint != Void)
			intersectedPlane = 1;
	}
		
	isWall = true;
	
	return intersectedPlane == 0;
}

function Level2::GenerateFloorTiles(tilesSize, spaceSize, tilesThickness)
{
	var returnObj = CVmObj();
	var tileMesh = CVmNewMesh(VRP_BOX, 1, [-tilesSize/2, -tilesSize/2, 0], [tilesSize/2, tilesSize/2, 0], tilesThickness);
	var lastLength = 0;
	var totalLength = tilesSize + spaceSize;
	var totalHeight = tilesSize + spaceSize;
	
	returnObj.AddChild(CVmObj(tileMesh), totalLength, totalHeight, 0);	
	
	while(true){
		totalLength += (tilesSize + spaceSize);
		
		if(totalLength >= ROOM_FAR_WALL_WIDTH){
			totalHeight += tilesSize + spaceSize;	
			lastLength = totalLength;
			totalLength = tilesSize + spaceSize;
		}	
		
		if(totalHeight >= ROOM_FAR_WALL_WIDTH){
			break;			
		}
		else{		
			returnObj.AddChild(CVmObj(tileMesh), totalLength, totalHeight, 0);	
		}
	}
	
	returnObj.rotate(90, 1, 0, 0);
	returnObj.SetPosition(-lastLength/2,0.3 * SCALE_FACTOR,-totalHeight/2);
	
	return returnObj;
}

function Level2::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, mLight0Diffuse); 
	glLight(GL_LIGHT1, GL_DIFFUSE, mLight1Diffuse); 
	glLight(GL_LIGHT2, GL_DIFFUSE, mLight2Diffuse);
}

function Level2::GetLevelPreview(){
	return "Level2Prev.png";
}