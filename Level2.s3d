//#include <Utils.s3d>
#include <MarcelloUtils.s3d>

#define PIT_WIDTH 25.0 * SCALE_FACTOR
#define PIT_HEIGHT 1000.0 * SCALE_FACTOR

class Level2
{
	var mIsVRon;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	var mLight0Diffuse;
	var mLight1Diffuse;
	var mLight2Diffuse;
	
	// These variables are temporary (or not?) floats used to move the light in a semi-random way, to create a nice dynamic effect
	var mIncrement;
	var mOffset;
	
	// "Room" object that contains the whole room
	var mMainRoom;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
	var mSpotShader;
	var mToonShader;
	var mAlphaShader;
	
	// Booleans that indicate whether the elevator has appeared and if it's already open or not
	var mIsElevatorPresent;
	var mIsElevatorOpen;
	
	// "Room" object that represent the elevator
	var mElevator;
	var mPortalRoom;
	var mPortalFrame;
	var mPortalFrameNormal;
	
	var pathAnim;
	var numberOfPaths;
	
	var redPathObjs;
	var redPathSteppedObjs;
	var timesWalked;
	var redPathWalked;
	var greenPathObjs;
	var greenPathSteppedObjs;
	var greenPathWalked;
	var bluePathObjs;
	var bluePathSteppedObjs;
	var bluePathWalked;
	var pinkPathObjs;
	var pinkPathSteppedObjs;
	var pinkPathWalked;
	
	var mCurrentlyVisiblePortalFrames;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;	
	var mOpenglTranslationOffset;	
	
	var floorObj;	
	var provaMeshObj;
	var numpadButtonsObj;
	var numpadTextsObj;
	var numpadHolderObj;
	
	var boxObj;
	
	var mController1;
	var mController2;
	
	var animStarted;
	var redNumberObjs;
	var redNumberObjsAnims;
	var redNumberObjsOriginalAngles;
	var redNumberObjsFinalAngles;
	var redNumberObjsOriginalPos;
	var redNumberObjsFinalPos;
	var blueNumberObjs;
	var blueNumberObjsAnims;
	var blueNumberObjsOriginalAngles;
	var blueNumberObjsFinalAngles;
	var blueNumberObjsOriginalPos;
	var blueNumberObjsFinalPos;
	var greenNumberObjs;
	var greenNumberObjsAnims;
	var greenNumberObjsOriginalAngles;
	var greenNumberObjsFinalAngles;
	var greenNumberObjsOriginalPos;
	var greenNumberObjsFinalPos;
		
	// Private functions
	DrawAllPortals();
	DrawPortal(portalFrame, portalRoom);
	GenerateFloorTiles(tilesSize, spaceSize, tilesThickness);
	GeneratePath(pathTilesObjs, pathVector, tilesSize, spaceSize, tilesThickness, startingPos);
	newTile(mesh, prevTilePos, offsets);
	CreateNumPad(buttonsObj, numberTextsObj, tilesSize, spaceSize, tilesThickness);
	CreateBox(boxWidth, boxHeight, boxThickness, borderThickness);
	CreateRandomMeshesInBox(mesh, number, boxSize, boxPosition, objsArray, objAngles, objsPos);
			
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	GetElevator();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
 	SetOpenglTransformOffset(mOpenglTranslationOffset);
 	SetupOpenglLights();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function Level2::Level2(isVRon, inputManager, soundManager)
{
	mIsVRon = isVRon;
	pathAnim = false;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	mIsElevatorPresent = false;
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH, ROOM_SIDE_WALL_WIDTH, ROOM_HEIGHT, true, 1, 2, true, false);
	mPortalRoom = Room(ROOM_FAR_WALL_WIDTH , PIT_HEIGHT, ROOM_SIDE_WALL_WIDTH, true, 0, 0, false);	
	mPortalRoom.Rotate(-90, 1, 0, 0);	
	
	var halfWidth = ROOM_FAR_WALL_WIDTH/2;
	var halfHeight = ROOM_SIDE_WALL_WIDTH/2;
	
	var portalFrameMesh = CVmNewMesh(VRP_PLANE, 0, [-halfWidth, -halfHeight, 0], [halfWidth, halfWidth, 0], 2, 2);
	mPortalFrame = CVmObj(portalFrameMesh);
//	mPortalFrame.Translate(0, 0.4, 15);
	mPortalFrame.Rotate(90, 1, 0, 0);
	mPortalFrameNormal = [0, 0, 1];
	mPortalRoom.GetObj().SetPosition(0, -PIT_HEIGHT, 0);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	mSpotShader = CVmShaderProgram("spotShader.glsl");	
	mToonShader = CVmShaderProgram("toonShader.glsl");	
	mAlphaShader = CVmShaderProgram("colorModulatorShader.glsl");	
	
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}


 
 function Level2::Init(lights, elevator, openglTranslationOffset)
{	
	mOpenglTranslationOffset = openglTranslationOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Position = [-10.0 * SCALE_FACTOR, -50 * SCALE_FACTOR, 10.0 * SCALE_FACTOR];
	mLight1Position =[20.0 * SCALE_FACTOR, 6 * SCALE_FACTOR, -10.0 * SCALE_FACTOR];
	mLight2Position =[-10.0 * SCALE_FACTOR, 6 * SCALE_FACTOR, 20.0 * SCALE_FACTOR];
	mLight0Diffuse = [0.5,0.5,1];
	mLight1Diffuse = [1,0,0];
	mLight2Diffuse = [1,1,1];
	
	// Setting up the lights of the scene. They're both positional lights
	mLight0 = lights[0];
	mLight0.SetPosition(mLight0Position);
	mLight0.SetDiffuse(mLight0Diffuse.x, mLight0Diffuse.y, mLight0Diffuse.z);
	mLight0.Enable();	
	
	// This second light is used only to render the portal's rooms, so it gets moved around. The initial position isn't really relevant
	mLight1 = lights[1];
	mLight1.SetPosition(mLight1Position);
	mLight1.SetDiffuse(mLight1Diffuse.x, mLight1Diffuse.y, mLight1Diffuse.z);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition(mLight2Position);
	mLight2.SetDiffuse(mLight2Diffuse.x, mLight2Diffuse.y, mLight2Diffuse.z);
	mLight2.Enable();	
		
	mElevator = elevator;
	mElevator.SetLightsRange(2,2);
//	mElevator.SetPosition(-50*SCALE_FACTOR, mElevator.GetRoomHeight()/2 + 0.08*SCALE_FACTOR, 200*SCALE_FACTOR);
	
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();
//	mCamera.SetPosition(mElevator.GetPosition());
	
	// Values used to move the portals' rooms light around, for a dynamic effect
	mIncrement = 0.03 * SCALE_FACTOR;
	mOffset = 0;
	
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();

	
	mEnding = false;
	mIsLevelCompleted = false;
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 3.0;
	
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	var lightPos = mLight1.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
//	mAnimator.CreateTransition(mLight1, lightPos + [0, -100, 0], lightPos, 20.0, false);
	
	mCameraYoffset = mCamera.GetPosition().y - mElevatorFinalPosition.y;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
	
	var provaMesh = CvmNewMesh("provaMesh.AAM");
	if(USE_TOON_SHADER == 2){		
		provaMesh.ShaderAdd("antishader.glsl", 0);
		provaMesh.ShaderActivate(true);
	}
	else if(USE_TOON_SHADER == 1){
		provaMesh.ShaderAdd("toonShader.glsl", 0);
		provaMesh.ShaderActivate(true);		
	}
	else if(USE_TOON_SHADER == 0){
		provaMesh.ShaderActivate(false);				
	}
	provaMesh.ShaderSetParameter(0, "ambient", 0, [1, 0.5, 0.3]);
	provaMesh.ShaderSetParameter(0, "diffuse", 0, [1, 1.0, 0.75]);
	provaMesh.ShaderSetParameter(0, "specular", 0, [0.5, 0.5, 0.5]);
	provaMesh.ShaderSetParameter(0, "shininess", 0, 50);
	provaMesh.ShaderSetParameter(0, "lightsRangeMin", 0, 0);
	provaMesh.ShaderSetParameter(0, "lightsRangeMax", 0, 0);
	provaMesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, SCALE_FACTOR);
	provaMesh.ShaderSetParameter(0, "alpha", 0, 1.0);
	
	provaMesh.Scale(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
	
	provaMeshObj = CVmObj(provaMesh);
	provaMeshObj.rotate(45,1,1,0);
	provaMeshObj.SetPosition(15*SCALE_FACTOR, -50*SCALE_FACTOR, -10*SCALE_FACTOR);
	
	redPathObjs = {};
	redPathSteppedObjs = {};
	redPathWalked = false;
	greenPathObjs = {};
	greenPathSteppedObjs = {};
	greenPathWalked = false;
	bluePathObjs = {};
	bluePathSteppedObjs = {};
	bluePathWalked = false;
	pinkPathObjs = {};
	pinkPathSteppedObjs = {};
	pinkPathWalked = false;
	numberOfPaths = 3;
	var tilesWidth = 2.75 * SCALE_FACTOR;
	var tilesThickness =  0.25 * SCALE_FACTOR;
	var tilesSpacing =  0.25 * SCALE_FACTOR;
	var elevatorFrontPosition = [mElevatorFinalPosition.x, mElevatorFinalPosition.y - mElevator.GetRoomHeight()/2, mElevatorFinalPosition.z+mElevator.GetRoomWidth()+tilesWidth/2+tilesSpacing*2];	
	var startingTilesPos = elevatorFrontPosition + [0, 0, 0];
	
	startingTilesPos = elevatorFrontPosition + [2*SCALE_FACTOR, 0, 0*SCALE_FACTOR];
	GeneratePath(redPathObjs, [3,-1,2,-2,2,-1,3,-1,3,-2,3,-2,4], tilesWidth, tilesSpacing, tilesThickness, startingTilesPos); //-1=Left Turn   -2 = Right Turn, if n > 0 n = number of tiles in that direction
	startingTilesPos = elevatorFrontPosition + [4*SCALE_FACTOR, 0, 0*SCALE_FACTOR];
	GeneratePath(greenPathObjs, [-1,5,-1,2,-2,6,-1,4,-1,3], tilesWidth, tilesSpacing, tilesThickness, startingTilesPos); //-1=Left Turn   -2 = Right Turn, if n > 0 n = number of tiles in that direction
	startingTilesPos = elevatorFrontPosition + [-3*SCALE_FACTOR, 0, 0*SCALE_FACTOR];
	GeneratePath(bluePathObjs, [-2,3,-1,2,-2,3,-1,1,-2,3,-1,3,-1,3,-2,2], tilesWidth, tilesSpacing, tilesThickness, startingTilesPos); //-1=Left Turn   -2 = Right Turn, if n > 0 n = number of tiles in that direction

//	GeneratePath(pinkPathObjs, [-2,1,-1,6], tileWidth, tileThickness, tilesSpacing, [0,0,0]); //-1=Left Turn   -2 = Right Turn, if n > 0 n = number of tiles in that direction

//	floorObj = GenerateFloorTiles(2.5*SCALE_FACTOR, 0.6*SCALE_FACTOR, 0.4 * SCALE_FACTOR);

	numpadButtonsObj = {};
	numpadTextsObj = {};
	var buttonsSize = 0.75 * SCALE_FACTOR;
	var buttonsSpacing = 0.04 * SCALE_FACTOR;
	var buttonsThickness = 0.1 * SCALE_FACTOR;
	CreateNumPad(numpadButtonsObj, numpadTextsObj, buttonsSize, buttonsSpacing, buttonsThickness);	
	numpadHolderObj = CvmObj(CVmNewMesh(VRP_BOX, 1, [-buttonsSize*5/2, 0, 0], [buttonsSize*5/2, mElevator.GetRoomHeight(), 0], buttonsThickness*1.5));
	numpadHolderObj.SetPosition(mElevatorFinalPosition.x + mElevator.GetRoomWidth()/2+(buttonsSize*3),mElevatorFinalPosition.y - mElevator.GetRoomHeight()/2,mElevatorFinalPosition.z + mElevator.GetRoomWidth() + buttonsThickness);

//	var boxWidth = 30*SCALE_FACTOR;
	var boxBordersThickness =  0.5*SCALE_FACTOR;
	var boxWidth = ROOM_SIDE_WALL_WIDTH/2 - boxBordersThickness - (0.1*SCALE_FACTOR);
	var boxHeight = ROOM_HEIGHT/2 - boxBordersThickness - (0.1*SCALE_FACTOR);
	var boxThickness = 10*SCALE_FACTOR;
	var boxPosition = [0, 0, mMainRoom.GetPosition().z + ROOM_SIDE_WALL_WIDTH - boxThickness*2 - boxBordersThickness - (0.1*SCALE_FACTOR)];
	boxObj = CreateBox(boxWidth, boxHeight, boxThickness,  boxBordersThickness);
	for(var i = 0; i < len(boxObj); i++){
		boxObj[i].SetPosition(boxPosition);	
	}
	
	var pyramidMesh =  CVmNewMesh(VRP_PYRAMID, 1, 1*SCALE_FACTOR, 1*SCALE_FACTOR );       // subset description
	var randomMeshNumber = 200;
	redNumberObjs = {};
	redNumberObjsOriginalAngles = {};
	redNumberObjsFinalAngles = {};
	redNumberObjsOriginalPos = {};
	redNumberObjsFinalPos = {};
	redNumberObjsAnims = {};
	CreateRandomMeshesInBox(pyramidMesh, randomMeshNumber, [boxWidth, boxHeight, boxThickness, boxBordersThickness], boxPosition, redNumberObjs, redNumberObjsOriginalAngles, redNumberObjsOriginalPos);
	blueNumberObjs = {};
	blueNumberObjsOriginalAngles = {};
	blueNumberObjsFinalAngles = {};
	blueNumberObjsOriginalPos = {};
	blueNumberObjsFinalPos = {};
	blueNumberObjsAnims = {};
	CreateRandomMeshesInBox(pyramidMesh, randomMeshNumber, [boxWidth, boxHeight, boxThickness, boxBordersThickness], boxPosition, blueNumberObjs, blueNumberObjsOriginalAngles, blueNumberObjsOriginalPos);
	greenNumberObjs = {};
	greenNumberObjsOriginalAngles = {};
	greenNumberObjsFinalAngles = {};
	greenNumberObjsOriginalPos = {};
	greenNumberObjsFinalPos = {};
	greenNumberObjsAnims = {};
	CreateRandomMeshesInBox(pyramidMesh, randomMeshNumber, [boxWidth, boxHeight, boxThickness, boxBordersThickness], boxPosition, greenNumberObjs, greenNumberObjsOriginalAngles, greenNumberObjsOriginalPos);
	
	for(var i = 0; i < randomMeshNumber; i++){
		aadd(redNumberObjsFinalAngles,[0, 90, 0]);
		aadd(redNumberObjsFinalPos,[0, 0, 2*SCALE_FACTOR]);		
		aadd(redNumberObjsAnims, [0, 0, 0]);
		
		aadd(blueNumberObjsFinalAngles,[0, 90, 0]);
		aadd(blueNumberObjsFinalPos,[-2*SCALE_FACTOR, 0, 2*SCALE_FACTOR]);		
		aadd(blueNumberObjsAnims, [0, 0, 0]);
		
		aadd(greenNumberObjsFinalAngles,[0, 90, 0]);
		aadd(greenNumberObjsFinalPos,[2*SCALE_FACTOR, 0, 2*SCALE_FACTOR]);		
		aadd(greenNumberObjsAnims, [0, 0, 0]);
	}
	animStarted = false;
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */

/*
 * Render method
 */
function Level2::Render()
{				
	// Move the lights back to their original position, because if the user previously teleported their position will be wrong
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_STARTED:
		{
			// The first thing we need to do is draw the portals. Since they are peculiar, it is best to draw them first, otherwise there might be glitches
//			DrawAllPortals();
			mPortalRoom.Draw();
			
			mMainRoom.Draw();
			
			var pathObjsArray;
			var pathSteppedObjsArray;
			var numberObjsArray;
			var arrayLength;
			var color;
			var steppedColor;
			for(var j = 0; j < numberOfPaths; j++){
				switch(j){
					case 0:
						pathObjsArray = redPathObjs;
						pathSteppedObjsArray = redPathSteppedObjs;
						numberObjsArray = redNumberObjs;
						color = [0.65,0.0,0.0];
						steppedColor = [1.0,0.0,0.0];
						break;
					case 1:
						pathObjsArray = greenPathObjs;
						pathSteppedObjsArray = greenPathSteppedObjs;
						numberObjsArray = greenNumberObjs;
						color = [0.0,0.65,0.0];
						steppedColor = [0.0,1.0,0.0];
						break;
					case 2:		
						pathObjsArray = bluePathObjs;
						pathSteppedObjsArray = bluePathSteppedObjs;
						numberObjsArray = blueNumberObjs;
						color = [0.0,0.0,0.65];
						steppedColor = [0.0,0.0,1.0];										
						break;
					case 3:
						pathObjsArray = pinkPathObjs;
						pathSteppedObjsArray = pinkPathSteppedObjs;
						numberObjsArray = {};
						color = [0.7,0.3,0.3];
						steppedColor = [1.0,0.4,0.4];
						break;
				}
				
				arrayLength = len(pathObjsArray);
				
				mSpotShader.Start();	
					mSpotShader.SetParameter("offset", 0.02 * SCALE_FACTOR);
					mSpotShader.SetParameter("outlineColor", color);
					mSpotShader.SetParameter("SCALE_FACTOR", SCALE_FACTOR);
					mSpotShader.SetParameter("color", [0.0, 0.0, 0.0]);	
							
					if(!pathAnim){						
						for(var i = 0; i < len(pathObjsArray); i++){
							mSpotShader.SetParameter("stepped", false);
							mSpotShader.SetParameter("outline", false);
							pathObjsArray[i].Draw();
							
							mSpotShader.SetParameter("outline", true);
							pathObjsArray[i].Draw();
						}
					}
					
					mSpotShader.SetParameter("outlineColor", steppedColor);
					for(var i = 0; i < len(pathSteppedObjsArray); i++){
						mSpotShader.SetParameter("stepped", true);	
						mSpotShader.SetParameter("outline", false);						
						pathSteppedObjsArray[i].Draw();
						
						mSpotShader.SetParameter("outline", true);						
						pathSteppedObjsArray[i].Draw();
					}
					
					for(var i = 0; i < len(numberObjsArray); i++){
						mSpotShader.SetParameter("offset", 0.01 * SCALE_FACTOR);
						mSpotShader.SetParameter("stepped", true);	
						mSpotShader.SetParameter("outline", false);
						numberObjsArray[i].Draw();
						
						mSpotShader.SetParameter("outline", true);
						numberObjsArray[i].Draw();
					}
					
				mSpotShader.Stop();				
			}
		}
	}

	// The elevator is always present, so it's always drawn
	mElevator.Draw();
	provaMeshObj.Draw();
	
	mToonShader.Start();
		mToonShader.SetParameter("ambient", [1, 1, 1]);
		mToonShader.SetParameter("diffuse", [1, 1, 1]);
		mToonShader.SetParameter("specular", [0.1, 0.1, 0.1]);
		mToonShader.SetParameter("shininess", 50);
		mToonShader.SetParameter("lightsRangeMin", 0);
		mToonShader.SetParameter("lightsRangeMax", 2);
		mToonShader.SetParameter("SCALE_FACTOR", SCALE_FACTOR);
		mToonShader.SetParameter("alpha", 1.0);
		
		numpadHolderObj.Draw();
	
		mToonShader.SetParameter("diffuse", [0.8, 0.8, 0.8]);
		for(var i = 0; i < 9; i++){		
			numpadButtonsObj[i].Draw();
		}		
		
		mToonShader.SetParameter("lightsRangeMin", 0);
		mToonShader.SetParameter("lightsRangeMax", 2);
		mToonShader.SetParameter("diffuse", [1, 1, 1]);
		for(var i = 0; i < len(boxObj); i++){
			if(i != 2){	//Glass wall
				boxObj[i].Draw();
			}
		}		
	mToonShader.Stop();
			
	var boxColor = [0.6, 0.6, 1];
	var boxAlpha = 0.3;
	mAlphaShader.Start();
		mAlphaShader.SetParameter("time", 0);
		mAlphaShader.SetParameter("alpha", boxAlpha);
		mAlphaShader.SetParameter("startingColor", boxColor);
		mAlphaShader.SetParameter("finalColor", boxColor);	
		boxObj[2].Draw(); //Glass wall
	mAlphaShader.Stop();
	
	for(var i = 0; i < 9; i++){	
		numpadTextsObj[i].Draw();
	}	
	
	if(mIsVRon){
		mController1.Draw();
		mController2.Draw();
	}
}

/*
 * This method draws every portal in the scene. This function MUST be called after the opening of a SceneBegin()/SceneEnd() block, 
 * otherwise it won't give out any results
 */
function Level2::DrawAllPortals()
{
	// To render the portal we need the stencil buffer
	glEnable(GL_STENCIL_TEST);

	// I render the portal
	DrawPortal(mPortalFrame, mPortalRoom);


	// After drawing the portals, the stencil test is no longer needed
	glDisable(GL_STENCIL_TEST);
	
	// Now the portals are drawn, but NOT in the depth buffer. This means that when we'll draw the rest of the scene, the computed depth will be wrong.
	// To solve this, I re-draw the portal's frame, but without actually applying colors, and I do it while the depth buffer is active and clear, so that
	// the frames will be put in there and will be taken into account when drawing the rest of the scene.
	// So, first off, I dsable the color buffer
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	
	// I enable writing to the depth buffer, enable the depth test and clear the buffer
	glDepthMask(GL_TRUE);
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
	
	
	// Now I draw each portal, even the ones that weren't actually visible, because they still need to "occupy space";
	// I use the silhouette shader so that the outline of the frames will be there
	mSilhouetteShader.Start();
		mSilhouetteShader.SetParameter("offset", 0.08 * SCALE_FACTOR);
		mSilhouetteShader.SetParameter("color", [0.0, 0.0, 0.0]);
		mPortalFrame.Draw();
	mSilhouetteShader.Stop();
	
	mPortalFrame.Draw();

	// I enable the color buffer again for the rest of the scene
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
}

 /*
  * Method for drawing a single portal room in a single portal frame.
  * Note: this method modifyes the currently active SceneBegin/SceneEnd block, meaning that it closes the currently active block and opens a new one without
  * closing it. So, this function MUST be called after the opening of a SceneBegin() block, and it assures that at the end of the method a block will
  * be still open for further use (so that outside this function we still have to call SceneEnd())
  * 
  * portalFrame: (CVmObj) the frame from which the portal's room will be visible
  * portalRoom: (Room) the room that needs to be rendered and that is seen from the portal
  */
function Level2::DrawPortal(portalFrame, portalRoom)
{
	// I add a matrix to the opengl stack; I will update the camera's position for the time being, so a copy of the current matrix 
	// comes in handy when we need to go back to how thing where
	glPushMatrix();
	
	// In order to draw the portal, I first need to draw the frame using the stencil buffer. To do that, I first disable the color, writing to the depht
	// buffer and the depth buffer itself; they're not needed now
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	glDepthMask(GL_FALSE);
	glDisable(GL_DEPTH_TEST);
	
	// I make sure that the stencil test will fail for every pixel drawn (thanks to GL_NEVER)
	glStencilFunc(GL_NEVER, 1, 0xFF);
	
	// I state that when the stencil test fails (so always, because I'm using GL_NEVER), the buffer will replace the current value in the buffer (0 initially)
	// with the reference value I passed as parameter to glStencilFunc (1 in this case). Basically this means that when I'll draw the portal's frame soon,
	// the stencil buffer will be filled with 1s for every fragment of the frame and 0s for every fragment outside the frame. This will help us
	// render the portal's room ONLY where the frame was rendered
	glStencilOp(GL_REPLACE, GL_KEEP, GL_KEEP);
	
	// I enable writing to the stencil buffer
	glStencilMask(0xFF);
	
	// I empty the stencil buffer
	glClear(GL_STENCIL_BUFFER_BIT);
	
	// I draw the portal frame; now the stencil buffer will contain 1s where the frame was rendered and 0s outside
	portalFrame.Draw();
	
	
	// In order to draw the portal room, I need translate BACK the world by the opengl offset, and translate it back FORWARD when I'm done with the portal,
	// otherwise the camera's position will be wrong, and so will the rendering of the portal's room
	glTranslate(-mOpenglTranslationOffset);
	
	
	// Getting the positions of the frame
	var framePos = portalFrame.GetPosition();
	
	// First I need to place the camera at the end of the portal's room, so I'm going to compute that position
	var localPoint = [0, 0, portalRoom.GetRoomHeight()];
	var newCameraPosition = portalRoom.LocalToWorld(localPoint);
		
	var translation = newCameraPosition - framePos - mOpenglTranslationOffset;
	
	// Now I want to move the first opengl light so that it's in front of the portal and it moves around. The change of position must be done outside theds
	// SceneBegin/SceneEnd block, just like for the camera, otherwise (in XVR) it doesn't have any effect.
	mOffset += mIncrement;
	
	var newLightPos = newCameraPosition;
	
	// I place the light where the camera's default position is, but I change it a bit in a pseudo-random way to make it move dynamically
	newLightPos.x += mOffset;
	newLightPos.y += sin(mOffset*1);
	
	if(mOffset > 7 * SCALE_FACTOR || mOffset < -7 * SCALE_FACTOR)
		mIncrement = -mIncrement;
		
	var oldLightPos = mLight0.GetPosition();

	glTranslate(-translation);
	glLight(GL_LIGHT0, GL_POSITION, [newLightPos.x, newLightPos.y, newLightPos.z, 1.0]);
	
	// Since the portal's room as to be rendered "normally", I enable the usual things (color and depth buffer, which is emptied)
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	glDepthMask(GL_TRUE);
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
	
	// I disable writing to the stencil buffer, and I make sure that a pixel passes the stencil test ONLY if its value in the buffer is 1. That is,
	// only the pixels belonging to the previously rendered portal's frame will pass the test, so the portal's room will be rendered there and olny there
	glStencilMask(0x00);
	glStencilFunc(GL_EQUAL, 1, 0xFF);
	
	// Drawing the actual portal's room where the stencil is 1
	portalRoom.Draw();
	
	// I translate back the world where it was before drawing the portal
	glTranslate(mOpenglTranslationOffset);

	// I move the light back where it was; I use opengl so that the effect is immediate
	glLight(GL_LIGHT0, GL_POSITION, [oldLightPos.x, oldLightPos.y, oldLightPos.z, 1.0]);

	// I'm done with this portal, so I pop the matrix from the stack
	glPopMatrix();
}







/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level2::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		case STATUS_ELEVATOR_MOVING: 
		{			
		    // I make sure that the camera doesn't go out of the elevator while it's going up
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();
	
			// I check if the elevator is halfway through the transtition; if this is the case, I change its lights range for the rendering (but only
			// if I didn't do so already)
			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2 && mElevator.GetLightsRange().y < 1)
				 mElevator.SetLightsRange(1,2);
			
			// I make sure that the camera goes up with the elevator by increasing the y along with the elevator's
			cameraPosition.y = mCameraYoffset + elevatorPos.y;
	   	    
			// To make the shaking camera effect, I randomly move the x and y axis with random values
		    cameraPosition.y += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
		    cameraPosition.x += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
			
			// I set the new (shaken and at level with the elevator) position
			mCamera.SetPosition(cameraPosition + mOpenglTranslationOffset);
			
			// I check if the elevator reached its destination, and if this is so I open the door and change status
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
			}
	
			break;
		}		
		// This is the case where the elevator arrived, BUT the player is still inside
		case STATUS_ELEVATOR_ARRIVED:
		{
			// I check if the player goes out from the elevator. Note: I'm not checking that he exits from the doors; he can pass through walls right now.
			// If the player comes out, I close the doors and change status
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			if(!animStarted){
				animStarted = true;
				var startAngle;
				var finalAngle;
				var time;
				var numberArrayObjs;
				for(var j = 0; j < numberOfPaths; j++){
					switch(j){
						case 0:	
							numberArrayObjs = redNumberObjs;
							startAngle = redNumberObjsOriginalAngles;
							finalAngle = redNumberObjsFinalAngles;
							break;
						case 1:
							numberArrayObjs = greenNumberObjs;
							startAngle = greenNumberObjsOriginalAngles;
							finalAngle = greenNumberObjsFinalAngles;
							break;
						case 2:
							numberArrayObjs = blueNumberObjs;
							startAngle = blueNumberObjsOriginalAngles;
							finalAngle = blueNumberObjsFinalAngles;
							break;
					}
					
					for(var i = 0; i < len(numberArrayObjs); i++){
						time = (Rand(13)+ 11) / 5;
						mAnimator.CreateRotatingTransition(numberArrayObjs[i], Rand(360), Rand(360), [Rand(1),Rand(1),Rand(1)], time-0.5, true, false);
					}	
				}
			}
			
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{
			// I make sure that the player stay's inside the room and outside of the elevator
//			if(!mIsVRon && mElevator.IsPointInElevator(cameraPosition) || !mMainRoom.IsPointInRoom(cameraPosition))
//		    	mInputManager.RestoreCameraPosition();
//			
			var cameraPos = mCamera.GetPosition();
			var tilePos;
			
			var stepDistance = 3*SCALE_FACTOR;
			
			if(pathAnim)
				stepDistance = 8*SCALE_FACTOR;
				
			var pathObjsArray;
			var pathSteppedObjsArray;
			var originaLength;
			var arrayLength;
			var pathWalked;
			for(var j = 0; j < numberOfPaths; j++){
				switch(j){
					case 0:
						pathObjsArray = redPathObjs;
						pathSteppedObjsArray = redPathSteppedObjs;
						pathWalked = redPathWalked;
						break;
					case 1:
						pathObjsArray = greenPathObjs;
						pathSteppedObjsArray = greenPathSteppedObjs;
						pathWalked = greenPathWalked;
						break;
					case 2:
						pathObjsArray = bluePathObjs;
						pathSteppedObjsArray = bluePathSteppedObjs;
						pathWalked = bluePathWalked;
						break;
					case 3:
						pathObjsArray = pinkPathObjs;
						pathSteppedObjsArray = pinkPathSteppedObjs;
						break;
				}
				arrayLength = len(pathObjsArray);
				originaLength = len(pathObjsArray);
				
				for(var i = 0; i < arrayLength; i++){			
					tilePos = pathObjsArray[i].GetPosition();
					if(cameraPos.x < tilePos.x + stepDistance && cameraPos.x > tilePos.x - stepDistance
						&& cameraPos.z < tilePos.z + stepDistance && cameraPos.z  > tilePos.z - stepDistance){
						if(pathAnim)
							mAnimator.CreateTransition(pathObjsArray[i], pathObjsArray[i].GetPosition() + [0, -10*SCALE_FACTOR, 0], pathObjsArray[i].GetPosition(), 0.25, false);
						aadd(pathSteppedObjsArray, pathObjsArray[i]);
						adel(pathObjsArray, i);
						i = 0;
						arrayLength--;
					}
				}
						
				var startPos;
				var finalPos;
				var startAngle;
				var finalAngle;
				var time;
				var numberArrayObjs;	
				var walkedPath;
				var objsAnimations;
				switch(j){
					case 0:	
						numberArrayObjs = redNumberObjs;
						objsAnimations = redNumberObjsAnims;
						startAngle = redNumberObjsOriginalAngles;
						finalAngle = redNumberObjsFinalAngles;
						startPos = redNumberObjsOriginalPos;
						finalPos = redNumberObjsFinalPos;	
						walkedPath = redPathWalked;
						break;
					case 1:
						numberArrayObjs = greenNumberObjs;
						objsAnimations = greenNumberObjsAnims;
						startAngle = greenNumberObjsOriginalAngles;
						finalAngle = greenNumberObjsFinalAngles;
						startPos = greenNumberObjsOriginalPos;
						finalPos = greenNumberObjsFinalPos;
						walkedPath = greenPathWalked;		
						break;
					case 2:
						numberArrayObjs = blueNumberObjs;
						objsAnimations = blueNumberObjsAnims;
						startAngle = blueNumberObjsOriginalAngles;
						finalAngle = blueNumberObjsFinalAngles;
						startPos = blueNumberObjsOriginalPos;
						finalPos = blueNumberObjsFinalPos;
						walkedPath = bluePathWalked;		
						break;
					case 3:
						pinkPathWalked = true;			
						outputln("\n\nPINK PATH WALKED");
						break;
				}	
						
				if(originaLength != arrayLength && arrayLength < 1){
					if(j == 0){	
						redPathWalked = true;
						walkedPath = true;				
						outputln("\n\nRED PATH WALKED");						
					}
					else if(j == 1){
						greenPathWalked = true;	
						walkedPath = true;		
						outputln("\n\nGREEN PATH WALKED");
						
					}
					else if(j == 2){
						bluePathWalked = true;	
						walkedPath = true;		
						outputln("\n\nBLUE PATH WALKED");					
					}
					
					for(var i = 0; i < len(numberArrayObjs); i++){
						time = (Rand(10)+ 11) / 5;
						mAnimator.RemoveTransitionByObject(numberArrayObjs[i], 1);
						numberArrayObjs[i].SetRotation(startAngle[i].x, 1,0,0);
						numberArrayObjs[i].SetRotation(startAngle[i].y, 0,1,0);
						numberArrayObjs[i].SetRotation(startAngle[i].z, 0,0,1);
						mAnimator.CreateRotatingTransition(numberArrayObjs[i], startAngle[i].x, finalAngle[i].x, [1,0,0], time-0.5, false, false);
						mAnimator.CreateRotatingTransition(numberArrayObjs[i], startAngle[i].y, finalAngle[i].y, [0,1,0], time-0.5, false, false);
						mAnimator.CreateRotatingTransition(numberArrayObjs[i], startAngle[i].z, finalAngle[i].z, [0,0,1], time-0.5, false, false);
												
//						mAnimator.CreateTransition(numberArrayObjs[i], [startPos[i].x, startPos[i].y, startPos[i].z], [startPos[i].x, startPos[i].y, finalPos[i].z], time, false);
//						mAnimator.CreateTransition(numberArrayObjs[i], [startPos[i].x, startPos[i].y, finalPos[i].z], [startPos[i].x, finalPos[i].y, finalPos[i].z], time, false);
//						mAnimator.CreateTransition(numberArrayObjs[i], [startPos[i].x, finalPos[i].y, finalPos[i].z], [finalPos[i].x, finalPos[i].y, finalPos[i].z], time, false);
					}	
				}
				
				
				//Workaround for the mAnimator diagonal transition bug
				//I'll start first the animation on the x axis, then the one on the Y axis and in the end the one on the z axis
				//so that the movement are computed correctly for every direction
				if(walkedPath){
					var objPos;
					var checkOffs = 0.35*SCALE_FACTOR; //The position is never perfect
					for(var i = 0; i < len(numberArrayObjs); i++){
						objPos = numberArrayObjs[i].GetPosition();
						time = (Rand(10)+ 11) / 5;
						
						if(objsAnimations[i].x == 0){
							objsAnimations[i].x = 1;
							mAnimator.CreateTransition(numberArrayObjs[i], [startPos[i].x, startPos[i].y, startPos[i].z], [finalPos[i].x, startPos[i].y, startPos[i].z], time, false);
						}
						
						if(objPos.x < finalPos[i].x + checkOffs && objPos.x > finalPos[i].x - checkOffs && objsAnimations[i].y == 0){
							objsAnimations[i].y = 1;
							mAnimator.CreateTransition(numberArrayObjs[i], [finalPos[i].x, startPos[i].y, startPos[i].z], [finalPos[i].x, finalPos[i].y, startPos[i].z], time, false);
						}
						
						if(objPos.y < finalPos[i].y + checkOffs && objPos.y > finalPos[i].y - checkOffs && objsAnimations[i].z == 0){
							objsAnimations[i].z = 1;
							mAnimator.CreateTransition(numberArrayObjs[i], [finalPos[i].x, finalPos[i].y, startPos[i].z], [finalPos[i].x, finalPos[i].y, finalPos[i].z], time, false);
						}
					}
				}
			}
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level2::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level2::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

/*
 * Method called by the GameManager to check if the level is completed
 */
function Level2::GetElevator()
{
	return mElevator;
}

/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level2::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	// I'm stating that there is no intersection
	var intersectedPlane = -1;

		
	// If there was no collision with the frames, I check the elevator if it's present. The method will return -1 if no interception was found,
	// 0 if a good intercetpion was found (i.e. the floor, with the elevator open), or a value > 1 indicating which part of the elevator was found (which
	// one is not relevant in this case)
	if(mIsElevatorPresent)
		intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	// If still no interception was found, I check the boundaries of the room
	if(intersectedPlane == -1)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	// If I'm here, I definitely found a wall
	isWall = true;
	
	// If the intersection value is 0, a good point was found
	return intersectedPlane == 0;
}

function Level2::GenerateFloorTiles(tilesSize, spaceSize, tilesThickness)
{
	var returnObj = CVmObj();
	var tileMesh = CVmNewMesh(VRP_BOX, 1, [-tilesSize/2, -tilesSize/2, 0], [tilesSize/2, tilesSize/2, 0], tilesThickness);
	var lastLength = 0;
	var totalLength = tilesSize + spaceSize;
	var totalHeight = tilesSize + spaceSize;
	
	returnObj.AddChild(CVmObj(tileMesh), totalLength, totalHeight, 0);	
	
	while(true){
		totalLength += (tilesSize + spaceSize);
		
		if(totalLength >= ROOM_FAR_WALL_WIDTH){
			totalHeight += tilesSize + spaceSize;	
			lastLength = totalLength;
			totalLength = tilesSize + spaceSize;
		}	
		
		if(totalHeight >= ROOM_FAR_WALL_WIDTH){
			break;			
		}
		else{		
			returnObj.AddChild(CVmObj(tileMesh), totalLength, totalHeight, 0);	
		}
	}
	
	returnObj.rotate(90, 1, 0, 0);
	returnObj.SetPosition(-lastLength/2,0.3 * SCALE_FACTOR,-totalHeight/2);
	
	return returnObj;
}


function Level2::newTile(mesh, prevTilePos, offsets){
	var newObj = CVmObj(mesh);
	newObj.rotate(90, 1, 0, 0);
	newObj.SetPosition(prevTilePos.x + offsets.x, prevTilePos.y + offsets.y, prevTilePos.z + offsets.z);	
	return newObj;
}


function Level2::GeneratePath(pathTilesObjs, pathVector, tilesSize, spaceSize, tilesThickness, startingPos){
	var tileMesh = CVmNewMesh(VRP_BOX, 1, [-tilesSize/2, -tilesSize/2, 0], [tilesSize/2, tilesSize/2, 0], tilesThickness);
	
	var yOffset = -tilesThickness;
	var xOffset = spaceSize + tilesSize;
	var zOffset = spaceSize + tilesSize;
	
	var tileObj;	
	
	//add the first tile
	tileObj = newTile(tileMesh, [0,0,0], startingPos);
	
//	aadd(pathTilesObjs, tileObj);
	
	var direction = [0,0,1,0]; //Defines in which direction the path is going	
//	var pathVector = [0,0,0,1,0,0,2,0,0,1,0,0,0]; //0 = straight, 1 = turn left, 2 = turn right
	for(var i = 0; i < len(pathVector); i++){	
		if(pathVector[i] < 0){
			if(pathVector[i] == -1 && direction.z == 1){
				direction = [1,0,0,1];
			}else if(pathVector[i] == -2 && direction.z == 1){
				direction = [-1,0,0,1];
			}else if(pathVector[i] == -1 && direction.z == -1){
				direction = [-1,0,0,1];			
			}else if(pathVector[i] == -2 && direction.z == -1){
				direction = [1,0,0,1];
			}else if(pathVector[i] == -1 && direction.x == 1){
				direction = [0,0,-1,1];			
			}else if(pathVector[i] == -2 && direction.x == 1){
				direction = [0,0,1,1];
			}else if(pathVector[i] == -1 && direction.x == -1){
				direction = [0,0,1,1];			
			}else if(pathVector[i] == -2 && direction.x == -1){
				direction = [0,0,-1,1];
			}
		}		
		if(direction[3] == 0){
			for(var j = 0; j < pathVector[i]; j++){
				tileObj = newTile(tileMesh, tileObj.GetPosition(), [xOffset*direction.x, yOffset*direction.y, zOffset*direction.z]);				
				aadd(pathTilesObjs, tileObj);						
			}			
		}	
		else
			direction[3] = 0;
	}
}


function Level2::CreateNumPad(buttonsObj, numberTextsObj, tilesSize, spaceSize, tilesThickness){
	var buttonMesh = CVmNewMesh(VRP_BOX, 1, [-tilesSize/2, -tilesSize/2, 0], [tilesSize/2, tilesSize/2, 0], tilesThickness);
	var offsetY = tilesSize + spaceSize;
	var offsetX = tilesSize + spaceSize;
	var offsetZ = tilesThickness;
	
	var txt;
	var txtObj;
	var buttonObj;
	var num = 9;
	
	for(var i = 1; i < 4; i++){
		for(var j = 1; j < 4; j++){
			var buttonPosX = (mElevatorFinalPosition.x + mElevator.GetRoomWidth()/2) - (offsetX * j) + (tilesSize * 5);
			var buttonPosY = mElevatorFinalPosition.y + offsetY*i;
			var buttonPosZ = mElevatorFinalPosition.z + mElevator.GetRoomWidth()+(tilesThickness * 2);
			txt = CVmText();
			txt.Load(char(48+(num--)));
			txt.SetColor(0, 0, 0);
			
			txtObj = CVmObj();
			txtObj.LinkToText(txt);
			txtObj.SetScale(0.1,0.1,0.1);
			txtObj.SetPosition(buttonPosX-(0.1*SCALE_FACTOR),buttonPosY-(1.65*SCALE_FACTOR), buttonPosZ+0.05*SCALE_FACTOR);
			
			buttonObj = CVmObj(buttonMesh);
			buttonObj.SetPosition(buttonPosX, buttonPosY-(1.5*SCALE_FACTOR), buttonPosZ);	
			
			aadd(numberTextsObj, txtObj);
			aadd(buttonsObj, buttonObj);
//			retObj.AddChild(buttonObj, -offsetX*j,offsetY*i,0);	
//			retObj.AddChild(txtObj, -offsetX*j-0.1*SCALE_FACTOR,offsetY*i-0.15*SCALE_FACTOR,0.05*SCALE_FACTOR);			
		}
	}
	
//	retObj.SetPosition(mElevatorFinalPosition + [mElevator.GetRoomWidth()/2+(offsetX*4), -1*SCALE_FACTOR, mElevator.GetRoomWidth()+tilesThickness]);
}


function Level2::CreateBox(boxWidth, boxHeight, boxThickness, borderThickness){
	var fixedOffset;	
	var retObj = {};
	aadd(retObj, CVmObj());
	aadd(retObj, CVmObj());
	aadd(retObj, CVmObj());
	aadd(retObj, CVmObj());
	aadd(retObj, CVmObj());
	aadd(retObj, CVmObj());
	aadd(retObj, CVmObj());	
	
	var frontBackTopBottomMesh;
	frontBackTopBottomMesh = CVmNewMesh(VRP_PLANE, 1, [-boxWidth, -borderThickness, 0], [boxWidth, borderThickness, 0], 2,2 );
	
	var frontBackLeftRightMesh;
	frontBackLeftRightMesh = CVmNewMesh(VRP_PLANE, 1, [-borderThickness, -(boxHeight+borderThickness), 0], [borderThickness, boxHeight+borderThickness, 0], 2,2 );
	
	var frontBackMesh = CVmNewMesh(VRP_PLANE, 1, [-(boxWidth - borderThickness), -(boxHeight-borderThickness), 0], [+(boxWidth - borderThickness), (boxHeight-borderThickness), 0], 2,2 );
	
	var sidesTopBottomMesh;
	sidesTopBottomMesh = CVmNewMesh(VRP_PLANE, 1, [-borderThickness, -boxThickness, 0], [borderThickness, boxThickness, 0], 2,2 );
	sidesTopBottomMesh.Rotate(90,0,0,1);
	sidesTopBottomMesh.Rotate(90,0,1,0);
	
	var sidesLeftRightMesh;
	sidesLeftRightMesh = CVmNewMesh(VRP_PLANE, 1, [-borderThickness, -(boxHeight+borderThickness), 0], [borderThickness, boxHeight+borderThickness, 0], 2,2 );
	sidesLeftRightMesh.Rotate(90,0,1,0);
	
	var sidesMesh = CVmNewMesh(VRP_PLANE, 1, [-(boxThickness-borderThickness), -(boxHeight-borderThickness), 0], [+(boxThickness - borderThickness), (boxHeight-borderThickness), 0], 2,2 );
	sidesMesh.Rotate(90,0,1,0);
	
	var roofFloorLeftRightMesh;
	roofFloorLeftRightMesh = CVmNewMesh(VRP_PLANE, 1, [-borderThickness, -(boxThickness+borderThickness), 0], [borderThickness, boxThickness+borderThickness, 0], 2,2 );
	roofFloorLeftRightMesh.Rotate(90,1,0,0);
	
	var roofFloorTopBottomMesh;
	roofFloorTopBottomMesh = CVmNewMesh(VRP_PLANE, 1, [-boxWidth, -borderThickness, 0], [boxWidth, borderThickness, 0], 2,2 );
	roofFloorTopBottomMesh.Rotate(90,1,0,0);	
	
	var roofFloorMesh = CVmNewMesh(VRP_PLANE, 1, [-(boxWidth-borderThickness), -(boxThickness-borderThickness), 0], [+(boxWidth - borderThickness), (boxThickness-borderThickness), 0], 2,2 );
	roofFloorMesh.Rotate(90,1,0,0);
	
	fixedOffset = boxThickness*2+borderThickness;
	//front
	retObj[0].AddChild(CvmObj(frontBackTopBottomMesh), 		0, 		 	0, 		  	 		-borderThickness);
	retObj[0].AddChild(CvmObj(frontBackTopBottomMesh), 		0, 		 	boxHeight*2, 		-borderThickness);
	retObj[0].AddChild(CvmObj(frontBackLeftRightMesh),	boxWidth, 		boxHeight,   		-borderThickness);
	retObj[0].AddChild(CvmObj(frontBackLeftRightMesh),	-boxWidth, 		boxHeight,   		-borderThickness);	
	retObj[2].AddChild(CvmObj(frontBackMesh), 			0, 				boxHeight, 			-borderThickness);
	
	//back
	retObj[0].AddChild(CvmObj(frontBackTopBottomMesh), 		0, 			0, 		  	 		fixedOffset);
	retObj[0].AddChild(CvmObj(frontBackTopBottomMesh), 		0, 			boxHeight*2, 		fixedOffset);
	retObj[0].AddChild(CvmObj(frontBackLeftRightMesh), 	boxWidth, 		boxHeight,   		fixedOffset);
	retObj[0].AddChild(CvmObj(frontBackLeftRightMesh),	-boxWidth, 		boxHeight,   		fixedOffset);	
	retObj[1].AddChild(CvmObj(frontBackMesh), 			0, 				boxHeight, 			fixedOffset);	
	 
	//sideLeft
	fixedOffset = boxWidth+borderThickness;
	retObj[0].AddChild(CvmObj(sidesTopBottomMesh),   	fixedOffset, 	0, 					boxThickness);
	retObj[0].AddChild(cvmObj(sidesTopBottomMesh),   	fixedOffset, 	boxHeight*2, 		boxThickness);
	retObj[0].AddChild(CvmObj(sidesLeftRightMesh),   	fixedOffset, 	boxHeight, 			boxThickness*2);
	retObj[0].AddChild(CvmObj(sidesLeftRightMesh),   	fixedOffset,	boxHeight, 			0);
	retObj[3].AddChild(CvmObj(sidesMesh), 				fixedOffset, 	boxHeight, 			boxThickness);
	
	//sideRight
	retObj[0].AddChild(CvmObj(sidesTopBottomMesh), 		-fixedOffset, 	0, 					boxThickness);
	retObj[0].AddChild(cvmObj(sidesTopBottomMesh), 		-fixedOffset, 	boxHeight*2, 		boxThickness);
	retObj[0].AddChild(CvmObj(sidesLeftRightMesh), 		-fixedOffset, 	boxHeight, 			boxThickness*2);
	retObj[0].AddChild(CvmObj(sidesLeftRightMesh), 		-fixedOffset, 	boxHeight, 			0);
	retObj[4].AddChild(CvmObj(sidesMesh), 				-fixedOffset, 	boxHeight, 			boxThickness);
	
	//roof
	fixedOffset = boxHeight*2 + borderThickness;
	retObj[0].AddChild(CvmObj(roofFloorTopBottomMesh),  0,				fixedOffset, 		0);
	retObj[0].AddChild(CvmObj(roofFloorTopBottomMesh),  0, 				fixedOffset, 		boxThickness*2);
	retObj[0].AddChild(CvmObj(roofFloorLeftRightMesh),  boxWidth,		fixedOffset, 		boxThickness);
	retObj[0].AddChild(CvmObj(roofFloorLeftRightMesh), -boxWidth,		fixedOffset, 		boxThickness);
	retObj[5].AddChild(CvmObj(roofFloorMesh), 			0,				fixedOffset, 		boxThickness);
	
	//floor
	retObj[0].AddChild(CvmObj(roofFloorTopBottomMesh), 	0,				-borderThickness,	0);
	retObj[0].AddChild(CvmObj(roofFloorTopBottomMesh), 	0, 				-borderThickness, 	boxThickness*2);
	retObj[0].AddChild(CvmObj(roofFloorLeftRightMesh),	boxWidth,		-borderThickness, 	boxThickness);
	retObj[0].AddChild(CvmObj(roofFloorLeftRightMesh),	-boxWidth,		-borderThickness, 	boxThickness);
	retObj[6].AddChild(CvmObj(roofFloorMesh),			0,				-borderThickness, 	boxThickness);
	
	return retObj;	
}


function Level2::CreateRandomMeshesInBox(mesh, number, boxSize, boxPosition, objsArray, objsAngles, objsPos){
	var offset = [1*SCALE_FACTOR, 0.5*SCALE_FACTOR, 1*SCALE_FACTOR];
	var randomx = 0;
	var randomy = 0;
	var randomz = 0;
	var randomDecimal;
	
	for(var i = 0; i < number; i++){
		randomx = Rand(boxSize.x*2 -offset.x) + boxPosition.x - boxSize.x +offset.x+boxSize.a;
		randomy = Rand(boxSize.y*2)+boxPosition.y;
		randomz = Rand(boxSize.z*2)+boxPosition.z;
		randomDecimal = Rand(20) / (Rand(50)+21);
		
		aadd(objsArray, CvmObj(mesh));
		
		aadd(objsAngles,[Rand(360), Rand(360), Rand(360)]);
		objsArray[i].SetRotation(objsAngles[i].x, 1, 0, 0);
		objsArray[i].SetRotation(objsAngles[i].y, 0, 1, 0);
		objsArray[i].SetRotation(objsAngles[i].z, 0, 0, 1);
		
		aadd(objsPos, [randomx, randomy, randomz]);
		objsArray[i].SetPosition(objsPos[i].x, objsPos[i].y, objsPos[i].z);
	}
}

function Level2::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, mLight0Diffuse); 
	glLight(GL_LIGHT1, GL_DIFFUSE, mLight1Diffuse); 
	glLight(GL_LIGHT2, GL_DIFFUSE, mLight2Diffuse);
}


