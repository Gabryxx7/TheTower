
#define STATUS_MENU     0
#define STATUS_INGAME   1

#include "Utils.s3d"
#include "Level0.s3d"
#include "Level1.s3d"
#include "Level2.s3d"
#include "Level3.s3d"
#include "InputManager.s3d"

/*
 * This class manages the whole game and the transition between levels.
 * It also manages the rendering and the integration of the HTC Vive, so that levels don't need to be aware of it (too much).
 * 
 * NOTE: The controller's CVmObj should be created in the GameManager but passed to each level's class. The level should handle rendering them, but
 * NOT updating their position, sinceit's better that the GameManger does that, so that the levels have no idea of the HTC Vive being used.
 * The ideal would be to update their position in the UpdateLogic of the GameManager (at start) and then setting the new position to the level's controller
 * (using a method like "mCurrentLevel.SetControllerPosition(pos)".
 */
class GameManager
{
	var mGameStatus;
	var mGameStarted;
	var mGameReady;
	var mCurrentLevel;
	var mCurrentLevelNumber;
	var mMenu;
	
	var mElevator;
	
	var mCamera;
	
	var mInputManager;
	var mSoundManager;
	
	// Booleans that indicate if the screen is fading to black or not
	var mFadingIn;
	var mFadingOut;
	
	// If the screen is fading to black, this float contains the alpha of the fading (1 == totally black, 0 == totally invisible)
	var mFadeToBlackAlpha;
	
	
	var mLights;
	
	var mLevel1;
	
	/* In order to use the teleporting feature along with the HTC Vive, when a user teleports to a destination we need to change the camera's position 
	 * in opengl fashon, meaning NOT using the SetPosition() of XVR. This is because the HTC Vive is powered by OpenVR, which works in its own way, and 
	 * it's not related to XVR classes. So, to move the Vive camera (and so also the XVR one) we need to move the camera as if we were using only opengl,
	 * meaning that we have to use glTransform(). We basically translate the whole scene at every frame, according to this offset.
	 * In order for this to NOT affect XVR objects, we need to be careful. For instance, if I need to get the position of the camera I need to 
	 * subtracts the vector mOpenglTranslationOffset to get the "actual" position of the camera in the world, since using glTransform doesn't change
	 * the camera position in the XVR object. Same goes for the lights.
	 * So, this vector is very important in the whole game, and everytime it gets changed (i.e. when the user teleports), the current level
     * needs to know the updated value, otherwise the level's logic will be updated using wrong positions */
	var mOpenglTranslationOffset;
	
	
	// This object is the circle that appears when the user wants to teleport to a destination
	var mPositionCircleObj;
	
	// Radius of the position circle
	var mPositionCircleRadius;
		
	// Shader used to render the position circle
	var mPositionCircleShader;
	
	// Boolean that indicates if the current position of the circle is a valid position for teleportation
	var mIsPositionValid;
	
	// Shader used to create the dashed lines when the player uses that teleportation feature
	var mDashedLineShader;
	
	// Offset used by the "dashed line shader" to create the illusion that the line segments are moving
	var mDashedLinesOffset;
	
	// If the current position of the circle isn't valid, this boolean indicates if it's placed on a wall; in that case the circle will be shown anyway, 
	// otherwise it will be hidden for rendering simplicity (meaning that it would be hard to render correctly the circle to a surface that is not planar like a wall)
	var mIsWall;
	
	// This boolean indicates whether the user is currently pressing the secondary button for teleportation
	var mIsPressingSecondaryButton;
	
	
	var frameNum;


	// Private methods
	XVRRendering();
	DrawCrosshair();
	FadeToBlackScreen(fadeIn);
	
	// Public methods
	Render();
	UpdateLogic(dt);
};


function GameManager::GameManager()
{
	frameNum = 0;
	mGameStatus = STATUS_INGAME;
		
	mGameStarted = false;
	mGameReady = false;
	
	mCamera = CameraGetCurrent();
	
	mInputManager = InputManager();
	mInputManager.SetActiveCamera(mCamera);
	
	mSoundManager = SoundManager();
	mSoundManager.SetMusic("sounds/Nexus - Tranquility.mp3", 0.5, true);
	mSoundManager.PlayMusic();
	
	mLights = {};
	
	
	var light0 = CVmLight();
	light0.SetPosition([-10.0, 10.0, 10.0]);
	light0.SetDiffuse(1, 1, 1);
	light0.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light0.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light0.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light0.Disable();	
	
	var light1 = CVmLight();
	light1.SetPosition([-10.0, 10.0, 10.0]);
	light1.SetDiffuse(1, 1, 1);
	light1.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light1.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light1.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light1.Disable();	
	
	var light2 = CVmLight();
	light2.SetPosition([-10.0, 10.0, 10.0]);
	light2.SetDiffuse(1, 1, 1);
	light2.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light2.SetParameter(GL_LINEAR_ATTENUATION, 0.9000);
	light2.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light2.Disable();
	
	aadd(mLights, light0);
	aadd(mLights, light1);
	aadd(mLights, light2);
	
	// 
	mOpenglTranslationOffset = [0, -3, 0]; //x,y,z	
	if(DEBUG_MODE)
	{
		// The current level takes as parameter the input manager, which is shared among every level
		mCurrentLevel = Level0(mInputManager, mSoundManager, mLights);
		
		mElevator = mCurrentLevel.GetElevator();
		mElevator.Unhide();
		
		// Sposto la camera in modo che sia dentro l'ascensore
		mCamera.SetPosition(0, 6, -4);
		
//		mCurrentLevel = Level1(mInputManager, mSoundManager);
//		mCurrentLevel.Init(mLights, mElevator, mOpenglTranslationOffset);
				
		mCurrentLevel = Level2(mInputManager, mSoundManager);
		mCurrentLevel.Init(mLights, mElevator, mOpenglTranslationOffset);
		
		mCurrentLevelNumber = 1;
		
		mFadingIn = false;
		mFadingOut = false;
	}
	else 
	{
	
		// The current level takes as parameter the input manager, which is shared among every level
		mCurrentLevel = Level0(mInputManager, mSoundManager, mLights);
		mCurrentLevelNumber = 0;
		
		mElevator = mCurrentLevel.GetElevator();
		
		//mLevel1 = Level0(mInputManager, mSoundManager);

		mFadeToBlackAlpha = 1;
		mFadingIn = true;
		mFadingOut = false;
	}
	
	// Creating the position circle object, used for the teleportation feature
	mPositionCircleRadius = 1.0;
//	var positionCircleMesh = CVmNewMesh(VRP_CIRCLE, 30, mPositionCircleRadius, 1);  
//	var positionCircleMesh = CVmNewMesh("circleProva.AAM");  
	var positionCircleMesh = CVmNewMesh(VRP_CYLINDER, 30, mPositionCircleRadius, 0.2, 1);  
	positionCircleMesh.Normalize(4);
	mPositionCircleObj = CVmObj(positionCircleMesh);
	
	// Booleans used for the teleportation feature
	mIsPositionValid = false;
	mIsWall = false;
	mIsPressingSecondaryButton = false;
	
	// Shaders used to render the dashed line and the circle for the teleportation feature
	mDashedLineShader = CVmShaderProgram("dashedLineShader.glsl");
	mPositionCircleShader = CVmShaderProgram("positionCircleShader.glsl");
	
	// Offset used for the teleportation feature rendering
	mDashedLinesOffset = 0;
}

/*
 * Render function. It delegates the job to the current level or the menu manager
 */
function GameManager::Render()
{
	switch (mGameStatus) 
	{
		case STATUS_MENU:
	//		mMenu.Render();
			break;
		case STATUS_INGAME:
				
			SceneBegin(mCamera);
			
			XVRRendering();
			
			if(VR_ON){		
				var cameraMatrix = HMD.GetCameraMatrix();	
				CameraSetMatrix(cameraMatrix);	
				glEnable(GL_LIGHT0);
				glEnable(GL_LIGHT1);
				glEnable(GL_LIGHT2);
				glLight(GL_LIGHT0, GL_POSITION, [mLights[0].GetPosition().x, mLights[0].GetPosition().y, mLights[0].GetPosition().z, 1.0]); 
			 	glLight(GL_LIGHT1, GL_POSITION, [mLights[1].GetPosition().x, mLights[1].GetPosition().y, mLights[1].GetPosition().z, 1.0]); 
			 	glLight(GL_LIGHT2, GL_POSITION, [mLights[2].GetPosition().x, mLights[2].GetPosition().y, mLights[2].GetPosition().z, 1.0]); 
			 			
				HMD.SceneBegin();
					HMD.frame_left();
						XVRRendering();
					HMD.frame_right();
						XVRRendering();
				HMD.SceneEnd();
			}	
				
				/*
				 * ******************************** HERE GOES THE HTC VIVE RENDERING PART ***************************************
				 * 
				 * Something like:
				 * 
				 * HMD.SceneBegin();
				 * 
				 * *** here goes the positioning of lights. The ideal thing would be to create a method for each level that returns info
				 *     about the positions and properties of the lights (diffuse and ambient colors, and anything that might be useful),
				 * 	   so that the properties can be set using opengl commands.
				 *     the code might be something like:
				 * 	   
				 *     var lights = mCurrentLevel.GetLights();
				 * 
				 * 	   // Need to pass as position a vector of 4 components, with the last one 1.0 to indicate that it's a positional light

				 * 
				 * 	   // Mini-problem: how to make this iterative? We have to use a constant like GL_LIGHT0, so making iterative might not be possible.
				 * 	   // Also, might need to add mOpenglTranslationOffset to the positions, in order to take into account transformations; need to check.
				 * *** 
				 * 
				 * HMD.RenderLeftFrame();
				 * 
				 * *** here goes the same exact rendering code as for XVR (the one above) ***
				 * 
				 * HMD.RenderRightFrame();
				 * 
				 * *** here goes the same exact rendering code as for XVR (the one above) ***
				 * 
				 * HMD.SceneEnd();
				 */
				 
			
			SceneEnd();
			break;
		default:
			break;
	}
}

function GameManager::XVRRendering(){
	/* This is very important: in order to move around with the HTC Vive using the teleportation, we need to translate everything when rendering by
	 * the amount computed when the teleportation goes through. This means that the whole world will shift by this amount, BUT the XVR objects
	 * won't move, meaning that their position taken with their GetPosition() methods will stay the same even after the translation.
	 * So in the levels it's important to take this into account when making computations based on the player position. For example,
	 * if I want to know where the player actually is, I need to to something like "mCamera.GetCamera() - mOpenglTranslationOffset": this
	 * will be the REAL position of the player.
	 * By letting the GameManager handle this, the levels stay pretty much the same, except for computing positions of some things (camera 
	 * and lights), as I just mentioned */
	glTranslate(mOpenglTranslationOffset);

	mCurrentLevel.Render();

	// Here we render the positional circle, if the user is pressing the button. Since it's common for every level, it's better to do it here
	if(mIsPressingSecondaryButton)
	{
		// I also render a line from the controller to the position circle.
		// Note: need to modify the code so that if the Vive is active the line starts from the controller, not the camera
		var raycastOrigin = mCamera.GetPosition() - mOpenglTranslationOffset - [-0.1, 0.1, 0.0];
		var raycastEnd = mPositionCircleObj.GetPosition();
												
		var color;
		
		// If the position is valid the ray is blue, otherwise it's red
		if(mIsPositionValid)
			color = [0, 0, 1];
		else
			color = [1, 0, 0];
		
		// Rendering of the ray
		mDashedLineShader.Start();
			// Parameters for the ray's shader
			mDashedLineShader.SetParameter("sourcePosition", raycastOrigin);
			mDashedLineShader.SetParameter("lineLength", Modulus(raycastEnd - raycastOrigin));
			mDashedLineShader.SetParameter("color", color);
			mDashedLineShader.SetParameter("ticksLength", 0.17);
			mDashedLineShader.SetParameter("offset", mDashedLinesOffset);
			
			glLineWidth(2.5); 
			
			// I draw the ray as a simple opengl line
			glBegin(GL_LINES);
				glVertex(raycastOrigin);
				glVertex(raycastEnd);		
			glEnd();
		mDashedLineShader.Stop();
								
		// If the position is on a wall, I also draw the position circle
		if(mIsWall)
		{
			mPositionCircleShader.Start();
				// Parameters for the circle's shader
				mPositionCircleShader.SetParameter("color", color);
				mPositionCircleShader.SetParameter("radius", mPositionCircleRadius * 2.0);
				mPositionCircleShader.SetParameter("innerCircleTickness", 0.06);
				mPositionCircleShader.SetParameter("outerCircleTickness", 0.16);
				mPositionCircleShader.SetParameter("offset", mDashedLinesOffset * 100.0); // The offset needs to be higher, otherwise the lines move slowly
				mPositionCircleShader.SetParameter("ticksNumber", 15.0);

//				if(frameNum == 51)
//					frameNum = 0;
					
				mPositionCircleObj.Draw();
//				mPositionCircleObj.Draw(VR_FRAMENUMBER,frameNum++,0);
			mPositionCircleShader.Stop();
		}
		
		// I increment the offset used for the rendering of the ray and the circle, so that in the next frame the ticks position will shift
		mDashedLinesOffset += 0.01;
	}
	// If we don't have to draw the ray, I reset its offset, so that it doesn't increment too much in the course of the game
	else
		mDashedLinesOffset = 0;
	
	
	// Drawing the crosshair and everything that is 2D after I'm finished with the 3D stuff
	DrawCrosshair();
	
	if(mFadingIn)
	{
		FadeToBlackScreen(true);
		mFadingIn = mFadeToBlackAlpha > 0.0;
	}
	else if(mFadingOut)
	{
		FadeToBlackScreen(false);
		mFadingOut = mFadeToBlackAlpha < 1.0;
	}
}

/*
 * Update logic function. It delegates the job to the current level or the menu manager
 */
function GameManager::UpdateLogic(dt)
{
	/*
	 * ******************************** HERE GOES THE HTC VIVE PART TO UPDATE THE CAMERA'S POSITION ***************************************
	 * 
	 * Before starting updating the logic, we need to update the camera's position with the matrix of the HMD given by OpenVR, so we have the correct
	 * position in XVR.
	 * Same thing goes for the controllers: here their position need to be updated
	 */
	var viveTriggerPressed = false;	//can't define vars inside switch statement
	var controllerMatrix;
	 
	switch (mGameStatus) {
		
		case STATUS_MENU:
		
			break;
		case STATUS_INGAME:	

			mCurrentLevel.UpdateLogic(dt);
			if(VR_ON){
				if(HMD.IsTriggerPressed(1) == 1){
					controllerMatrix = HMD.GetControllerRotationMatrix(1);
					viveTriggerPressed = true;
				}					
			}
			
			// Checking the user is pressing the button to teleport
			if(mInputManager.IsPressingSecondaryButton() || viveTriggerPressed)
			{				
				// I get the camera's position- minus the offset so we get the actual position of the player in the world
				// NOTE: if the Vive is active, this shouldn't be the camera's, but the controller's position. Need to modify the code
				var cameraPosition;
				if(!VR_ON)
					cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
				else
					cameraPosition = [controllerMatrix[12] - mOpenglTranslationOffset.x, controllerMatrix[13] - mOpenglTranslationOffset.y, controllerMatrix[14] - mOpenglTranslationOffset.z];
				
				// Computing the ray that goes to infinity: I'm going to check were it collides
				var raycastOrigin = cameraPosition;
				var raycastEnd;
				if(!VR_ON)
					raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
				else
					raycastEnd = raycastOrigin + [-controllerMatrix[8], -controllerMatrix[9], -controllerMatrix[10]] * mCamera.GetZFar();
				
				var contactPoint;
				var normal;
				
				// I'm assuming the intersection will be in a wall
				mIsWall = true;
				
				// I ask the level to check where the ray intersects and if that position is valid. I'm passing the reference to some objects
				// so that the level will put in there the point of interception, the normal of the object and whether it's a wall or not
				mIsPositionValid = mCurrentLevel.IsPointedPositionValid(raycastOrigin, raycastEnd, &contactPoint, &normal, &mIsWall);
				
				
				if(contactPoint != Void)
				{
					// If the position is valid I reset the circle's rotation, in case it was previously rotated (I'm doing this since I know that valid
					// positions are for floors, and the circle as default is parallel to the floor
					if(mIsPositionValid)
						mPositionCircleObj.SetRotation(0, 0, 1, 0);
					// If it's not valid, I check the normal of the contact point in order to rotate the circle accordingly
					else
					{
						if(abs(normal.x) == 1)
						{
							mPositionCircleObj.SetRotation(90, 0, 0, 1);
						}
						else if(abs(normal.z) == 1)
						{
							mPositionCircleObj.SetRotation(90, 1, 0, 0);
						}
						else
							mPositionCircleObj.SetRotation(0, 0, 1, 0);
					}
					
					// Finally I set the position of the circle, subtracting the direction vector so that the circle is not really on the plane but a bit
					// closer to the user (to avoid Z fighting with the intersected plane)
					mPositionCircleObj.SetPosition(contactPoint - mCamera.GetDirection());
				}
									
				// I state that the user is pressing the secondary button
				mIsPressingSecondaryButton = true;
			}
			// If the user isn't pressing the button...
			else
			{
				// If the user WAS pressing the button, now he's not anymore
				if(mIsPressingSecondaryButton)
				{
					// If the last position of the circle was valid, I update the opengl offset
					if(mIsPositionValid)
					{
						// The new offset is the difference between the player's position and the new position of the circle;
						// I'm only udpating the x and y values since the y should stay the same
						var cameraPosition = mCamera.GetPosition();
						mOpenglTranslationOffset.x = cameraPosition.x  - mPositionCircleObj.GetPosition().x;
						mOpenglTranslationOffset.z = cameraPosition.z  - mPositionCircleObj.GetPosition().z;
						
						// I notify the current level that the offset has changed
						mCurrentLevel.SetOpenglTransformOffset(mOpenglTranslationOffset);
					}
					
					mIsPressingSecondaryButton = false;
				}
			}
			
			if(mCurrentLevel.IsLevelCompleted())
			{
				mCurrentLevelNumber++;
				
				switch(mCurrentLevelNumber)
				{
					case 1:
					{
						mCurrentLevel = mLevel1;
						mCurrentLevel.Init(mLights, mElevator, mOpenglTranslationOffset);
						break;
					}
				}
			}
			
			break;
			
		default:
			break;
	}
}

function GameManager::DrawCrosshair()
{
	// This array will contain at position 2 the width of the viewport, and at 3 its height
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable(GL_LIGHTING);
    
    glLineWidth(2.0);
    
    
    // Horizontal line
    glBegin(GL_LINES);
    	glColor(0.0, 0.0, 0.0, 1.0);
        
        glVertex(viewport[2] / 2 - 7, viewport[3] / 2);
        glVertex(viewport[2] / 2 + 7, viewport[3] / 2);
    glEnd();
        
    // Vertical line
    glBegin(GL_LINES);
        glVertex(viewport[2] / 2, viewport[3] / 2 + 7);
        glVertex(viewport[2] / 2, viewport[3] / 2 - 7);
    glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}


/*
 * 
 */
function GameManager::FadeToBlackScreen(fadeIn)
{
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);

	if(fadeIn)
		mFadeToBlackAlpha -= 0.006;
	else
		mFadeToBlackAlpha += 0.004;
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[4], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable( GL_LIGHTING );
    
    glBegin(GL_QUADS);
	    glColor(0.0, 0.0, 0.0, mFadeToBlackAlpha);
	    glVertex(-1.0, -1.0);
	    glVertex(1.0, -1.0);
	    glVertex(1.0, 1.0);
	    glVertex(-1.0, 1.0);
	glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}