
#define STATUS_MENU     0
#define STATUS_INGAME   1

global var DEBUG_MODE = true;
global var openglTranslationOffset = [0, 0, 0];

#include "Utils.s3d"
#include "Level0.s3d"
#include "Level1.s3d"
#include "InputManager.s3d"
//#include "Utils.s3d"
//#include <Room.s3d>
//#include <EventTrigger.s3d>
//#include <Text.s3d>
//#include <Animator.s3d>
//#include <SoundManager.s3d>
//#include <Elevator.s3d>
//#include <Utils.s3d>

/*
 * This class manages the whole game and the transition between levels
 */
class GameManager
{
	var mGameStatus;
	var mGameStarted;
	var mGameReady;
	var mCurrentLevel;
	var mCurrentLevelNumber;
	var mMenu;
	
	var mElevator;
	
	var mCamera;
	var mFadeToBlackAlpha;
	
	var mInputManager;
	var mSoundManager;
	
	var mFadingIn;
	var mFadingOut;
	
	var mLights;
	
	var mLevel1;
	
	var mPositionCircleObj;
	var mIsPositionValid;
	var mIsWall;
	var mIsClickingSecondaryButton;

	Render();
	UpdateLogic(dt);
	DrawCrosshair();
	FadeToBlackScreen(fadeIn);
};


function GameManager::GameManager()
{
	mGameStatus = STATUS_INGAME;
		
	mGameStarted = false;
	mGameReady = false;
	
	
	mCamera = CameraGetCurrent();
	
	mInputManager = InputManager();
	mInputManager.SetActiveCamera(mCamera);
	
	mSoundManager = SoundManager();
	mSoundManager.SetMusic("sounds/Nexus - Tranquility.mp3", 0.5, true);
	mSoundManager.PlayMusic();
	
	mLights = {};
	
	
	var light0 = CVmLight();
	light0.SetPosition([-10.0, 10.0, 10.0]);
	light0.SetDiffuse(1, 1, 1);
	light0.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light0.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light0.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light0.Disable();	
	
	var light1 = CVmLight();
	light1.SetPosition([-10.0, 10.0, 10.0]);
	light1.SetDiffuse(1, 1, 1);
	light1.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light1.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light1.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light1.Disable();	
	
	var light2 = CVmLight();
	light2.SetPosition([-10.0, 10.0, 10.0]);
	light2.SetDiffuse(1, 1, 1);
	light2.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light2.SetParameter(GL_LINEAR_ATTENUATION, 0.9000);
	light2.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light2.Disable();
	
	aadd(mLights, light0);
	aadd(mLights, light1);
	aadd(mLights, light2);
	
	if(DEBUG_MODE)
	{
		// The current level takes as parameter the input manager, which is shared among every level
		mCurrentLevel = Level0(mInputManager, mSoundManager, mLights);
		mCurrentLevelNumber = 0;
		
		mElevator = mCurrentLevel.GetElevator();
		mElevator.Unhide();
		
		// Sposto la camera in modo che sia dentro l'ascensore
		mCamera.SetPosition(0, 6, -4);
		
		mCurrentLevel = Level1(mInputManager, mSoundManager);
		mCurrentLevel.Init(mLights, mElevator);
		
		mFadingIn = false;
		mFadingOut = false;
	}
	else 
	{
	
		// The current level takes as parameter the input manager, which is shared among every level
		mCurrentLevel = Level0(mInputManager, mSoundManager, mLights);
		mCurrentLevelNumber = 0;
		
		mElevator = mCurrentLevel.GetElevator();
		
		mLevel1 = Level1(mInputManager, mSoundManager);

		mFadeToBlackAlpha = 1;
		mFadingIn = true;
		mFadingOut = false;
	}
	
	
	
	var positionCircleMesh = CVmNewMesh(VRP_CIRCLE, 30, 1, 1);  
	mPositionCircleObj = CVmObj(positionCircleMesh);
	
	mIsPositionValid = false;
	mIsWall = false;
	mIsClickingSecondaryButton = false;
}


/*
 * Render function. It delegates the job to the current level or the menu manager
 */
function GameManager::Render()
{
	switch (mGameStatus) 
	{
		case STATUS_MENU:
	//		mMenu.Render();
			break;
		case STATUS_INGAME:
			SceneBegin(mCamera);
				glTranslate(openglTranslationOffset);
	
				mCurrentLevel.Render();
	
				if(mIsClickingSecondaryButton)
				{
					var raycastOrigin = mCamera.GetPosition() - openglTranslationOffset - [-0.1, 0.1, 0.0];
					var raycastEnd = mPositionCircleObj.GetPosition();
					
					
					glLineWidth(2.5); 
					
					glDisable(GL_LIGHTING);
					
					if(mIsPositionValid)
						glColor(0.0, 0.0, 1.0, 1.0);
					else
						glColor(1.0, 0.0, 0.0, 1.0);
					
					glBegin(GL_LINES);
						glVertex(raycastOrigin);
						glVertex(raycastEnd);
					glEnd();
					
					glEnable(GL_LIGHTING);
					
					if(mIsWall)
						mPositionCircleObj.Draw();
				}
				
				// Drawing the crosshair and everything that is 2D after I'm finished with the 3D stuff
				DrawCrosshair();
				
				if(mFadingIn)
				{
					FadeToBlackScreen(true);
					mFadingIn = mFadeToBlackAlpha > 0.0;
				}
				else if(mFadingOut)
				{
					FadeToBlackScreen(false);
					mFadingOut = mFadeToBlackAlpha < 1.0;
				}
			
			SceneEnd();
			break;
		default:
			break;
	}
}

/*
 * Update logic function. It delegates the job to the current level or the menu manager
 */
function GameManager::UpdateLogic(dt)
{
	
	switch (mGameStatus) {
		
		case STATUS_MENU:
		
			break;
		case STATUS_INGAME:	

			mCurrentLevel.UpdateLogic(dt);
			
			if(mInputManager.IsPressingSecondaryButton())
			{				
				var cameraPosition = mCamera.GetPosition() - openglTranslationOffset;
				
				var raycastOrigin = cameraPosition;
				var raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
				
				var contactPoint;
				var normal;
				
				mIsWall = true;
				
				mIsPositionValid = mCurrentLevel.IsPointedPositionValid(raycastOrigin, raycastEnd, &contactPoint, &normal, &mIsWall);
				
				
				if(mIsPositionValid)
					mPositionCircleObj.SetRotation(0, 0, 1, 0);
				else
				{
					if(abs(normal.x) == 1)
					{
						mPositionCircleObj.SetRotation(90, 0, 0, 1);
					}
					else if(abs(normal.z) == 1)
					{
						mPositionCircleObj.SetRotation(90, 1, 0, 0);
					}
					else
						mPositionCircleObj.SetRotation(0, 0, 1, 0);
				}	
				
//				print({"contactPoint", "add"}, {contactPoint, contactPoint - mCamera.GetDirection()});
					
				if(contactPoint != Void)
					mPositionCircleObj.SetPosition(contactPoint - mCamera.GetDirection());
				
				mIsClickingSecondaryButton = true;
			}
			else
			{
				if(mIsClickingSecondaryButton)
				{
					if(mIsPositionValid)
					{
						var cameraPosition = mCamera.GetPosition() - openglTranslationOffset;
						openglTranslationOffset.x = cameraPosition.x +  openglTranslationOffset.x - mPositionCircleObj.GetPosition().x;
						openglTranslationOffset.z = cameraPosition.z  + openglTranslationOffset.z - mPositionCircleObj.GetPosition().z;
					}
					
					mIsClickingSecondaryButton = false;
				}
			}
			
			if(mCurrentLevel.IsLevelCompleted())
			{
				mCurrentLevel = mLevel1;
				mCurrentLevel.Init(mLights, mElevator);
			}
			
			break;
			
		default:
			break;
	}
}

function GameManager::DrawCrosshair()
{
	// This array will contain at position 2 the width of the viewport, and at 3 its height
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable(GL_LIGHTING);
    
    glLineWidth(2.0);
    
    
    // Horizontal line
    glBegin(GL_LINES);
    	glColor(0.0, 0.0, 0.0, 1.0);
        
        glVertex(viewport[2] / 2 - 7, viewport[3] / 2);
        glVertex(viewport[2] / 2 + 7, viewport[3] / 2);
    glEnd();
        
    // Vertical line
    glBegin(GL_LINES);
        glVertex(viewport[2] / 2, viewport[3] / 2 + 7);
        glVertex(viewport[2] / 2, viewport[3] / 2 - 7);
    glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}


/*
 * 
 */
function GameManager::FadeToBlackScreen(fadeIn)
{
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);

	if(fadeIn)
		mFadeToBlackAlpha -= 0.006;
	else
		mFadeToBlackAlpha += 0.004;
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[4], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable( GL_LIGHTING );
    
    glBegin(GL_QUADS);
	    glColor(0.0, 0.0, 0.0, mFadeToBlackAlpha);
	    glVertex(-1.0, -1.0);
	    glVertex(1.0, -1.0);
	    glVertex(1.0, 1.0);
	    glVertex(-1.0, 1.0);
	glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}