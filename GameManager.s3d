global var DEBUG_MODE = true;
global var MUSIC_ON = false;
global var MUSICFX_ON = true;
global var SCALE_FACTOR = 0.2;

#define STATUS_MENU     0
#define STATUS_INGAME   1
#define STATUS_ENDGAME   2

#define USE_TOON_SHADER 1


#include "Utils.s3d"
#include "Text.s3d"
#include "VirtualKeyboard.s3d"
#include "Numpad.s3d"
#include "ViveController.s3d"
#include "DrawingsConnector.s3d"
#include "GlassBox.s3d"
#include "TilesPath.s3d"
#include "LevelMenuSelector.s3d"
#include "PreviewFrame.s3d"
#include "RandomMeshes.s3d"
#include "Bullet.s3d"
#include "Target.s3d"
#include "Gun.s3d"
#include "ButtonsWall.s3d"
#include "MarcelloUtils.s3d"
#include "Level0.s3d"
#include "LevelMenu.s3d"
#include "Level1.s3d"
#include "Level2.s3d"
#include "Level3.s3d"
#include "Level4.s3d"
#include "Level5.s3d"
#include "Level6.s3d"
#include "InputManager.s3d"


/*
 * This class manages the whole game and the transition between levels.
 * It also manages the rendering and the integration of the HTC Vive, so that levels don't need to be aware of it (too much).
 * 
 * NOTE: The controller's CVmObj should be created in the GameManager but passed to each level's class. The level should handle rendering them, but
 * NOT updating their position, sinceit's better that the GameManger does that, so that the levels have no idea of the HTC Vive being used.
 * The ideal would be to update their position in the UpdateLogic of the GameManager (at start) and then setting the new position to the level's controller
 * (using a method like "mCurrentLevel.SetControllerPosition(pos)".
 */
class GameManager
{
	// This variable has access to the DLL functions to control the Vive
	var mHMD;
	var mJoystick;
	
	// Boolean, set to true if the Vive was detected at start; false otherwise
	var mIsVRon;
	
	var mGameStatus;
	var mGameStarted;
	var mGameReady;
	var mCurrentLevel;
	var mCurrentLevelNumber;
	var mMenu;
	
	var mElevator;
	
	var mCamera;
	var mAnimator;
	
	var mInputManager;
	var mSoundManager;
	
	var mStarting;
	var mEnding;
	var mEndingLevelMenu;
	var mEndTimer;
	var mTimeToEnd;
	
	// If the screen is fading to black, this float contains the alpha of the fading (1 == totally black, 0 == totally invisible)
	var mFadeToBlackAlpha;
	var mFadeAnimationID;
	
	var mLights;
	
	var mLevels;
	var mLevel0;
	
	/* In order to use the teleporting feature along with the HTC Vive, when a user teleports to a destination we need to change the camera's position 
	 * in opengl fashon, meaning NOT using the SetPosition() of XVR. This is because the HTC Vive is powered by OpenVR, which works in its own way, and 
	 * it's not related to XVR classes. So, to move the Vive camera (and so also the XVR one) we need to move the camera as if we were using only opengl,
	 * meaning that we have to use glTransform(). We basically translate the whole scene at every frame, according to this offset.
	 * In order for this to NOT affect XVR objects, we need to be careful. For instance, if I need to get the position of the camera I need to 
	 * subtracts the vector mOpenglTranslationOffset to get the "actual" position of the camera in the world, since using glTransform doesn't change
	 * the camera position in the XVR object. Same goes for the lights.
	 * So, this vector is very important in the whole game, and everytime it gets changed (i.e. when the user teleports), the current level
     * needs to know the updated value, otherwise the level's logic will be updated using wrong positions */
	var mOpenglTranslationOffset;
	
	// ID for the animations used to teleport the player from one position to another
	var mOpenglTranslationOffsetAnimationID;
	
	// Threshold used to determine whether to use the moving transition when teleporting or the fade-to-black transition
	var mTeleportDistanceThreshold;
	
	// Boolean that is true when the user is teleporting with the fade-to-black transition
	var mIsTeleporting;
	
	// This object is the circle that appears when the user wants to teleport to a destination
	var mPositionCircleObj;
	
	// Radius and height of the position circle
	var mPositionCircleRadius;
	var mPositionCircleHeight;
		
	// Shader used to render the position circle
	var mPositionCircleShader;
	
	// Objects that represent the play area rectangle (that is displayed as a box to create a cool shading effect). The play area is defined by the Vive's lighthouse
	// system and it's basically the area that the player can move in safely
	var mPlayAreaRec;
	var mPlayAreaTeleportBox;
	var mPlayAreaTeleportBoxHeight;
	var mPlayAreaTeleportBoxShader;
	
	var mPlayAreaBox;
	var mPlayAreaBoxAlpha;
	var mPlayAreaBoxHeight;
	var mPlayAreaBoxShader;
	var mPlayAreaBoxAlphaIncrement;
	var mIsPlayAreaPlaneVisible;
	
	// Boolean that indicates if the current position of the circle is a valid position for teleportation
	var mIsPositionValid;
	
	// Shader used to create the dashed lines when the player uses that teleportation feature
	var mDashedLineShader;
	
	// Offset used by the "dashed line shader" to create the illusion that the line segments are moving
	var mDashedLinesOffset;
	
	// If the current position of the circle isn't valid, this boolean indicates if it's placed on a wall; in that case the circle will be shown anyway, 
	// otherwise it will be hidden for rendering simplicity (meaning that it would be hard to render correctly the circle to a surface that is not planar like a wall)
	var mIsWall;
	
	// This boolean indicates whether the user is currently pressing the secondary button for teleportation
	var mIsPressingSecondaryButton;
	
	// Index of the controller being used for the teleportation
	var mControllerBeingUsedIndex;
	
	var mLevelsPreloading;
	

	// Private methods
	XVRRendering(eye);
	DrawCrosshair();
	FadeToBlackScreen();
	
	// Public methods
	Render();
	UpdateLogic(dt);
};


function GameManager::GameManager(HMD)
{
	mHMD = HMD;
	mJoystick = CVmJoystick();
	
	mIsVRon = mHMD.IsVRactive() == 1;
//	mIsVRon = false;
		
	mGameStatus = STATUS_INGAME;
		
	mGameStarted = false;
	mGameReady = false;
	
	mCamera = CameraGetCurrent();
	mAnimator = Animator();
	
	mInputManager = InputManager(mIsVRon, mHMD, mJoystick);
	mInputManager.SetActiveCamera(mCamera);
	
	mSoundManager = SoundManager();
	mSoundManager.SetMusic("sounds/Nexus - Tranquility.mp3", 0.95, false, 7.0);	
	mSoundManager.AddSound("sounds/Mi1.wav", 0);
	mSoundManager.AddSound("sounds/Fa#2.wav", 1);
	mSoundManager.AddSound("sounds/Sol3.wav", 2);
	mSoundManager.AddSound("sounds/La4.wav", 3);
	mSoundManager.AddSound("sounds/Si5.wav", 4);
	mSoundManager.AddSound("sounds/Do#6.wav", 5);
	mSoundManager.AddSound("sounds/Mi7.wav", 6);
	mSoundManager.AddSound("sounds/numpadBeep.wav", "numpadBeep");
	mSoundManager.AddSound("sounds/numpadCorrectCode.wav", "numpadCorrectCode");
	mSoundManager.AddSound("sounds/numpadWrongCode.wav", "numpadWrongCode");
	
	if(MUSIC_ON)
		mSoundManager.PlayMusic();
	
	mLights = {};
	
	
	var light0 = CVmLight();
	light0.SetPosition([-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR]);
	light0.SetDiffuse(1, 1, 1);
	light0.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light0.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light0.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light0.Disable();	
	
	var light1 = CVmLight();
	light1.SetPosition([-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR]);
	light1.SetDiffuse(1, 1, 1);
	light1.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light1.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light1.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light1.Disable();	
	
	var light2 = CVmLight();
	light2.SetPosition([-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR]);
	light2.SetDiffuse(1, 1, 1);
	light2.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light2.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light2.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light2.Disable();
	
	aadd(mLights, light0);
	aadd(mLights, light1);
	aadd(mLights, light2);
	
	mOpenglTranslationOffset = [0, 0, 0]; 
	mOpenglTranslationOffsetAnimationID = 1;
	
	mTimeToEnd = 7000;
	mStarting = true;
	mEnding = false;
	mEndingLevelMenu = false;
	
	mLevels = {};
	mLevel0 = Level0(mIsVRon, mInputManager, mSoundManager, mLights, &mOpenglTranslationOffset);	
	
	mElevator = mLevel0.GetElevator();
	mElevator.Unhide();
	
	// This creates an almost white background
	SetClearColor(0.95, 0.95, 0.95);
	
	mFadeAnimationID = 0;
	
	mLevelsPreloading = true;
	if(DEBUG_MODE)
	{
		/*** Select here which level you want to preload (-1 to preload every level)
		 * Select if you want to start from the menu or not
		 */
		var testingLevel = 6;
		var testWithMenu = false;
		
		
		mCamera.SetPosition(0, 6.0 * SCALE_FACTOR, -2.0 * SCALE_FACTOR);
		
//		mOpenglTranslationOffset.z += 20 * SCALE_FACTOR;

		var levelSelectors = {};
		if(testingLevel == 0 || testingLevel == -1)
			aadd(levelSelectors, {"Start", CVmTexture("Level0Prev.png")});
		if(testingLevel == 1 || testingLevel == -1)
			aadd(levelSelectors, {"Colors", CVmTexture("Level1Prev.png")});
		if(testingLevel == 2 || testingLevel == -1)
			aadd(levelSelectors, {"Ghost", CVmTexture("Level2Prev.png")});
		if(testingLevel == 3 || testingLevel == -1)
			aadd(levelSelectors, {"Chaos", CVmTexture("Level3Prev.png")});
		if(testingLevel == 4 || testingLevel == -1)
			aadd(levelSelectors, {"Timing", CVmTexture("Level4Prev.png")});
		if(testingLevel == 5 || testingLevel == -1)
			aadd(levelSelectors, {"Wall", CVmTexture("Level5Prev.png")});	
		if(testingLevel == 6 || testingLevel == -1)
			aadd(levelSelectors, {"War", CVmTexture("Level5Prev.png")});
		
		if(mLevelsPreloading){
			if(testingLevel == 0 || testingLevel == -1)
				aadd(mLevels, mLevel0);
			if(testingLevel == 1 || testingLevel == -1)
				aadd(mLevels, Level1(mIsVRon, mInputManager, mSoundManager));
			if(testingLevel == 2 || testingLevel == -1)
				aadd(mLevels, Level2(mIsVRon, mInputManager, mSoundManager));
			if(testingLevel == 3 || testingLevel == -1)
				aadd(mLevels, Level3(mIsVRon, mInputManager, mSoundManager));
			if(testingLevel == 4 || testingLevel == -1)
				aadd(mLevels, Level4(mIsVRon, mInputManager, mSoundManager));
			if(testingLevel == 5 || testingLevel == -1)
				aadd(mLevels, Level5(mIsVRon, mInputManager, mSoundManager));
			if(testingLevel == 6 || testingLevel == -1)
				aadd(mLevels, Level6(mIsVRon, mInputManager, mSoundManager));
		}
		
		if(testWithMenu){
			mCurrentLevel = LevelMenu(mIsVRon, mInputManager, mSoundManager, levelSelectors, mElevator);
			mCurrentLevel.Init(mLights, mElevator, &mOpenglTranslationOffset);			
			mCurrentLevelNumber = -1;		
		}	
		else{
			mCurrentLevel = mLevels[0];
			mCurrentLevel.Init(mLights, {[0.0, 1.0, 0.0], [0.0, 1.0, 0.0], [0.0, 1.0, 0.0]}, mElevator, &mOpenglTranslationOffset);				
			mCurrentLevelNumber = testingLevel;				
		}	

		mAnimator.CreateGenericTransition(mFadeAnimationID, 1.0, 0.0, 3.0);
	}
	else 
	{
		// The current level takes as parameter the input manager, which is shared among every level
		mCurrentLevelNumber = 0;
		
		var levelSelectors = {};
		aadd(levelSelectors, {"Start", CVmTexture("Level0Prev.png")});
		aadd(levelSelectors, {"Colors", CVmTexture("Level1Prev.png")});
		aadd(levelSelectors, {"Ghost", CVmTexture("Level2Prev.png")});
		aadd(levelSelectors, {"Chaos", CVmTexture("Level3Prev.png")});
		aadd(levelSelectors, {"Wall", CVmTexture("Level5Prev.png")});
		aadd(levelSelectors, {"War", CVmTexture("Level5Prev.png")});
		aadd(levelSelectors, {"Timing", CVmTexture("Level4Prev.png")});
		
		aadd(mLevels, mLevel0);
		aadd(mLevels, Level1(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level2(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level3(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level5(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level6(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level4(mIsVRon, mInputManager, mSoundManager));
		
		mCurrentLevel = LevelMenu(mIsVRon, mInputManager, mSoundManager, levelSelectors, mElevator);
		mCurrentLevel.Init(mLights, mElevator, &mOpenglTranslationOffset);

		mAnimator.CreateGenericTransition(mFadeAnimationID, 1.0, 0.0, 3.0);
	}
	
	// Creating the position circle object, used for the teleportation feature
	mPositionCircleRadius = 1.0 * SCALE_FACTOR;
	mPositionCircleHeight = 0.2 * SCALE_FACTOR;
	var positionCircleMesh = CVmNewMesh(VRP_CYLINDER, 30, mPositionCircleRadius, mPositionCircleHeight, 1);  
	positionCircleMesh.Normalize(4 * SCALE_FACTOR);
	mPositionCircleObj = CVmObj(positionCircleMesh);
	
	// Booleans used for the teleportation feature
	mIsPositionValid = false;
	mIsWall = false;
	mIsPressingSecondaryButton = false;
	
	// Initially, no controller is being used
	mControllerBeingUsedIndex = 0;
	
	// Shaders used to render the dashed line and the circle for the teleportation feature
	mDashedLineShader = CVmShaderProgram("dashedLineShader.glsl");
	mPositionCircleShader = CVmShaderProgram("positionCircleShader.glsl");
	mPlayAreaTeleportBoxShader = CVmShaderProgram("playAreaTeleportBoxShader.glsl");
	mPlayAreaBoxShader = CVmShaderProgram("playAreaBoxShader.glsl");

	
	// Offset used for the teleportation feature rendering
	mDashedLinesOffset = 0;
	
	// Getting the play area size for the Vive; if the Vive isn't on, a default size is chosen. This method returns a vector containing with and depth of the area
	mPlayAreaRec = mInputManager.GetPlayAreaSize();
	
	// Height of the play area box
	mPlayAreaTeleportBoxHeight = 4.0 * SCALE_FACTOR;
	
	// Creating the play area box
	var playAreaTeleportBoxMesh = CVmNewMesh(VRP_BOX, 1, [-mPlayAreaRec.x / 2.0, -mPlayAreaTeleportBoxHeight/2.0, -mPlayAreaRec.y / 2.0], [mPlayAreaRec.x/2.0, mPlayAreaTeleportBoxHeight/2, mPlayAreaRec.y / 2.0]);
	mPlayAreaTeleportBox = CVmObj(playAreaTeleportBoxMesh);
	
	mPlayAreaBoxHeight = 20.0 * SCALE_FACTOR;
	
	// Creating the play area plane (the green one); I rotate it so that it's parallel to the floor, and I move it up a bit to avoid z-fighting
	var playAreaBoxMesh = CVmNewMesh(VRP_BOX, 1, [-mPlayAreaRec.x / 2.0, -mPlayAreaBoxHeight / 2.0, -mPlayAreaRec.y/2.0], [mPlayAreaRec.x / 2.0, mPlayAreaBoxHeight / 2.0, mPlayAreaRec.y/2.0]);
	mPlayAreaBox = CVmObj(playAreaBoxMesh);
	mPlayAreaBox.Translate(0, mPlayAreaBoxHeight / 2.0 + 0.2 * SCALE_FACTOR, 0);
	
	// Variables for the play area box
	mPlayAreaBoxAlpha = 1.0;
	mPlayAreaBoxAlphaIncrement = 0.004;
	mIsPlayAreaPlaneVisible = false;
	
	mIsTeleporting = false;
	mTeleportDistanceThreshold = 30.0 * SCALE_FACTOR;
}

/*
 * Render function. It delegates the job to the current level or the menu manager
 */
function GameManager::Render()
{
	switch (mGameStatus) 
	{
		case STATUS_MENU:
	//		mMenu.Render();
			break;
		case STATUS_ENDGAME:
		case STATUS_INGAME:{
				
			mCurrentLevel.SetupOpenglLights();
				
				
			SceneBegin(mCamera);
			
			glEnable(GL_NORMALIZE);
			glEnable (GL_BLEND);
			glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
			
			XVRRendering(0);

			if(mIsVRon)
			{		
				mHMD.SceneBegin();
				
					mCurrentLevel.SetupOpenglLights();
					
					glEnable (GL_BLEND);
					glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);	
					
					if(mCurrentLevel.__GetName() == "LEVELMENU")				
						glClearColor(0.95, 0.95, 0.95, 1.0);
					
					mHMD.frame_left();
						XVRRendering(1);
					mHMD.frame_right();
						XVRRendering(2);
				mHMD.SceneEnd();
			}	
				
			SceneEnd();
			break;
			
			}
		default:
			break;
	}
}

function GameManager::XVRRendering(eye)
{
	// This makes the background white
//	glClearColor(0.95, 0.95, 0.95, 1.0);
	
	// The current level might change the opengl offset (for now only when it moves the camera with the elevator), so we get it before applying it below
	mOpenglTranslationOffset = mCurrentLevel.GetOpenglTransformOffset();
	
	/* This is very important: in order to move around with the HTC Vive using the teleportation, we need to translate everything when rendering by
	 * the amount computed when the teleportation goes through. This means that the whole world will shift by this amount, BUT the XVR objects
	 * won't move, meaning that their position taken with their GetPosition() methods will stay the same even after the translation.
	 * So in the levels it's important to take this into account when making computations based on the player position. For example,
	 * if I want to know where the player actually is, I need to to something like "mCamera.GetCamera() - mOpenglTranslationOffset": this
	 * will be the REAL position of the player.
	 * By letting the GameManager handle this, the levels stay pretty much the same, except for computing positions of some things (camera 
	 * and lights), as I just mentioned */
	glTranslate(mOpenglTranslationOffset);

	mCurrentLevel.Render();

	// Here we render the positional circle, if the user is pressing the button. Since it's common for every level, it's better to do it here
	if(mControllerBeingUsedIndex != 0)
	{		
		// I also render a line from the controller to the position circle.
		// Note: need to modify the code so that if the Vive is active the line starts from the controller, not the camera
		var raycastOrigin;
		
		if(mIsVRon)
			raycastOrigin = mInputManager.GetController(mControllerBeingUsedIndex).GetPosition();
		else 
			raycastOrigin = mCamera.GetPosition() - mOpenglTranslationOffset - [-0.1 * SCALE_FACTOR, 0.1 * SCALE_FACTOR, 0.0 * SCALE_FACTOR];
		
		// The endpoint is at the top of the cylinder that is the position "circle"
		var raycastEnd = mPositionCircleObj.LocalToWorld([0, mPositionCircleHeight, 0]); 
												
		var color;
		
		// If the position is valid the ray is blue, otherwise it's red
		if(mIsPositionValid)
			color = [0, 0, 1];
		else
			color = [1, 0, 0];
		
		// Rendering of the ray
		mDashedLineShader.Start();
			// Parameters for the ray's shader
			mDashedLineShader.SetParameter("sourcePosition", raycastOrigin);
			mDashedLineShader.SetParameter("lineLength", Modulus(raycastEnd - raycastOrigin));
			mDashedLineShader.SetParameter("color", color);
			mDashedLineShader.SetParameter("ticksLength", 0.17 * SCALE_FACTOR);
			mDashedLineShader.SetParameter("offset", mDashedLinesOffset);
			
			glLineWidth(2.5); 
			
			// I draw the ray as a simple opengl line
			glBegin(GL_LINES);
				glVertex(raycastOrigin);
				glVertex(raycastEnd);		
			glEnd();
		mDashedLineShader.Stop();
								
		// If the position is on a wall, I also draw the position circle
		if(mIsWall)
		{
			mPositionCircleShader.Start();
				// Parameters for the circle's shader
				mPositionCircleShader.SetParameter("color", color);
				mPositionCircleShader.SetParameter("radius", mPositionCircleRadius * 2.0);
				mPositionCircleShader.SetParameter("innerCircleTickness", 0.06 * SCALE_FACTOR);
				mPositionCircleShader.SetParameter("outerCircleTickness", 0.16 * SCALE_FACTOR);
				mPositionCircleShader.SetParameter("offset", mDashedLinesOffset * 300.0); // The offset needs to be higher, otherwise the lines move slowly
				mPositionCircleShader.SetParameter("ticksNumber", 15.0);

				mPositionCircleObj.Draw();
			mPositionCircleShader.Stop();
			
			// If the position is valid I also draw the play area box
			if(mIsPositionValid)
			{
				mPlayAreaTeleportBoxShader.Start();
					mPlayAreaTeleportBoxShader.SetParameter("color", color);
					mPlayAreaTeleportBoxShader.SetParameter("width", mPlayAreaRec.x);
					mPlayAreaTeleportBoxShader.SetParameter("depth", mPlayAreaRec.y);
					mPlayAreaTeleportBoxShader.SetParameter("height", mPlayAreaTeleportBoxHeight);
					mPlayAreaTeleportBoxShader.SetParameter("outerEdgesTickness", 0.06 * SCALE_FACTOR);
					
					// In order to render the box correctly with the shader, I have to render first the back faces and then the front faces.
					// If I only draw the front faces, some fragments will have transparency, but behind there wouldn't be anything since the back
					// faces wouldn't be drawn. By drawing them first, I can assure that the transparencies of the fragments will be consistent
					glCullFace(GL_FRONT);
					mPlayAreaTeleportBox.Draw();
					glCullFace(GL_BACK);
					mPlayAreaTeleportBox.Draw();
				mPlayAreaTeleportBoxShader.Stop();
			}
		}
		
		// I increment the offset used for the rendering of the ray and the circle, so that in the next frame the ticks position will shift
		mDashedLinesOffset += 0.01 * SCALE_FACTOR;
	}
	// If we don't have to draw the ray, I reset its offset, so that it doesn't increment too much in the course of the game
	else
		mDashedLinesOffset = 0;

	// If the green play area plane is visible (i.e. the user is pressing the grip buttons), I need to render it too
	if(mIsPlayAreaPlaneVisible)
	{
		// Since the plane has to be always centered in the origin, I translate back with the opengl offset before rendering. By doing this I assure that
		// the plane always "follows" the player when he teleports, uses the elevator or stuff like that
		glTranslate(-mOpenglTranslationOffset);
		
		// I render it with its shader
		mPlayAreaBoxShader.Start();
			mPlayAreaBoxShader.SetParameter("primaryColor", [0.0, 1.0, 0.0]);
			mPlayAreaBoxShader.SetParameter("secondaryColor", [1.0, 0.0, 0.0]);
			mPlayAreaBoxShader.SetParameter("colorAlpha", mPlayAreaBoxAlpha);
			mPlayAreaBoxShader.SetParameter("width", mPlayAreaRec.x);
			mPlayAreaBoxShader.SetParameter("height", mPlayAreaBoxHeight);
			mPlayAreaBoxShader.SetParameter("depth", mPlayAreaRec.y);
			mPlayAreaBoxShader.SetParameter("outerEdgesTickness", 0.06 * SCALE_FACTOR);
			mPlayAreaBoxShader.SetParameter("playerPosition", mCamera.GetPosition());
			mPlayAreaBoxShader.SetParameter("modelMatrix", mPlayAreaBox.GetModelMatrix());
			mPlayAreaBoxShader.SetParameter("scaleFactor", SCALE_FACTOR);
			
			// To create the alpha animation of the plane I increment its alpha value; if it reaches the threshold bounds I invert the sign of the increment
			if(mPlayAreaBoxAlpha >= 0.5 && mPlayAreaBoxAlphaIncrement > 0 || mPlayAreaBoxAlpha <= 0.1 && mPlayAreaBoxAlphaIncrement < 0)
				mPlayAreaBoxAlphaIncrement = -mPlayAreaBoxAlphaIncrement;
				
			mPlayAreaBoxAlpha += mPlayAreaBoxAlphaIncrement;
			
			glCullFace(GL_FRONT);
			mPlayAreaBox.Draw();	
			glCullFace(GL_BACK);
			mPlayAreaBox.Draw();	
		mPlayAreaBoxShader.Stop();
	}
		
	// Drawing the crosshair and everything that is 2D after I'm finished with the 3D stuff, but only if the VR isn't on
	if(!mIsVRon)
		DrawCrosshair();
		
	mCurrentLevel.DrawHUD(eye);
		
	// If there is a fade transition going on or the level is ending I fade to black the screen (I check if the level is ending so that when it is
	// and the animation of fading to black is over, the screen keeps being black)
	if(mAnimator.HaveTransition(mFadeAnimationID, 6) || mEnding)
		FadeToBlackScreen();
}

/*
 * Update logic function. It delegates the job to the current level or the menu manager
 */
function GameManager::UpdateLogic(dt)
{	
 	switch (mGameStatus) {
		
		case STATUS_MENU:
		
			break;
		case STATUS_ENDGAME:
			// If the game is ending and has passed enough time, I quit the application. The problem is that the Quit() function doesn't work.
			// Note that I keep updating the current level's logic and I render it, because in the meantime the screen is fading to black
//			if(GetTime() - mEndTimer > mTimeToEnd)
//				Quit();
		case STATUS_INGAME:	
		{
			// The first thing we have to do is to update the logic of the current level
			mCurrentLevel.UpdateLogic(dt);
			
			var usingController1 = mInputManager.IsPressingSecondaryButton(1);
			var usingController2 = mInputManager.IsPressingSecondaryButton(2);
			
			
			var firstTimeUsingController = (usingController1 || usingController2) && mControllerBeingUsedIndex == 0;
			var wasUsingController1 = (usingController1 && mControllerBeingUsedIndex == 1);
			var wasUsingController2 = (usingController2 && mControllerBeingUsedIndex == 2);
			
			// Checking the user is pressing the button to teleport
			if(firstTimeUsingController || wasUsingController1 || wasUsingController2)
			{				
				if(firstTimeUsingController)
					mControllerBeingUsedIndex = usingController1 ? 1 : 2;
				
				// I get the camera's position- minus the offset so we get the actual position of the player in the world
				// NOTE: if the Vive is active, this shouldn't be the camera's, but the controller's position. Need to modify the code
				var raycastOrigin;
				var raycastEnd;
				
				// Computing the ray that goes to infinity: I'm going to check were it collides
				if(mIsVRon)
				{
					var controller = mInputManager.GetController(mControllerBeingUsedIndex);
					raycastOrigin = controller.GetPosition();
					raycastEnd = raycastOrigin + controller.GetDirection() * mCamera.GetZFar();
				}
				else
				{
					raycastOrigin = mCamera.GetPosition() - mOpenglTranslationOffset;
					raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
				}
					
				
				var contactPoint;
				var normal;
				
				// I'm assuming the intersection will be in a wall
				mIsWall = true;
				
				// I ask the level to check where the ray intersects and if that position is valid. I'm passing the reference to some objects
				// so that the level will put in there the point of interception, the normal of the object and whether it's a wall or not
				mIsPositionValid = mCurrentLevel.IsPointedPositionValid(raycastOrigin, raycastEnd, &contactPoint, &normal, &mIsWall);
				
				
				if(contactPoint != Void)
				{
					// If the position is valid I reset the circle's rotation, in case it was previously rotated (I'm doing this since I know that valid
					// positions are for floors, and the circle as default is parallel to the floor
					if(mIsPositionValid)
						mPositionCircleObj.SetRotation(0, 0, 1, 0);
					// If it's not valid, I check the normal of the contact point in order to rotate the circle accordingly
					else
					{
						if(abs(normal.x) == 1)
							mPositionCircleObj.SetRotation(90, 0, 0, 1);
						else if(abs(normal.z) == 1)
							mPositionCircleObj.SetRotation(90, 1, 0, 0);
						else
							mPositionCircleObj.SetRotation(0, 0, 1, 0);
					}
					
					// Finally I set the position of the circle, subtracting the direction vector so that the circle is not really on the plane but a bit
					// closer to the user (to avoid Z fighting with the intersected plane)
					mPositionCircleObj.SetPosition(contactPoint - mCamera.GetDirection() * SCALE_FACTOR);
					
					// I also position the play area box in that point, lifting it a bit so that it's completely above the ground (remember, the box
					// has the origin in its center). I then translate the box, moving it so that it shows where the player is in the world with respect
					// to the play area; where the player is can be seen directly by looking at the position of the camera
					mPlayAreaTeleportBox.SetPosition(contactPoint + [0, mPlayAreaTeleportBoxHeight / 2.0 + 0.02 * SCALE_FACTOR, 0]);
					mPlayAreaTeleportBox.Translate(-mCamera.GetPosition().x, 0, -mCamera.GetPosition().z);
				}
			}
			// If the user isn't pressing the button...
			else
			{
				// If the user WAS pressing the button, now he's not anymore
				if(mControllerBeingUsedIndex != 0)
				{
					// If the last position of the circle was valid, I update the opengl offset
					if(mIsPositionValid)
					{
						// I need to check which teleport transition to use: the moving animation or the fade-to-black animation. The choice is determined
						// by the distance; if it's too long, I use the fade-to-black animation to avoid motion sickness. So now I need to determine
						// the distance from the player to the desired position
						var playerPos = mCamera.GetPosition() - mOpenglTranslationOffset;
						var circlePos = mPositionCircleObj.GetPosition();
						
						// I only care about the x and z values for the distance, so the y is put to 0
						playerPos.y = 0;
						circlePos.y = 0;
						
						var distance = Modulus(playerPos - circlePos);
						
						// If the distance is below the threshold, I create the moving animation
						if(distance < mTeleportDistanceThreshold)
//						if(distance < 200)
						{
							// The new position has the same y as the opengl offset (I only want to move along the x and z axis after all), 
							// and as x and z it has the difference between the player's position and the desired position
							var cameraPosition = mCamera.GetPosition();
							var newPos = [0.0, mOpenglTranslationOffset.y, 0.0];
							newPos.x = cameraPosition.x - mPositionCircleObj.GetPosition().x;
							newPos.z = cameraPosition.z - mPositionCircleObj.GetPosition().z;
								
							// Normally the animation is direct from the player's position to the desired one. But if the player's controller is, for example,
							// after a wall and it points directly behind it (a position that can't be directly seen by the player's point of view), 
							// the player would move through the wall to get to that position. To avoid that, I check whether the desired position
							// can be directly seen by the player's position; if that's so, I move directly to it. Otherwise, I first move
							// where the controller was, and then to the desired position. 
							// So first, I need to check whether the player can see the desired point
							var raycastOrigin = mCamera.GetPosition() - mOpenglTranslationOffset;
							var raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
							
							var contactPoint;
							var normal;
							var isWall = true;
								
							var isPositionValid = mCurrentLevel.IsPointedPositionValid(raycastOrigin, raycastEnd, &contactPoint, &normal, &isWall);
							
							// If the player can see the desired point, I create a direct transition
//							if(isPositionValid)
								mAnimator.CreateGenericTransition(mOpenglTranslationOffsetAnimationID, mOpenglTranslationOffset, newPos, 0.2, 3);
							// Otherwise, I create a waypoint transition that first move from the camera's position to the position of the controller,
							// and then to the desired position
//							else
//							{
//								var controllerPos = mCamera.GetPosition() - mInputManager.GetController(mControllerBeingUsedIndex).GetPosition();
//	//							var controllerPos = mCamera.GetPosition() - (mCamera.GetPosition() - mOpenglTranslationOffset - [1 * SCALE_FACTOR, 0, 0]);
//								controllerPos.y = mOpenglTranslationOffset.y;
//								
//								mAnimator.CreateGenericTransition(mOpenglTranslationOffsetAnimationID, mOpenglTranslationOffset, {controllerPos, newPos}, 0.2, 3);
//							}
						}
						// If the distance to the desired point is too great, I teleport using the fade-to-black transition
						else
						{
							// When the user teleports there is a very quick fade effect to black and then to white; in order to make it look cool, I need to
							// teleport the player when the fade reaches black (i.e. the screen is completely black). I do this only if there is no current
							// fading animation active (for example, when the game is starting and there is a "fade in", I can't create the animation otherwise
							// it overwrites the old animation). So I check if there is no current animation, and in that case I create one
							if(!mAnimator.HaveTransition(mFadeAnimationID, 6))
							{
								// At start, the fade animation is composed of 1 animation from white to black, so that later I can check if the animation ended
								// and if that is so, I teleport the user and create another animation, this time from black to white. I don't create
								// a waypoint animation because it caused artifacts, maybe because the animation is very fast
								mAnimator.CreateGenericTransition(mFadeAnimationID, 0.0, 1.0, 0.15);
								
								// I state that the user is teleporting, so that now I can check when the screen becomes black
								mIsTeleporting = true;
							}
							// This is the case where the animation doesn't have to be used, and the player needs to be teleported instantly
							else
							{
								// The new offset is the difference between the player's position and the new position of the circle;
								// I'm only udpating the x and y values since the y should stay the same
								var cameraPosition = mCamera.GetPosition();
								mOpenglTranslationOffset.x = cameraPosition.x  - mPositionCircleObj.GetPosition().x;
								mOpenglTranslationOffset.z = cameraPosition.z  - mPositionCircleObj.GetPosition().z;
								
								// I notify the current level that the offset has changed
								mCurrentLevel.SetOpenglTransformOffset(&mOpenglTranslationOffset);
							}
						}
					}
					
					mControllerBeingUsedIndex = 0;
				}
			}
			
			
			if(mAnimator.HaveTransition(mOpenglTranslationOffsetAnimationID, 6))
			{	mOpenglTranslationOffset = mAnimator.GetCurrentStateInTransition(mOpenglTranslationOffsetAnimationID, 6);
				// I notify the current level that the offset has changed
				mCurrentLevel.SetOpenglTransformOffset(&mOpenglTranslationOffset);
			}
			
			
			// If the user presses the grip buttons of the controllers, I show the play area plane
			if(mInputManager.IsGripPressed(1) || mInputManager.IsGripPressed(2))
				mIsPlayAreaPlaneVisible = true;
			else
				mIsPlayAreaPlaneVisible = false;
			
			// If the current level is completed, I switch to the next one
			if(mCurrentLevel.IsLevelCompleted())
			{
				// If the level that notified this is the menu, I need to do something a little different
				if(mCurrentLevel.__GetName() == "LEVELMENU")
				{
					if(!mEndingLevelMenu)
					{
						// If we reach this, it means we're moving from the menu level to an actual level; so, I create a fade effect from white to black
						// and then from black to white
						mAnimator.CreateGenericTransition(mFadeAnimationID, 0.0, {1.0, 0.0}, 3.0);
						mEndingLevelMenu = true;
					}
					// If the fade effect reached 1.0 (i.e. the screen is completely black), I change level
					else if(mFadeToBlackAlpha >= 1.0)
					{
						mCurrentLevelNumber = mCurrentLevel.GetSelectedLevel();

						// In order to position the player inside the elevator, I take the difference between their position and the one of the elevator.
						// Note that I'm not considering the mOpenglTranslationOffset; I consider it to be [0, 0, 0], as new. This will be the starting
						// opengl offset for the new level
						var startingOpenglOffset = mCamera.GetPosition() - mElevator.GetPosition();
						
						// If the level is actually the first, I don't put the player inside the elevator, but in front of it; otherwise, I put it in the middle
						if(mCurrentLevelNumber == 0)
							startingOpenglOffset.z -= 40.0 * SCALE_FACTOR - mElevator.GetRoomDepth();
						else
							startingOpenglOffset.z -= mElevator.GetRoomDepth() / 2.0;
						
						if(!mLevelsPreloading){
							switch(mCurrentLevelNumber){
								case 0:
									mCurrentLevel = mLevel0;	
									break;
								case 1:
									mCurrentLevel = Level1(mIsVRon, mInputManager, mSoundManager);	
									break;
								case 2:
									mCurrentLevel = Level2(mIsVRon, mInputManager, mSoundManager);	
									break;
								case 3:
									mCurrentLevel = Level3(mIsVRon, mInputManager, mSoundManager);	
									break;
								case 4:
									mCurrentLevel = Level4(mIsVRon, mInputManager, mSoundManager);	
									break;
								case 5:
									mCurrentLevel = Level5(mIsVRon, mInputManager, mSoundManager);	
									break;
								case 6:
									mCurrentLevel = Level6(mIsVRon, mInputManager, mSoundManager);	
									break;
							}						
						}
						else{
							mCurrentLevel = mLevels[mCurrentLevelNumber];
						}
						
						mCurrentLevel.Init(mLights, {[1, 1, 1], [1, 1, 1], [1, 1, 1]}, mElevator, [startingOpenglOffset.x, 0.0, startingOpenglOffset.z]);

						mEndingLevelMenu = false;
						mStarting = true;
					}
				}			
				else if(mCurrentLevelNumber + 1 < len(mLevels))
				{
					var lightsDiffuse = mCurrentLevel.GetLightDiffuse();
					mCurrentLevel = mLevels[mCurrentLevelNumber + 1];
					mCurrentLevel.Init(mLights, lightsDiffuse, mElevator, mOpenglTranslationOffset);
					mCurrentLevelNumber++;
				}
				else
				{
					if(!mEnding)
					{
						mAnimator.CreateGenericTransition(mFadeAnimationID, 0.0, 1.0, 5.0);
						mGameStatus = STATUS_ENDGAME;
						mEndTimer = GetTime();
						mEnding = true;
					}
				}
			}
			
			// If there is an active transition for the fade effect, I take the current value. It's the only way to update the alpha value
			if(mAnimator.HaveTransition(mFadeAnimationID, 6))
				mFadeToBlackAlpha = mAnimator.GetCurrentStateInTransition(mFadeAnimationID, 6);
				
								
			// If the game was starting, there was a fade in effect; if the fade alpha reached almost zero (I don't check zero to avoid floating 
			// point errors), surely the game has started
			if(mStarting && mFadeToBlackAlpha <= 0.01)
				mStarting = false;
						
			// If the user was teleporting (i.e. there is a pending fade animation) and the fade alpha reached the threshold (I should check that the screen
			// is completely black, but to avoid artifacts due to the very fast animation I check that it's above this threshold, which is good enough), I need
			// to teleport the player
			if(mIsTeleporting && mFadeToBlackAlpha >= 0.65)
			{
				// I teleport the player
				var cameraPosition = mCamera.GetPosition();
				mOpenglTranslationOffset.x = cameraPosition.x  - mPositionCircleObj.GetPosition().x;
				mOpenglTranslationOffset.z = cameraPosition.z  - mPositionCircleObj.GetPosition().z;
				
				// I notify the current level that the offset has changed
				mCurrentLevel.SetOpenglTransformOffset(&mOpenglTranslationOffset);
				
				// I create the animation from black to white
				mAnimator.CreateGenericTransition(mFadeAnimationID, 1.0, 0.0, 0.15);
				
				// I state that the player is no longer teleporting
				mIsTeleporting = false;
			}
			
			// Debug checks to stop/resume the music
			if(Keypressed("V"))
				mSoundManager.PauseMusic();
			if(Keypressed("B"))
				mSoundManager.PlayMusic();
				
			mAnimator.UpdateTransitions(dt);
				
			break;
		}
			
		default:
			break;
	}
}

function GameManager::DrawCrosshair()
{
	// This array will contain at position 2 the width of the viewport, and at 3 its height
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable(GL_LIGHTING);
    
    glLineWidth(2.0);
    
    
    // Horizontal line
    glBegin(GL_LINES);
    	glColor(0.0, 0.0, 0.0, 1.0);
        
        glVertex(viewport[2] / 2 - 7, viewport[3] / 2);
        glVertex(viewport[2] / 2 + 7, viewport[3] / 2);
    glEnd();
        
    // Vertical line
    glBegin(GL_LINES);
        glVertex(viewport[2] / 2, viewport[3] / 2 + 7);
        glVertex(viewport[2] / 2, viewport[3] / 2 - 7);
    glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}


/*
 * 
 */
function GameManager::FadeToBlackScreen()
{
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[4], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable( GL_LIGHTING );
    
    glBegin(GL_QUADS);
	    glColor(0.0, 0.0, 0.0, mFadeToBlackAlpha);
	    glVertex(-1.0, -1.0);
	    glVertex(1.0, -1.0);
	    glVertex(1.0, 1.0);
	    glVertex(-1.0, 1.0);
	glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}