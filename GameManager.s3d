global var DEBUG_MODE = true;
global var MUSIC_ON = true;
global var MUSICFX_ON = true;
global var SCALE_FACTOR = 0.2;

#define STATUS_MENU     0
#define STATUS_INGAME   1
#define STATUS_ENDGAME   2

#define USE_TOON_SHADER 1


#include "Utils.s3d"
#include "Text.s3d"
#include "VirtualKeyboard.s3d"
#include "Numpad.s3d"
#include "ViveController.s3d"
#include "DrawingsConnector.s3d"
#include "GlassBox.s3d"
#include "TilesPath.s3d"
#include "LevelMenuSelector.s3d"
#include "PreviewFrame.s3d"
#include "CubeNumbers.s3d"
#include "RandomMeshes.s3d"
#include "MarcelloUtils.s3d"
#include "Level0.s3d"
#include "LevelMenu.s3d"
#include "Level1.s3d"
#include "Level2.s3d"
#include "Level3.s3d"
#include "Level4.s3d"
#include "Level5.s3d"
#include "InputManager.s3d"


/*
 * This class manages the whole game and the transition between levels.
 * It also manages the rendering and the integration of the HTC Vive, so that levels don't need to be aware of it (too much).
 * 
 * NOTE: The controller's CVmObj should be created in the GameManager but passed to each level's class. The level should handle rendering them, but
 * NOT updating their position, sinceit's better that the GameManger does that, so that the levels have no idea of the HTC Vive being used.
 * The ideal would be to update their position in the UpdateLogic of the GameManager (at start) and then setting the new position to the level's controller
 * (using a method like "mCurrentLevel.SetControllerPosition(pos)".
 */
class GameManager
{
	// This variable has access to the DLL functions to control the Vive
	var mHMD;
	var mJoystick;
	
	// Boolean, set to true if the Vive was detected at start; false otherwise
	var mIsVRon;
	
	var mGameStatus;
	var mGameStarted;
	var mGameReady;
	var mCurrentLevel;
	var mCurrentLevelNumber;
	var mMenu;
	
	var mElevator;
	
	var mCamera;
	
	var mInputManager;
	var mSoundManager;
	
	var mEnding;
	var mEndTimer;
	var mTimeToEnd;
	
	// Booleans that indicate if the screen is fading to black or not
	var mFadingIn;
	var mFadingOut;
	
	// If the screen is fading to black, this float contains the alpha of the fading (1 == totally black, 0 == totally invisible)
	var mFadeToBlackAlpha;
	
	
	var mLights;
	
	var mLevels;
	
	/* In order to use the teleporting feature along with the HTC Vive, when a user teleports to a destination we need to change the camera's position 
	 * in opengl fashon, meaning NOT using the SetPosition() of XVR. This is because the HTC Vive is powered by OpenVR, which works in its own way, and 
	 * it's not related to XVR classes. So, to move the Vive camera (and so also the XVR one) we need to move the camera as if we were using only opengl,
	 * meaning that we have to use glTransform(). We basically translate the whole scene at every frame, according to this offset.
	 * In order for this to NOT affect XVR objects, we need to be careful. For instance, if I need to get the position of the camera I need to 
	 * subtracts the vector mOpenglTranslationOffset to get the "actual" position of the camera in the world, since using glTransform doesn't change
	 * the camera position in the XVR object. Same goes for the lights.
	 * So, this vector is very important in the whole game, and everytime it gets changed (i.e. when the user teleports), the current level
     * needs to know the updated value, otherwise the level's logic will be updated using wrong positions */
	var mOpenglTranslationOffset;
	
	
	// This object is the circle that appears when the user wants to teleport to a destination
	var mPositionCircleObj;
	
	// Radius and height of the position circle
	var mPositionCircleRadius;
	var mPositionCircleHeight;
		
	// Shader used to render the position circle
	var mPositionCircleShader;
	
	// Objects that represent the play area rectangle (that is displayed as a box to create a cool shading effect). The play area is defined by the Vive's lighthouse
	// system and it's basically the area that the player can move in safely
	var mPlayAreaRec;
	var mPlayAreaBox;
	var mPlayAreaBoxHeight;
	var mPlayAreaBoxShader;
	
	// Boolean that indicates if the current position of the circle is a valid position for teleportation
	var mIsPositionValid;
	
	// Shader used to create the dashed lines when the player uses that teleportation feature
	var mDashedLineShader;
	
	// Offset used by the "dashed line shader" to create the illusion that the line segments are moving
	var mDashedLinesOffset;
	
	// If the current position of the circle isn't valid, this boolean indicates if it's placed on a wall; in that case the circle will be shown anyway, 
	// otherwise it will be hidden for rendering simplicity (meaning that it would be hard to render correctly the circle to a surface that is not planar like a wall)
	var mIsWall;
	
	// This boolean indicates whether the user is currently pressing the secondary button for teleportation
	var mIsPressingSecondaryButton;
	
	// Index of the controller being used for the teleportation
	var mControllerBeingUsedIndex;


	// Private methods
	XVRRendering();
	DrawCrosshair();
	FadeToBlackScreen(fadeIn);
	
	// Public methods
	Render();
	UpdateLogic(dt);
};


function GameManager::GameManager(HMD)
{
	mHMD = HMD;
	mJoystick = CVmJoystick();
	
	mIsVRon = mHMD.IsVRactive() == 1;
		
	mGameStatus = STATUS_INGAME;
		
	mGameStarted = false;
	mGameReady = false;
	
	mCamera = CameraGetCurrent();
	
	mInputManager = InputManager(mIsVRon, mHMD, mJoystick);
	mInputManager.SetActiveCamera(mCamera);
	
	mSoundManager = SoundManager();
	mSoundManager.SetMusic("sounds/Nexus - Tranquility.mp3", 0.95, true, 7.0);
	
	if(MUSIC_ON)
		mSoundManager.PlayMusic();
	
	mLights = {};
	
	
	var light0 = CVmLight();
	light0.SetPosition([-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR]);
	light0.SetDiffuse(1, 1, 1);
	light0.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light0.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light0.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light0.Disable();	
	
	var light1 = CVmLight();
	light1.SetPosition([-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR]);
	light1.SetDiffuse(1, 1, 1);
	light1.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light1.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light1.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light1.Disable();	
	
	var light2 = CVmLight();
	light2.SetPosition([-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR]);
	light2.SetDiffuse(1, 1, 1);
	light2.SetParameter(GL_CONSTANT_ATTENUATION, 1.0);
	light2.SetParameter(GL_LINEAR_ATTENUATION, 0.0000);
	light2.SetParameter(GL_QUADRATIC_ATTENUATION, 0.0000);
	light2.Disable();
	
	aadd(mLights, light0);
	aadd(mLights, light1);
	aadd(mLights, light2);
	
	mOpenglTranslationOffset = [0, 0, 0]; 
	
	mTimeToEnd = 7000;
	mEnding = false;
	
	mLevels = {};
	var arrayLevel0 = Level0(mIsVRon, mInputManager, mSoundManager, mLights, &mOpenglTranslationOffset);

	if(DEBUG_MODE)
	{
		// The current level takes as parameter the input manager, which is shared among every level
		
		mElevator = arrayLevel0.GetElevator();
		mElevator.Unhide();
		
		// Sposto la camera in modo che sia dentro l'ascensore
		mCamera.SetPosition(0, 6.0 * SCALE_FACTOR, -2.0 * SCALE_FACTOR);
		
//		for(var i = 0; i < 5; i++){
//			aadd(mLevels, i);	
//		}

		SetClearColor(0.95,0.95,0.95);  
//		aadd(mLevels, arrayLevel0);
//		aadd(mLevels, Level1(mIsVRon, mInputManager, mSoundManager));
//		aadd(mLevels, Level2(mIsVRon, mInputManager, mSoundManager));
//		aadd(mLevels, Level3(mIsVRon, mInputManager, mSoundManager));
//		aadd(mLevels, Level4(mIsVRon, mInputManager, mSoundManager));	
		
//		mCurrentLevel = LevelMenu(mIsVRon, mInputManager, mSoundManager, mLevels, mElevator);
		mCurrentLevel = Level2(mIsVRon, mInputManager, mSoundManager);
		mCurrentLevel.Init(mLights, mElevator, &mOpenglTranslationOffset);			
		mCurrentLevelNumber = -1;
		
		mFadeToBlackAlpha = 1;
		mFadingIn = false;
		mFadingOut = false;
	}
	else 
	{
		// The current level takes as parameter the input manager, which is shared among every level
		mCurrentLevel = arrayLevel0;
		mCurrentLevelNumber = 0;
		
		mElevator = mCurrentLevel.GetElevator();
		
		aadd(mLevels, arrayLevel0);
		aadd(mLevels, Level1(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level2(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level3(mIsVRon, mInputManager, mSoundManager));
		aadd(mLevels, Level4(mIsVRon, mInputManager, mSoundManager));

		mFadeToBlackAlpha = 1;
		mFadingIn = true;
		mFadingOut = false;
	}
	
	// Creating the position circle object, used for the teleportation feature
	mPositionCircleRadius = 1.0 * SCALE_FACTOR;
	mPositionCircleHeight = 0.2 * SCALE_FACTOR;
	var positionCircleMesh = CVmNewMesh(VRP_CYLINDER, 30, mPositionCircleRadius, mPositionCircleHeight, 1);  
	positionCircleMesh.Normalize(4 * SCALE_FACTOR);
	mPositionCircleObj = CVmObj(positionCircleMesh);
	
	// Booleans used for the teleportation feature
	mIsPositionValid = false;
	mIsWall = false;
	mIsPressingSecondaryButton = false;
	
	// Initially, no controller is being used
	mControllerBeingUsedIndex = 0;
	
	// Shaders used to render the dashed line and the circle for the teleportation feature
	mDashedLineShader = CVmShaderProgram("dashedLineShader.glsl");
	mPositionCircleShader = CVmShaderProgram("positionCircleShader.glsl");
	mPlayAreaBoxShader = CVmShaderProgram("playAreaBoxShader.glsl");
	
	// Offset used for the teleportation feature rendering
	mDashedLinesOffset = 0;
	
	// Getting the play area size for the Vive; if the Vive isn't on, a default size is chosen. This method returns a vector containing with and depth of the area
	mPlayAreaRec = mInputManager.GetPlayAreaSize();
	
	// Height of the play area box
	mPlayAreaBoxHeight = 4.0 * SCALE_FACTOR;
	
	// Creating the play area box
	var playAreaBoxMesh = CVmNewMesh(VRP_BOX, 1, [-mPlayAreaRec.x / 2.0, -mPlayAreaBoxHeight/2.0, -mPlayAreaRec.y / 2.0], [mPlayAreaRec.x/2.0, mPlayAreaBoxHeight/2, mPlayAreaRec.y / 2.0]);
	mPlayAreaBox = CVmObj(playAreaBoxMesh);
}

/*
 * Render function. It delegates the job to the current level or the menu manager
 */
function GameManager::Render()
{
	switch (mGameStatus) 
	{
		case STATUS_MENU:
	//		mMenu.Render();
			break;
		case STATUS_ENDGAME:
		case STATUS_INGAME:{
				
			mCurrentLevel.SetupOpenglLights();
				
				
			SceneBegin(mCamera);
			
			
			glEnable (GL_BLEND);
			glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
			
			XVRRendering();

			if(mIsVRon)
			{		
				mHMD.SceneBegin();
				
					mCurrentLevel.SetupOpenglLights();
					
					glEnable (GL_BLEND);
					glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
					
					mHMD.frame_left();
						XVRRendering();
					mHMD.frame_right();
						XVRRendering();
				mHMD.SceneEnd();
			}	
				
			SceneEnd();
			break;
			
			}
		default:
			break;
	}
}

function GameManager::XVRRendering()
{
	// The current level might change the opengl offset (for now only when it moves the camera with the elevator), so we get it before applying it below
	mOpenglTranslationOffset = mCurrentLevel.GetOpenglTransformOffset();
	
	/* This is very important: in order to move around with the HTC Vive using the teleportation, we need to translate everything when rendering by
	 * the amount computed when the teleportation goes through. This means that the whole world will shift by this amount, BUT the XVR objects
	 * won't move, meaning that their position taken with their GetPosition() methods will stay the same even after the translation.
	 * So in the levels it's important to take this into account when making computations based on the player position. For example,
	 * if I want to know where the player actually is, I need to to something like "mCamera.GetCamera() - mOpenglTranslationOffset": this
	 * will be the REAL position of the player.
	 * By letting the GameManager handle this, the levels stay pretty much the same, except for computing positions of some things (camera 
	 * and lights), as I just mentioned */
	glTranslate(mOpenglTranslationOffset);

	mCurrentLevel.Render();

	// Here we render the positional circle, if the user is pressing the button. Since it's common for every level, it's better to do it here
	if(mControllerBeingUsedIndex != 0)
	{		
		// I also render a line from the controller to the position circle.
		// Note: need to modify the code so that if the Vive is active the line starts from the controller, not the camera
		var raycastOrigin;
		
		if(mIsVRon)
			raycastOrigin = mInputManager.GetController(mControllerBeingUsedIndex).GetPosition();
		else 
			raycastOrigin = mCamera.GetPosition() - mOpenglTranslationOffset - [-0.1 * SCALE_FACTOR, 0.1 * SCALE_FACTOR, 0.0 * SCALE_FACTOR];
		
		// The endpoint is at the top of the cylinder that is the position "circle"
		var raycastEnd = mPositionCircleObj.LocalToWorld([0, mPositionCircleHeight, 0]); 
												
		var color;
		
		// If the position is valid the ray is blue, otherwise it's red
		if(mIsPositionValid)
			color = [0, 0, 1];
		else
			color = [1, 0, 0];
		
		// Rendering of the ray
		mDashedLineShader.Start();
			// Parameters for the ray's shader
			mDashedLineShader.SetParameter("sourcePosition", raycastOrigin);
			mDashedLineShader.SetParameter("lineLength", Modulus(raycastEnd - raycastOrigin));
			mDashedLineShader.SetParameter("color", color);
			mDashedLineShader.SetParameter("ticksLength", 0.17 * SCALE_FACTOR);
			mDashedLineShader.SetParameter("offset", mDashedLinesOffset);
			
			glLineWidth(2.5); 
			
			// I draw the ray as a simple opengl line
			glBegin(GL_LINES);
				glVertex(raycastOrigin);
				glVertex(raycastEnd);		
			glEnd();
		mDashedLineShader.Stop();
								
		// If the position is on a wall, I also draw the position circle
		if(mIsWall)
		{
			mPositionCircleShader.Start();
				// Parameters for the circle's shader
				mPositionCircleShader.SetParameter("color", color);
				mPositionCircleShader.SetParameter("radius", mPositionCircleRadius * 2.0);
				mPositionCircleShader.SetParameter("innerCircleTickness", 0.06 * SCALE_FACTOR);
				mPositionCircleShader.SetParameter("outerCircleTickness", 0.16 * SCALE_FACTOR);
				mPositionCircleShader.SetParameter("offset", mDashedLinesOffset * 300.0); // The offset needs to be higher, otherwise the lines move slowly
				mPositionCircleShader.SetParameter("ticksNumber", 15.0);

				mPositionCircleObj.Draw();
			mPositionCircleShader.Stop();
			
			// If the position is valid I also draw the play area box
			if(mIsPositionValid)
			{
				mPlayAreaBoxShader.Start();
					mPlayAreaBoxShader.SetParameter("color", color);
					mPlayAreaBoxShader.SetParameter("width", mPlayAreaRec.x);
					mPlayAreaBoxShader.SetParameter("depth", mPlayAreaRec.y);
					mPlayAreaBoxShader.SetParameter("height", mPlayAreaBoxHeight);
					mPlayAreaBoxShader.SetParameter("outerEdgesTickness", 0.06 * SCALE_FACTOR);
					
					// In order to render the box correctly with the shader, I have to render first the back faces and then the front faces.
					// If I only draw the front faces, some fragments will have transparency, but behind there wouldn't be anything since the back
					// faces wouldn't be drawn. By drawing them first, I can assure that the transparencies of the fragments will be consistent
					glCullFace(GL_FRONT);
					mPlayAreaBox.Draw();
					glCullFace(GL_BACK);
					mPlayAreaBox.Draw();
				mPlayAreaBoxShader.Stop();
			}
		}
		
		// I increment the offset used for the rendering of the ray and the circle, so that in the next frame the ticks position will shift
		mDashedLinesOffset += 0.01 * SCALE_FACTOR;
	}
	// If we don't have to draw the ray, I reset its offset, so that it doesn't increment too much in the course of the game
	else
		mDashedLinesOffset = 0;
	
	
	// Drawing the crosshair and everything that is 2D after I'm finished with the 3D stuff, but only if the VR isn't on
	if(!mIsVRon)
		DrawCrosshair();
	
	if(mFadingIn)
	{
		FadeToBlackScreen(true);
		mFadingIn = mFadeToBlackAlpha > 0.0;
	}
	else if(mFadingOut)
	{
		FadeToBlackScreen(false);
//		mFadingOut = mFadeToBlackAlpha < 1.0; // For now I let the screen go black indefinitely
	}
}

/*
 * Update logic function. It delegates the job to the current level or the menu manager
 */
function GameManager::UpdateLogic(dt)
{
 	switch (mGameStatus) {
		
		case STATUS_MENU:
		
			break;
		case STATUS_ENDGAME:
			// If the game is ending and has passed enough time, I quit the application. The problem is that the Quit() function doesn't work.
			// Note that I keep updating the current level's logic and I render it, because in the meantime the screen is fading to black
//			if(GetTime() - mEndTimer > mTimeToEnd)
//				Quit();
		case STATUS_INGAME:	
		{
			// The first thing we have to do is to update the logic of the current level
			mCurrentLevel.UpdateLogic(dt);
			
			var usingController1 = mInputManager.IsPressingSecondaryButton(1);
			var usingController2 = mInputManager.IsPressingSecondaryButton(2);
			
			
			var firstTimeUsingController = (usingController1 || usingController2) && mControllerBeingUsedIndex == 0;
			var wasUsingController1 = (usingController1 && mControllerBeingUsedIndex == 1);
			var wasUsingController2 = (usingController2 && mControllerBeingUsedIndex == 2);
			
			// Checking the user is pressing the button to teleport
			if(firstTimeUsingController || wasUsingController1 || wasUsingController2)
			{				
				if(firstTimeUsingController)
					mControllerBeingUsedIndex = usingController1 ? 1 : 2;
				
				// I get the camera's position- minus the offset so we get the actual position of the player in the world
				// NOTE: if the Vive is active, this shouldn't be the camera's, but the controller's position. Need to modify the code
				var raycastOrigin;
				var raycastEnd;
				
				// Computing the ray that goes to infinity: I'm going to check were it collides
				if(mIsVRon)
				{
					var controller = mInputManager.GetController(mControllerBeingUsedIndex);
					raycastOrigin = controller.GetPosition();
					raycastEnd = raycastOrigin + controller.GetDirection() * mCamera.GetZFar();
				}
				else
				{
					raycastOrigin = mCamera.GetPosition() - mOpenglTranslationOffset;
					raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
				}
					
				
				var contactPoint;
				var normal;
				
				// I'm assuming the intersection will be in a wall
				mIsWall = true;
				
				// I ask the level to check where the ray intersects and if that position is valid. I'm passing the reference to some objects
				// so that the level will put in there the point of interception, the normal of the object and whether it's a wall or not
				mIsPositionValid = mCurrentLevel.IsPointedPositionValid(raycastOrigin, raycastEnd, &contactPoint, &normal, &mIsWall);
				
				
				if(contactPoint != Void)
				{
					// If the position is valid I reset the circle's rotation, in case it was previously rotated (I'm doing this since I know that valid
					// positions are for floors, and the circle as default is parallel to the floor
					if(mIsPositionValid)
						mPositionCircleObj.SetRotation(0, 0, 1, 0);
					// If it's not valid, I check the normal of the contact point in order to rotate the circle accordingly
					else
					{
						if(abs(normal.x) == 1)
						{
							mPositionCircleObj.SetRotation(90, 0, 0, 1);
						}
						else if(abs(normal.z) == 1)
						{
							mPositionCircleObj.SetRotation(90, 1, 0, 0);
						}
						else
							mPositionCircleObj.SetRotation(0, 0, 1, 0);
					}
					
					// Finally I set the position of the circle, subtracting the direction vector so that the circle is not really on the plane but a bit
					// closer to the user (to avoid Z fighting with the intersected plane)
					mPositionCircleObj.SetPosition(contactPoint - mCamera.GetDirection() * SCALE_FACTOR);
					
					// I also position the play area box in that point, lifting it a bit so that it's completely above the ground (remember, the box
					// has the origin in its center). I then translate the box, moving it so that it shows where the player is in the world with respect
					// to the play area; where the player is can be seen directly by looking at the position of the camera
					mPlayAreaBox.SetPosition(contactPoint + [0, mPlayAreaBoxHeight / 2.0 + 0.02 * SCALE_FACTOR, 0]);
					mPlayAreaBox.Translate(-mCamera.GetPosition().x, 0, -mCamera.GetPosition().z);
				}
			}
			// If the user isn't pressing the button...
			else
			{
				// If the user WAS pressing the button, now he's not anymore
				if(mControllerBeingUsedIndex != 0)
				{
					// If the last position of the circle was valid, I update the opengl offset
					if(mIsPositionValid)
					{
						// The new offset is the difference between the player's position and the new position of the circle;
						// I'm only udpating the x and y values since the y should stay the same
						var cameraPosition = mCamera.GetPosition();
						mOpenglTranslationOffset.x = cameraPosition.x  - mPositionCircleObj.GetPosition().x;
						mOpenglTranslationOffset.z = cameraPosition.z  - mPositionCircleObj.GetPosition().z;
						
						// I notify the current level that the offset has changed
						mCurrentLevel.SetOpenglTransformOffset(&mOpenglTranslationOffset);
					}
					
					mControllerBeingUsedIndex = 0;
				}
			}
			
			if(mCurrentLevel.IsLevelCompleted())
			{
				if(mCurrentLevel.__GetName() == "LEVELMENU"){
					mCurrentLevelNumber = mCurrentLevel.GetSelectedLevel();
					mCamera.SetPosition(0, 6.0 * SCALE_FACTOR, -2.0 * SCALE_FACTOR);
					mCurrentLevel = mLevels[mCurrentLevelNumber];
					mCurrentLevel.Init(mLights, mElevator, mOpenglTranslationOffset);
				}			
				else if(mCurrentLevelNumber + 1 < len(mLevels))
				{
					mCurrentLevel = mLevels[mCurrentLevelNumber + 1];
					mCurrentLevel.Init(mLights, mElevator, mOpenglTranslationOffset);
					mCurrentLevelNumber++;
				}
				else
				{
					if(!mEnding)
					{
						mFadingOut = true;
						mFadeToBlackAlpha = 0;
						mGameStatus = STATUS_ENDGAME;
						mEndTimer = GetTime();
						mEnding = true;
					}
				}
			}
			
			// Debug checks to stop/resume the music
			if(Keypressed("V"))
				mSoundManager.PauseMusic();
			if(Keypressed("B"))
				mSoundManager.PlayMusic();
				
			break;
		}
			
		default:
			break;
	}
}

function GameManager::DrawCrosshair()
{
	// This array will contain at position 2 the width of the viewport, and at 3 its height
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[3], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable(GL_LIGHTING);
    
    glLineWidth(2.0);
    
    
    // Horizontal line
    glBegin(GL_LINES);
    	glColor(0.0, 0.0, 0.0, 1.0);
        
        glVertex(viewport[2] / 2 - 7, viewport[3] / 2);
        glVertex(viewport[2] / 2 + 7, viewport[3] / 2);
    glEnd();
        
    // Vertical line
    glBegin(GL_LINES);
        glVertex(viewport[2] / 2, viewport[3] / 2 + 7);
        glVertex(viewport[2] / 2, viewport[3] / 2 - 7);
    glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}


/*
 * 
 */
function GameManager::FadeToBlackScreen(fadeIn)
{
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);

	if(fadeIn)
		mFadeToBlackAlpha -= 0.006;
	else
		mFadeToBlackAlpha += 0.004;
	
	glClear(GL_DEPTH_BUFFER_BIT);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, viewport[2], viewport[4], 0, -1, 1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    
    glEnable(GL_BLEND);
    glDisable(GL_DEPTH_TEST);
    glDepthMask(GL_FALSE);
    
    glDisable( GL_LIGHTING );
    
    glBegin(GL_QUADS);
	    glColor(0.0, 0.0, 0.0, mFadeToBlackAlpha);
	    glVertex(-1.0, -1.0);
	    glVertex(1.0, -1.0);
	    glVertex(1.0, 1.0);
	    glVertex(-1.0, 1.0);
	glEnd();
	
	glMatrixMode(GL_PROJECTION);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);
	
	glEnable( GL_LIGHTING );
}