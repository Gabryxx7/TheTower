/*
 * Class that represents a room, with an optional front wall (so that it can be used for portals' rooms, that don't have the front wall so the camera
 * dosn't get obstructed when the room is rendered). It gives more flexibility than simply creating a box, and it's easier to maintain
 */ 
class Room
{
	// Sizes
	var mFarWallWidth;
	var mSideWallWidth;
	var mRoomHeight;
	var mHalfFarWidth;
	var mHalfSideWidth;
	var mHalfHeight;	
	
	// Meshes for the walls. I keep track of them in order to manipulate their shaders
	var mFarWallMesh;
	var mSideWallMesh;
	var mRoofMesh; // Works also as floor
	
	// Walls that compose the room
	var mFrontWallObj;
	var mBackWallObj;
	var mLeftWallObj;
	var mRightWallObj;
	var mRoofObj;
	var mFloorObj;

	// The CVmObj that contains the room
	var mRoom;
	
	// Number of the OpenGL light used to render the room
	var mLightsRangeMin;
	var mLightsRangeMax;
	
	// Boolean that states if the front wall is present
	var mHasFront;
	var mHasFloor;
	var mHasBack;
	
	// Corners of the room (these are local coordinates)
	var mLowerCornerPosition;
	var mUpperCornerPosition;
	
	var mLowerCornerWorld;
	var mUpperCornerWorld;
	
	// Shader to draw the silhouettes of the objects contained in the room
	var mSilhouetteShader;
	
	// Array that contains any object that is added to the room with the apposite function
	var mChildren;
		
	// Meshes for the silhouette lines added to each wall
	var	mFarWallSilhouetteLineMesh;
	var mHeightSilhouetteLineMesh;
	var mSideWallSilhouetteLineMesh;
	
	// Private functions
	AddSilhouetteLines(wall, type);
	
	// Public functions
	Draw();
	IsPointInRoom(point);
	AddObject(object, x, y, z);
	RemoveObject(object);
	GetObj();
	GetRoomWidth();
	GetRoomDepth();
	GetRoomHeight();
	SetLightsRange(min, max);
	GetLightsRange();
	LocalToWorld(point);
	SetPosition(position);
	GetPosition();
	Rotate(angle, x, y, z);
	Translate(x, y, z);
	Hide();
	Unhide();
	CheckIntersection(rayOrigin, rayEnd, contactPoint, normal);
};

/*
 * Constructor
 * 
 * farWallWidth: (float) width of the front and back wall
 * height: (float) height of the room
 * hasFront: (boolean) true if there is a front wall, false otherwise
 * centerInOrigin: (boolean) if true, the room is moved to the center of the coordinate system
 * lightNumber: (integer) the number of the opengl light that has to be used in the cel shader to render the room
 */
function Room::Room(farWallWidth, sideWallWidth, height, centerInOrigin, lightsRangeMin, lightsRangeMax, hasFront, hasFloor, hasBack)
{
	mFarWallWidth = farWallWidth;
	mSideWallWidth = sideWallWidth;
	mRoomHeight = height;
	
	mHalfFarWidth = mFarWallWidth / 2.0;
	mHalfSideWidth = mSideWallWidth / 2.0;
	mHalfHeight = mRoomHeight / 2.0;
	
	mHasFront = (valtype(hasFront) == "") ? true : hasFront;
	mHasFloor = (valtype(hasFloor) == "") ? true : hasFloor;
	mHasBack = (valtype(hasBack) == "") ? true : hasBack;
	
	mLightsRangeMin = lightsRangeMin;
	mLightsRangeMax = lightsRangeMax;
	
	// Creating the meshes for the walls; all are perpendicular to the z axis, and will be rotated accordingly later
	mFarWallMesh = CVmNewMesh(VRP_PLANE, 1, [-mHalfFarWidth, -mHalfHeight, 0], [mHalfFarWidth, mHalfHeight, 0], 2, 2);
	mSideWallMesh = CVmNewMesh(VRP_PLANE, 1, [-mHalfSideWidth, -mHalfHeight, 0], [mHalfSideWidth, mHalfHeight, 0], 2, 2);
	mRoofMesh = CVmNewMesh(VRP_PLANE, 1, [-mHalfFarWidth, -mHalfSideWidth, 0], [mHalfFarWidth, mHalfSideWidth, 0], 2, 2);
	
	
	// Adding the toon shader to the mesh's subset 0 (so the whole mesh in this case) and activating it
	if(USE_TOON_SHADER == 2){		
		mFarWallMesh.ShaderAdd("antishader.glsl", 0);
		mFarWallMesh.ShaderActivate(true);
	}
	else if(USE_TOON_SHADER == 1){
		mFarWallMesh.ShaderAdd("toonShader.glsl", 0);
		mFarWallMesh.ShaderActivate(true);		
	}
	else if(USE_TOON_SHADER == 0){
		mFarWallMesh.ShaderActivate(false);				
	}
	
	// Passing the material parameters of the mesh to the shader, and also the light number that has to be used to render the lighting on the mesh
	mFarWallMesh.ShaderSetParameter(0, "ambient", 0, [0.5, 0.5, 0.5]);
	mFarWallMesh.ShaderSetParameter(0, "diffuse", 0, [1, 1, 1]);
	mFarWallMesh.ShaderSetParameter(0, "specular", 0, [0.0, 0.0, 0.0]);
	mFarWallMesh.ShaderSetParameter(0, "shininess", 0, 0);
	mFarWallMesh.ShaderSetParameter(0, "lightsRangeMin", 0, lightsRangeMin);
	mFarWallMesh.ShaderSetParameter(0, "lightsRangeMax", 0, lightsRangeMax);
	mFarWallMesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, SCALE_FACTOR);
	mFarWallMesh.ShaderSetParameter(0, "alpha", 0, 1.0);
	
	if(USE_TOON_SHADER == 2){		
		mSideWallMesh.ShaderAdd("antishader.glsl", 0);
		mSideWallMesh.ShaderActivate(true);
	}
	else if(USE_TOON_SHADER == 1){
		mSideWallMesh.ShaderAdd("toonShader.glsl", 0);
		mSideWallMesh.ShaderActivate(true);		
	}
	else if(USE_TOON_SHADER == 0){
		mSideWallMesh.ShaderActivate(false);				
	}
	
	mSideWallMesh.ShaderSetParameter(0, "ambient", 0, [0.5, 0.5, 0.5]);
	mSideWallMesh.ShaderSetParameter(0, "diffuse", 0, [1, 1, 1]);
	mSideWallMesh.ShaderSetParameter(0, "specular", 0, [0.0, 0.0, 0.0]);
	mSideWallMesh.ShaderSetParameter(0, "shininess", 0, 0);
	mSideWallMesh.ShaderSetParameter(0, "lightsRangeMin", 0, lightsRangeMin);
	mSideWallMesh.ShaderSetParameter(0, "lightsRangeMax", 0, lightsRangeMax);
	mSideWallMesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, SCALE_FACTOR);
	mSideWallMesh.ShaderSetParameter(0, "alpha", 0, 1.0);
	
	if(USE_TOON_SHADER == 2){		
		mRoofMesh.ShaderAdd("antishader.glsl", 0);
		mRoofMesh.ShaderActivate(true);
	}
	else if(USE_TOON_SHADER == 1){
		mRoofMesh.ShaderAdd("toonShader.glsl", 0);
		mRoofMesh.ShaderActivate(true);		
	}
	else if(USE_TOON_SHADER == 0){
		mRoofMesh.ShaderActivate(false);				
	}
	
	mRoofMesh.ShaderSetParameter(0, "ambient", 0, [0.5, 0.5, 0.5]);
	mRoofMesh.ShaderSetParameter(0, "diffuse", 0, [1, 1, 1]);
	mRoofMesh.ShaderSetParameter(0, "specular", 0, [0.0, 0.0, 0.0]);
	mRoofMesh.ShaderSetParameter(0, "shininess", 0, 0);
	mRoofMesh.ShaderSetParameter(0, "lightsRangeMin", 0, lightsRangeMin);
	mRoofMesh.ShaderSetParameter(0, "lightsRangeMax", 0, lightsRangeMax);
	mRoofMesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, SCALE_FACTOR);
	mRoofMesh.ShaderSetParameter(0, "alpha", 0, 1.0);
		
	// Created the meshes, time to create the CVmObjects
	mRoofObj = CVmObj(mRoofMesh);
	mLeftWallObj = CVmObj(mSideWallMesh);
	mRightWallObj = CVmObj(mSideWallMesh);
	
	// Size of the silhouettes lines
	var silhouetteLineHalfWidth = 0.02 * SCALE_FACTOR;

	// Meshes for the lines of the silhouettes (actually they're thin planes)
	mFarWallSilhouetteLineMesh = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, 0, 0], [silhouetteLineHalfWidth, mFarWallWidth, 0], 2, 2);
	mHeightSilhouetteLineMesh = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, 0, 0], [silhouetteLineHalfWidth, mRoomHeight, 0], 2, 2);
	mSideWallSilhouetteLineMesh = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, 0, 0], [silhouetteLineHalfWidth, sideWallWidth, 0], 2, 2);
	
	// Black material for the lines
	var silhouetteMaterial = CVmMaterial();
	silhouetteMaterial.diffuse = [0, 0, 0];
	silhouetteMaterial.ambient = [0, 0, 0];
	silhouetteMaterial.specular = [0, 0, 0];
	
	mFarWallSilhouetteLineMesh.ForceMaterial(silhouetteMaterial);
	mHeightSilhouetteLineMesh.ForceMaterial(silhouetteMaterial);
	mSideWallSilhouetteLineMesh.ForceMaterial(silhouetteMaterial);

	// Adding the silhouettes lines to every wall in the room
	AddSilhouetteLines(mLeftWallObj, 1);
	AddSilhouetteLines(mRightWallObj, 1);
	AddSilhouetteLines(mRoofObj, 2);
	
	// If the room has a front wall I create that too
	if(mHasFront){
		mFrontWallObj = CVmObj(mFarWallMesh);
		AddSilhouetteLines(mFrontWallObj, 0);
	}
	
	if(mHasBack){
		mBackWallObj = CVmObj(mFarWallMesh);
		AddSilhouetteLines(mBackWallObj, 0);		
	}
		
	if(mHasFloor){
		mFloorObj = CVmObj(mRoofMesh);
		mFloorObj.Rotate(90, 1, 0, 0);
		AddSilhouetteLines(mFloorObj, 2);
	}
	
	// Rotating the roof and floor so they get perpendicular to the y axis
	mRoofObj.Rotate(90, 1, 0, 0);
	
	// Rotating the side walls so they get perpendicular to the x axis
	mLeftWallObj.SetRotation(-90, 0, 1, 0);
	mRightWallObj.SetRotation(90, 0, 1, 0);
		
	// Creating the container object. Each wall is translated to ro the right positions, sometimes using little offset so that they're 
	// NOT completely attached; this way the black contour created using the silhouette shader can be seen. These offset values are a bit random
	mRoom = CVmObj();
	if(mHasBack)
		mRoom.AddChild(mBackWallObj, 0, 0, 0 * SCALE_FACTOR);
		
	mRoom.AddChild(mRoofObj, 0, mHalfHeight + 0 * SCALE_FACTOR, mHalfSideWidth);
	
	if(mHasFloor)
		mRoom.AddChild(mFloorObj, 0, -mHalfHeight - 0 * SCALE_FACTOR, mHalfSideWidth);
		
	mRoom.AddChild(mLeftWallObj, -mHalfFarWidth, 0, mHalfSideWidth);
	mRoom.AddChild(mRightWallObj, mHalfFarWidth, 0, mHalfSideWidth);
	
	if(mHasFront)
		mRoom.AddChild(mFrontWallObj, 0, 0, mSideWallWidth + 0 * SCALE_FACTOR);
		
	// Moving the room in the origin if the user chose so
	if(centerInOrigin)
		mRoom.Translate(0, mHalfHeight, -mHalfSideWidth);
		
	// Computing the local coordinates of the bounding box of the room
	mLowerCornerPosition = [-mHalfFarWidth, -mHalfHeight, mSideWallWidth];
	mUpperCornerPosition = [mHalfFarWidth, mHalfHeight, 0];
		
	// Silhouette shader, used to create the black outline in the walls
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	
	// List of objects in the room; initially empty. Mind that the children are only useful for drawing, meaning that the Room object will 
	// only make sure to draw its children using the silhouette shader plus any shader they might have, nothing more
	mChildren = {};
}

/*
 * This method draws the room and any objects that was added to it. It makes sure to draw each object's silhouette and on top of it
 * the object itself using any shader that was added to it
 */
function Room::Draw()
{
	// In order to draw the silhouette of a object, I need to first draw a black, bigger version of it (or any color you want for the outline) by culling 
	// the front faces, so that only the back faces gets drawn. This way I can draw later the same object (the normal version) by culling the back faces instead,
	// so that it looks like to be over the black mesh. So first, I state that I want to cull the front faces; only the back faces will be drawn
    glCullFace (GL_FRONT);
    
    // Enabling writes to Z-buffer and the depth test, in case these weren't active
    glDepthMask(GL_TRUE); 
    glEnable(GL_DEPTH_TEST); 
    
    // Since I'm using a shader to create the black enlarged mesh, I first need to deactivate any shader of any objects in the room, otherwise they will interfere
    mFarWallMesh.ShaderActivate(false);
    mSideWallMesh.ShaderActivate(false);
    mRoofMesh.ShaderActivate(false);
    
    // For each child, I check if the child has a mesh (so if the child is a CVmObj linked to a mesh); if that's so, I deactivate the mesh's shader.
    // I need to check if there is a mesh since the child could be a Text, or things like that, that do not have a mesh linked
	foreach(var child in mChildren)
	{
		if(child.GetMesh() != Void)
			child.GetMesh().ShaderActivate(false);
	}
   
   // Starting the silhouette shader
    mSilhouetteShader.Start();
    	// Setting its parameter; the offset tells the shader how the size of the mesh has to increase
    	mSilhouetteShader.SetParameter("offset", 0.05 * SCALE_FACTOR);
    	mSilhouetteShader.SetParameter("color", [0.0, 0.0, 0.0]);
    	
    	// Drawing the silhouette of the room and of any objects in it
		mRoom.Draw();
	mSilhouetteShader.Stop();
	
	// Now I enable back faces culling, since I'm ready to draw the normal version of the room
	glCullFace (GL_BACK); 
	
	// I reactivate the shaders of any mesh in the room
	mFarWallMesh.ShaderActivate(true);
    mSideWallMesh.ShaderActivate(true);
    mRoofMesh.ShaderActivate(true);
    
    foreach(var child in mChildren)
	{
		if(child.GetMesh() != Void)
			child.GetMesh().ShaderActivate(true);
	}
	
	// And finally draw the room
	mRoom.Draw();
}

/*
 * Ausialiary method that adds lines that works as silhouette to a wall; the type can be 0 for front/back fwalls, 1 for side walls, 2 for roof/floor
 */
function Room::AddSilhouetteLines(wall, type)
{
	// Front/back wall
	switch(type)	
	{
		// Front/back wall
		case 0:
		{
			// I have to create objects both for front and back lines
			var farWallSilhouetteLineFront1 = CVmObj(mFarWallSilhouetteLineMesh);
			var farWallSilhouetteLineFront2 = CVmObj(mFarWallSilhouetteLineMesh);
			var heightSilhouetteLineFront1 = CVmObj(mHeightSilhouetteLineMesh);
			var heightSilhouetteLineFront2 = CVmObj(mHeightSilhouetteLineMesh);
			
			var farWallSilhouetteLineBack1 = CVmObj(mFarWallSilhouetteLineMesh);
			var farWallSilhouetteLineBack2 = CVmObj(mFarWallSilhouetteLineMesh);
			var heightSilhouetteLineBack1 = CVmObj(mHeightSilhouetteLineMesh);
			var heightSilhouetteLineBack2 = CVmObj(mHeightSilhouetteLineMesh);
			
			// Initially the plane is vertical, so I rotate it
			farWallSilhouetteLineFront1.Rotate(90, 0, 0, 1);
			farWallSilhouetteLineFront2.Rotate(90, 0, 0, 1);
			
			farWallSilhouetteLineBack1.Rotate(90, 0, 0, 1);
			farWallSilhouetteLineBack2.Rotate(90, 0, 0, 1);
			
			wall.AddChild(farWallSilhouetteLineFront1, mHalfFarWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, -0.01 * SCALE_FACTOR);
			wall.AddChild(farWallSilhouetteLineFront2, mHalfFarWidth - 0.01 * SCALE_FACTOR, mHalfHeight, -0.01 * SCALE_FACTOR);
			wall.AddChild(heightSilhouetteLineFront1, -mHalfFarWidth + 0.01 * SCALE_FACTOR, -mHalfHeight, -0.01 * SCALE_FACTOR);
			wall.AddChild(heightSilhouetteLineFront2, mHalfFarWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, -0.01 * SCALE_FACTOR);
			
//			wall.AddChild(farWallSilhouetteLineBack1, mHalfFarWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, 0.01 * SCALE_FACTOR);
//			wall.AddChild(farWallSilhouetteLineBack2, mHalfFarWidth - 0.01 * SCALE_FACTOR, mHalfHeight, 0.01 * SCALE_FACTOR);
//			wall.AddChild(heightSilhouetteLineBack1, -mHalfFarWidth + 0.01 * SCALE_FACTOR, -mHalfHeight, 0.01 * SCALE_FACTOR);
//			wall.AddChild(heightSilhouetteLineBack2, mHalfFarWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, 0.01 * SCALE_FACTOR);
			
			break;
		}
		// Sidewall
		case 1:
		{
			var sideWallSilhouetteLineFront1 = CVmObj(mSideWallSilhouetteLineMesh);
			var sideWallSilhouetteLineFront2 = CVmObj(mSideWallSilhouetteLineMesh);
			var heightSilhouetteLineFront1 = CVmObj(mHeightSilhouetteLineMesh);
			var heightSilhouetteLineFront2 = CVmObj(mHeightSilhouetteLineMesh);
			
			var sideWallSilhouetteLineBack1 = CVmObj(mSideWallSilhouetteLineMesh);
			var sideWallSilhouetteLineBack2 = CVmObj(mSideWallSilhouetteLineMesh);
			var heightSilhouetteLineBack1 = CVmObj(mHeightSilhouetteLineMesh);
			var heightSilhouetteLineBack2 = CVmObj(mHeightSilhouetteLineMesh);
			
			sideWallSilhouetteLineFront1.Rotate(90, 0, 0, 1);
			sideWallSilhouetteLineFront2.Rotate(90, 0, 0, 1);
			
			sideWallSilhouetteLineBack1.Rotate(90, 0, 0, 1);
			sideWallSilhouetteLineBack2.Rotate(90, 0, 0, 1);
			
			wall.AddChild(sideWallSilhouetteLineFront1, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, -0.01 * SCALE_FACTOR);
			wall.AddChild(sideWallSilhouetteLineFront2, mHalfSideWidth - 0.01 * SCALE_FACTOR , mHalfHeight, -0.01 * SCALE_FACTOR);
			wall.AddChild(heightSilhouetteLineFront1, -mHalfSideWidth + 0.01 * SCALE_FACTOR, -mHalfHeight, -0.01 * SCALE_FACTOR);
			wall.AddChild(heightSilhouetteLineFront2, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, -0.01 * SCALE_FACTOR);
			
//			wall.AddChild(sideWallSilhouetteLineBack1, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, 0.01 * SCALE_FACTOR);
//			wall.AddChild(sideWallSilhouetteLineBack2, mHalfSideWidth - 0.01 * SCALE_FACTOR, mHalfHeight, 0.01 * SCALE_FACTOR);
//			wall.AddChild(heightSilhouetteLineBack1, -mHalfSideWidth + 0.01 * SCALE_FACTOR, -mHalfHeight, 0.01 * SCALE_FACTOR);
//			wall.AddChild(heightSilhouetteLineBack2, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfHeight, 0.01 * SCALE_FACTOR);
			
			break;
		}
		// Roof/floor wall
		case 2:
		{
			var farWallSilhouetteLineFront1 = CVmObj(mFarWallSilhouetteLineMesh);
			var farWallSilhouetteLineFront2 = CVmObj(mFarWallSilhouetteLineMesh);
			var sideWallSilhouetteLineFront1 = CVmObj(mSideWallSilhouetteLineMesh);
			var sideWallSilhouetteLineFront2 = CVmObj(mSideWallSilhouetteLineMesh);
			
			var farWallSilhouetteLineBack1 = CVmObj(mFarWallSilhouetteLineMesh);
			var farWallSilhouetteLineBack2 = CVmObj(mFarWallSilhouetteLineMesh);
			var sideWallSilhouetteLineBack1 = CVmObj(mSideWallSilhouetteLineMesh);
			var sideWallSilhouetteLineBack2 = CVmObj(mSideWallSilhouetteLineMesh);
			
			farWallSilhouetteLineFront1.Rotate(90, 0, 0, 1);
			farWallSilhouetteLineFront2.Rotate(90, 0, 0, 1);
			
			farWallSilhouetteLineBack1.Rotate(90, 0, 0, 1);
			farWallSilhouetteLineBack2.Rotate(90, 0, 0, 1);
			
			wall.AddChild(farWallSilhouetteLineFront1, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfFarWidth, -0.01 * SCALE_FACTOR);
			wall.AddChild(farWallSilhouetteLineFront2, mHalfSideWidth - 0.01 * SCALE_FACTOR, mHalfFarWidth, -0.01 * SCALE_FACTOR);
			wall.AddChild(sideWallSilhouetteLineFront1, -mHalfSideWidth + 0.01 * SCALE_FACTOR, -mHalfFarWidth, -0.01 * SCALE_FACTOR);
			wall.AddChild(sideWallSilhouetteLineFront2, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfFarWidth, -0.01 * SCALE_FACTOR);
			
//			wall.AddChild(farWallSilhouetteLineBack1, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfFarWidth, 0.01 * SCALE_FACTOR);
//			wall.AddChild(farWallSilhouetteLineBack2, mHalfSideWidth - 0.01 * SCALE_FACTOR, mHalfFarWidth, 0.01 * SCALE_FACTOR);
//			wall.AddChild(sideWallSilhouetteLineBack1, -mHalfSideWidth + 0.01 * SCALE_FACTOR, -mHalfFarWidth, 0.01 * SCALE_FACTOR);
//			wall.AddChild(sideWallSilhouetteLineBack2, mHalfSideWidth - 0.01 * SCALE_FACTOR, -mHalfFarWidth, 0.01 * SCALE_FACTOR);
			
			break;
		}
	}
	
}

/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * 
 * The method returns:
 * -1 -> if no interception was found
 *  0 -> if it intercepts the floor
 *  1 -> if it intercepts the back wall
 *  2 -> if it intercepts the roof
 *  3 -> if it intercepts the left wall
 *  4 -> if it intercepts the right wall
 *  5 -> if it intercepts the front wall
 */
function Room::CheckIntersection(rayOrigin, rayEnd, contactPoint, normal)
{	
	// At first I state that no intersection was found
	var intersectedObject = -1;
	var contactPointTmp;
	var normalTmp;
	var planePoint;
	
	
	if(mHasFloor)
	{
		// To find the interception of a plane I first need one of its point: I get the coordinates of the floor first. Since it's a child of the mRoom object
		// I need to add its position (NOTE: this will work only if the room is NOT a child of something else); I then add 1 to make sure that
		// the plane is considered inside the room
		planePoint = mFloorObj.GetPosition() + GetPosition() + [0, 1 * SCALE_FACTOR, 0];
		
		// I compute the normal of the plane
		normalTmp = ComputeNormalOfPlanarObject(mFloorObj);
			
		// I check for interceptions
		contactPointTmp = FindIntersectionInPlane(rayOrigin, rayEnd, planePoint, normalTmp);
		
		// If one was found and it's inside the room (remember, planes are infinite, so maybe there was an interception but outside the room, so it's no good)
		// I return the 0 to indicate that
		if(contactPointTmp != Void && IsPointInRoom(contactPointTmp))
		{
			contactPointTmp -= [0, 1 * SCALE_FACTOR, 0];
			intersectedObject = 0;
			
			contactPoint = contactPointTmp;
			normal = normalTmp;
		}	
	}
		
		
	/* Back wall */
	planePoint = mBackWallObj.GetPosition() + GetPosition() + [0, 0, 1 * SCALE_FACTOR];
	normalTmp = ComputeNormalOfPlanarObject(mBackWallObj);
	
	contactPointTmp = FindIntersectionInPlane(rayOrigin, rayEnd, planePoint, normalTmp);
	
	if(contactPointTmp != Void && IsPointInRoom(contactPointTmp))
	{
		// Firt I remove the point I added in order to make sure that the plane point was in the room
		contactPointTmp -= [0, 0, 1 * SCALE_FACTOR];
		
		// If there was an intersection before and I found one in the rest of the elevator, I need to check which one "wins", i.e. which one
		// is closest to the player (in this case the origin of the ray)
		if(intersectedObject != -1)
		{
			var previousDistance = Modulus(contactPoint - rayOrigin);
			var currentDistance = Modulus(contactPointTmp - rayOrigin);
			
			// If the new distance is lesser, it wins
			if(currentDistance < previousDistance)
			{
				intersectedObject = 1;
				contactPoint = contactPointTmp;
				normal = normalTmp;
			}
		}
		// If before there was no intersection, I update the values with the current ones
		else
		{
			intersectedObject = 1;
			contactPoint = contactPointTmp;
			normal = normalTmp;
		}
	}
		
	/* Roof */
	planePoint = mRoofObj.GetPosition() + GetPosition() + [0, -1 * SCALE_FACTOR, 0];
	normalTmp = ComputeNormalOfPlanarObject(mRoofObj);
	
	contactPointTmp = FindIntersectionInPlane(rayOrigin, rayEnd, planePoint, normalTmp);
	
	if(contactPointTmp != Void && IsPointInRoom(contactPointTmp))
	{
		contactPointTmp -= [0, -1 * SCALE_FACTOR, 0];
		
		if(intersectedObject != -1)
		{
			var previousDistance = Modulus(contactPoint - rayOrigin);
			var currentDistance = Modulus(contactPointTmp - rayOrigin);
			
			if(currentDistance < previousDistance)
			{
				intersectedObject = 2;
				contactPoint = contactPointTmp;
				normal = normalTmp;
			}
		}
		else
		{
			intersectedObject = 2;
			contactPoint = contactPointTmp;
			normal = normalTmp;
		}
	}
		
	/* Left wall */
	planePoint = mLeftWallObj.GetPosition() + GetPosition() + [1 * SCALE_FACTOR, 0, 0];
	normalTmp = ComputeNormalOfPlanarObject(mLeftWallObj);
	
	contactPointTmp = FindIntersectionInPlane(rayOrigin, rayEnd, planePoint, normalTmp);
	
	if(contactPointTmp != Void && IsPointInRoom(contactPointTmp))
	{
		contactPointTmp -= [1 * SCALE_FACTOR, 0, 0];
		
		if(intersectedObject != -1)
		{
			var previousDistance = Modulus(contactPoint - rayOrigin);
			var currentDistance = Modulus(contactPointTmp - rayOrigin);
			
			if(currentDistance < previousDistance)
			{				
				intersectedObject = 3;
				contactPoint = contactPointTmp;
				normal = normalTmp;
			}
		}
		else
		{
			intersectedObject = 3;
			contactPoint = contactPointTmp;
			normal = normalTmp;
		}
	}
		
	/* Right wall */
	planePoint = mRightWallObj.GetPosition() + GetPosition() + [-1 * SCALE_FACTOR, 0, 0];
	normalTmp = ComputeNormalOfPlanarObject(mRightWallObj);
	
	contactPointTmp = FindIntersectionInPlane(rayOrigin, rayEnd, planePoint, normalTmp);
	
	if(contactPointTmp != Void && IsPointInRoom(contactPointTmp))
	{
		contactPointTmp -= [-1 * SCALE_FACTOR, 0, 0];
		
		if(intersectedObject != -1)
		{
			var previousDistance = Modulus(contactPoint - rayOrigin);
			var currentDistance = Modulus(contactPointTmp - rayOrigin);
			
			if(currentDistance < previousDistance)
			{
				intersectedObject = 4;
				contactPoint = contactPointTmp;
				normal = normalTmp;
			}
		}
		else
		{
			intersectedObject = 4;
			contactPoint = contactPointTmp;
			normal = normalTmp;
		}
	}
		
	/* Front wall */
	if(mHasFront)
	{
		planePoint = mFrontWallObj.GetPosition() + GetPosition() + [0, 0, -1 * SCALE_FACTOR];
		normalTmp = ComputeNormalOfPlanarObject(mFrontWallObj);
		
		contactPointTmp = FindIntersectionInPlane(rayOrigin, rayEnd, planePoint, normalTmp);
		
		if(contactPointTmp != Void && IsPointInRoom(contactPointTmp))
		{
			contactPointTmp -= [0, 0, -1 * SCALE_FACTOR];
			
			if(intersectedObject != -1)
			{
				var previousDistance = Modulus(contactPoint - rayOrigin);
				var currentDistance = Modulus(contactPointTmp - rayOrigin);
				
				if(currentDistance < previousDistance)
				{
					intersectedObject = 5;
					contactPoint = contactPointTmp;
					normal = normalTmp;
				}
			}
			else
			{
				intersectedObject = 5;
				contactPoint = contactPointTmp;
				normal = normalTmp;
			}
		}
	}
	
	return intersectedObject;
}

/*
 * This method checks whether the point passed as parameter is in the room or not
 * 
 * point: (vector) the point, in world coordinates
 */
function Room::IsPointInRoom(point)
{
	mLowerCornerWorld = mRoom.LocalToWorld(mLowerCornerPosition);
	mUpperCornerWorld = mRoom.LocalToWorld(mUpperCornerPosition);
	
	// I check if the point is in the bounding box, using the world coordinates. I'm also using little offset to account for the fact that 
	// the walls are not completely attached, so the bounding box is a little bit bigger
	return (point.x >= mLowerCornerWorld.x + 0.5 * SCALE_FACTOR && point.x <= mUpperCornerWorld.x - 0.5 * SCALE_FACTOR) &&
    	   (point.y >= mLowerCornerWorld.y + 0.5 * SCALE_FACTOR && point.y <= mUpperCornerWorld.y - 0.5 * SCALE_FACTOR) &&
       	   (point.z <= mLowerCornerWorld.z - 0.5 * SCALE_FACTOR && point.z >= mUpperCornerWorld.z + 0.5 * SCALE_FACTOR);


//	return (point.x >= mLowerCornerWorld.x - 0.5 && point.x <= mUpperCornerWorld.x + 0.5) &&
//    	   (point.y >= mLowerCornerWorld.y - 0.5 && point.y <= mUpperCornerWorld.y + 0.5) &&
//       	   (point.z <= mLowerCornerWorld.z + 0.5 && point.z >= mUpperCornerWorld.z - 0.5);
}

/*
 * Method that adds an object fo the room. Mind that the children are only useful for drawing, meaning that the Room object will 
 * only make sure to draw its children using the silhouette shader plus any shader they might have, nothing more
 */
function Room::AddObject(object, x, y, z)
{
	mRoom.AddChild(object, x, y, z);
	
	aadd(mChildren, object);
}


function Room::RemoveObject(object)
{
	mRoom.RemoveChild(object);
}

function Room::GetObj()
{
	return mRoom;
}

function Room::GetRoomWidth()
{
	return mFarWallWidth;
}

function Room::GetRoomDepth()
{
	return mSideWallWidth;
}

function Room::GetRoomHeight()
{
	return mRoomHeight;
}

function Room::SetLightsRange(min, max)
{
	mFarWallMesh.ShaderSetParameter(0, "lightsRangeMin", 0, min);
	mFarWallMesh.ShaderSetParameter(0, "lightsRangeMax", 0, max);
	mSideWallMesh.ShaderSetParameter(0, "lightsRangeMin", 0, min);
	mSideWallMesh.ShaderSetParameter(0, "lightsRangeMax", 0, max);
	mRoofMesh.ShaderSetParameter(0, "lightsRangeMin", 0, min);
	mRoofMesh.ShaderSetParameter(0, "lightsRangeMax", 0, max);
	
	foreach(var child in mChildren)
	{
		if(child.GetMesh() != Void)
		{
			child.GetMesh().ShaderSetParameter(0, "lightsRangeMin", 0, min);
			child.GetMesh().ShaderSetParameter(0, "lightsRangeMax", 0, max);
		}
	}
	
	mLightsRangeMin = min;
	mLightsRangeMax = max;
}

function Room::GetLightsRange()
{
	return [mLightsRangeMin, mLightsRangeMax];
}

function Room::SetPosition(position)
{
	mRoom.SetPosition(position);
}

function Room::Translate(x, y, z)
{
	mRoom.Translate(x, y, z);
}

function Room::Rotate(angle, x, y, z)
{
	mRoom.Rotate(angle, x, y, z);
}


function Room::GetPosition()
{
	return mRoom.GetPosition();
}


function Room::LocalToWorld(point)
{
	return mRoom.LocalToWorld(point);
}

function Room::Hide()
{
	return mRoom.Hide();
}

function Room::Unhide()
{
	return mRoom.Unhide();
}
