
#define STATUS_ELEVATOR_MOVING 0
#define STATUS_ELEVATOR_ARRIVED 1
#define STATUS_LEVEL_STARTED 2

class Level1
{
	var mIsVRon;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	
	// "Room" object that contains the whole room
	var mMainRoom;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
	
	// "Room" object that represent the elevator
	var mElevator;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;
	
	var mOpenglTranslationOffset;
	
	
	var mDrawingShader;
	var mPreviousPoint;
	var mLineArray;	
	
	var mTime;
	var mReversedTime;
	var mVertexArray;
	
	var mController1;
	var mController2;
	
	var mControllerBeingUsedIndex;
	
	// Private functions
	DrawAllPortals();
	DrawPortal(portalFrame, portalRoom);
	FadeToBlackScreen(fadeIn);
	
	intersect3D_SegmentPlane( p0, p1, v0, normal);
	
	Selection(object);
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	GetElevator();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	SetOpenglTransformOffset(mOpenglTranslationOffset);
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function Level1::Level1(isVRon, inputManager, soundManager)
{		
	mIsVRon = isVRon;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	
	mLineArray = {};
		
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH, ROOM_SIDE_WALL_WIDTH, ROOM_HEIGHT, true, true, 1, 2);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
		

	mDrawingShader = CVmShaderProgram("drawingShader.glsl");

	mTime = 0;
	mReversedTime = 0;
	
	
	var base = CVmNewMesh(VRP_BOX, 3, [0, 0, 0], [2.0, 0.2, 0], 2.0);  
	var column = CVmNewMesh(VRP_CYLINDER, 30, 0.8, 5, 1);  
	var neck = CVmNewMesh(VRP_CONEFRUSTUM, 30, 0.3, 0.8, 0.8, 1);  
	
	var baseObj = CVmObj(base);
	var columnObj = CVmObj(column);
	var neckObj = CVmObj(neck);
	
	global var mesh = CVmNewMesh("Sci-fi-thing.aam");
//	mesh.CenterBoundingBox();

	var mat = CVmMaterial();
	mat.diffuse = [1.0, 1.0, 0.0];
	mat.ambient = [0.0, 0.0, 1.0];
	mat.specular = [0.0, 1.0, 0.0];
	
//	mesh.SubsetForceMaterial(1, mat);
	mat.diffuse = [0.0, 1.0, 0.0];
//	mesh.SubsetForceMaterial(2, mat);
//	mat.diffuse = [0.0, 0.0, 1.0];
	mesh.SubsetSetMaterial(0, mat);
	
	global var obj = CVmObj(mesh);
//	obj.AddChild(baseObj, 0, 0, 0);
//	obj.AddChild(columnObj, 2.0 / 2.0, 0.2, -1.0);
//	obj.AddChild(neckObj, 2.0 / 2.0, 0.2 + 5, -1.0);
	
	obj.SetPosition(0, 3, 5);	
	
	mControllerBeingUsedIndex = 0;
	
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}


 
 function Level1::Init(lights, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
	
	mLight0 = lights[0];
	mLight0.SetPosition([-10.0, 10.0, 10.0] + [0, -100, 0] + mOpenglTranslationOffset);
	mLight0.SetDiffuse(1, 1, 1);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetPosition([0, 10.0, 10.0] + mOpenglTranslationOffset);
	mLight1.SetDiffuse(1, 1, 1);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition([0, 10.0, -20.0] + mOpenglTranslationOffset);
	mLight2.SetDiffuse(1, 1, 1);
	mLight2.Enable();
	
		
	mElevator = elevator;
	mElevator.SetLightsRange(0,0);
	
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();


	
	mEnding = false;
	mIsLevelCompleted = false;
	
	mElevatorTravelDistance = 100.0;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 1.5;
	
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	var lightPos = mLight1.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
	
	mCameraYoffset = mCamera.GetPosition().y - mOpenglTranslationOffset.y - mElevatorFinalPosition.y;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
	
	mVertexArray = {};
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */


/*
 * Render method
 */
function Level1::Render()
{	
	// If the user teleported modifying the mOpenglTranslationOffset, the lights will be in the wrong places. So at each frame I reset their 
	// position according to the offset
	mLight1.SetPosition([0, 10.0, 35.0] + mOpenglTranslationOffset);
	mLight2.SetPosition([0, 10.0, -20.0] + mOpenglTranslationOffset);

	// This array will contain at position 2 the width of the viewport, and at 3 its height
	var viewport = array(4);
	viewport = glget(GL_VIEWPORT);
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_STARTED:
		{
			mMainRoom.Draw();

//			if(mTime % 1.0 <= 0.01 && mReversedTime <= 0)
//				mReversedTime = 1;
//			
//			if(mReversedTime > 0)
//			{
//				glLineWidth(10 * (mReversedTime));
//				outputln("yo");
//				mReversedTime -= 0.005;
//			}
//			else
//				glLineWidth(10 * (mTime % 1.0));
			
			glLineWidth(5);
			
			mDrawingShader.Start();
//				mDrawingShader.SetParameter("screenWidth", viewport[2]);
//				mDrawingShader.SetParameter("screenHeight", viewport[3]);		
				mDrawingShader.SetParameter("time", mTime);

				for(var i = 0; i < len(mVertexArray); i += 2)
				{
					var point0 = mVertexArray[i];
					var point1 = mVertexArray[i+1];
					
					glBegin(GL_LINES);
						glVertex(point0);
						glVertex(point1);		
					glEnd();
				}
			
			mDrawingShader.Stop();

//			mDrawingShader.Start();
//				mDrawingShader.SetParameter("screenWidth", viewport[2]);
//				mDrawingShader.SetParameter("screenHeight", viewport[3]);
//				
//				foreach(var line in mLineArray)
//				{
//					mDrawingShader.SetParameter("time", mTime);
//					line.Draw();
//					
//				}
//			mDrawingShader.Stop();
			
			obj.Draw();
			

			mTime += 0.01;
			
			break;
			
		}
	}
	
			var rayO = mCamera.GetPosition() - mOpenglTranslationOffset;
			var rayE = mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 900;
			
			var contactPoint;
			var contactNormal;
			var triangleID;
			
			if(obj.IsColliding(rayO, rayE, &contactPoint, &contactNormal, &triangleId))
			{
				var string;
				outputln(mesh.GetSubsetFromTriIndex (triangleID, &string));
//				outputln(obj.Inspect(obj.LocalToWorld([0, 1, 0])));
//				outputln(obj.Inspect(obj.LocalToWorld([-3.74, 7, 1.8])));
				
//				outputln(mCamera.GetPosition() - mOpenglTranslationOffset);
			}
	
	// The elevator is always present, so it's always drawn
	mElevator.Draw();
	
	if(mIsVRon)
	{
		mController1.Draw();
		mController2.Draw();
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level1::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		case STATUS_ELEVATOR_MOVING: 
		{			
			
		    // I make sure that the camera doesn't go out of the elevator while it's going up
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();
	
			// I check if the elevator is halfway through the transtition; if this is the case, I change its lights range for the rendering (but only
			// if I didn't do so already)
			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2 && mElevator.GetLightsRange().y < 1)
				 mElevator.SetLightsRange(1,2);
			
			// I make sure that the camera goes up with the elevator by increasing the y along with the elevator's
			cameraPosition.y = mCameraYoffset + elevatorPos.y;
	   	    
			// To make the shaking camera effect, I randomly move the x and y axis with random values
		    cameraPosition.y += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
		    cameraPosition.x += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
			
			// I set the new (shaken and at level with the elevator) position
			mCamera.SetPosition(cameraPosition + mOpenglTranslationOffset);
			
			// I check if the elevator reached its destination, and if this is so I open the door and change status
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
			}
	
			break;
		}		
		// This is the case where the elevator arrived, BUT the player is still inside
		case STATUS_ELEVATOR_ARRIVED:
		{
			// I check if the player goes out from the elevator. Note: I'm not checking that he exits from the doors; he can pass through walls right now.
			// If the player comes out, I close the doors and change status
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{
			// I make sure that the player stay's inside the room and outside of the elevator
			if(!mIsVRon && mElevator.IsPointInElevator(cameraPosition) || !mMainRoom.IsPointInRoom(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
		    	
		    	
	    	var usingController1 = mInputManager.IsPressingPrimaryButton(1);
			var usingController2 = mInputManager.IsPressingPrimaryButton(2);
			
			var firstTimeUsingController = (usingController1 || usingController2) && mControllerBeingUsedIndex == 0;
			var wasUsingController1 = (usingController1 && mControllerBeingUsedIndex == 1);
			var wasUsingController2 = (usingController2 && mControllerBeingUsedIndex == 2);
				 
			// I check if the user has clicked with the mouse or whatever; if that is the case I need to check "where" he clicked    	
	    	if(firstTimeUsingController || wasUsingController1 || wasUsingController2)
			{				
				if(firstTimeUsingController)
				{
					mControllerBeingUsedIndex = usingController1 ? 1 : 2;
					
	    			mPreviousPoint = mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3;
	    			mLineArray = {};
	    			mVertexArray = {};
				}
	    		else
	    		{
	    			var currentPoint;
	    			
	    			if(mIsVRon)
    					currentPoint = mInputManager.GetController(mControllerBeingUsedIndex).GetControllerTipCoordinates();
    				else
	    				currentPoint = mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3;
								
					// Taking the direction that goes from the previous point to the current one. Note that the order of the difference is important:
					// I need the direction that goes from the previous point to the current one
					var vec = Norm(mPreviousPoint - currentPoint);
					
					// To compute the angle around which to rotate the object, I compute the cross product between this vector and the up vector (the vector
					// that tells me which way is up); the result will be a vector perpendicular to the 2, which I normalize to use it as a normal.
					// I then switch sign, otherwise it turns on the opposite side
					var axis = -Norm(vec ^ [0, 1, 0]);
					
					// I now compute the angle for the rotation. The formula derives from "easy" trigonometry (lookup "finding angle between 2 vectors").
					// I'm not sure why the final angle is shifted by 180 degrees; that's why I subtract 180
					var angle = acos((Norm(vec) * [0, 1, 0])) * RAD_TO_GRAD - 180; 
				
					// Creating the new mesh, a very thin box, as tall as the distance between the 2 points
					var stickMesh = CVmNewMesh(VRP_BOX, 0, [0.0, 0.0, 0.0], [0.003, Modulus(currentPoint - mPreviousPoint), 0.001]); 
					var line = CVmObj(stickMesh);
					
					// Since the center of the box is at its feet, moving it at the coordinates of the previous point and then applying the rotation works perfectly
					line.SetPosition(mPreviousPoint);
					line.SetRotation(angle, axis.x, axis.y, axis.z);
					
					// Adding the 2 points to the array for drawing lines with simple opengl
					aadd(mVertexArray, mPreviousPoint);
					aadd(mVertexArray, currentPoint);
					
					// Adding the new mesh to the aray, to draw it in the render function
					aadd(mLineArray, line);
					
					mPreviousPoint = currentPoint;
	    		}
    		}
    		else
    			mControllerBeingUsedIndex = 0;
	    		
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}


/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level1::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	if(intersectedPlane == -1)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	isWall = true;
	
	return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level1::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level1::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

