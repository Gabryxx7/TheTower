
#define STATUS_ELEVATOR_MOVING 0
#define STATUS_ELEVATOR_ARRIVED 1
#define STATUS_LEVEL_STARTED 2

class Level1
{
	var mIsVRon;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	
	// "Room" object that contains the whole room
	var mMainRoom;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
	
	// "Room" object that represent the elevator
	var mElevator;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;
	
	var mOpenglTranslationOffset;
	
	var mIsDrawing;
	
	var mDrawingShader;
	var mPreviousPoint;
	var mLineArray;	
	
	var mTime;
	var mReversedTime;
		
	var mDrawingsArray;
	var mDrawingsAlphaArray;
	var mIsDrawingConnectedArray;
	
	var mDrawingsAlpha;
	
	var mController1;
	var mController2;
	
	var mControllerBeingUsedIndex;
	
	var mIsControllerInLight;
	
	var mConnectors;
	
	var mStartingConnectorsArray;
	
	var mStartingActiveConnector;
	var mCurrentActiveConnector;
	var mGoodStartingPoint;
	
	
	var mEverythingIsConnectedText;
	
	// Private functions
	DrawAllPortals();
	DrawPortal(portalFrame, portalRoom);
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	GetElevator();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	SetupOpenglLights();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function Level1::Level1(isVRon, inputManager, soundManager)
{		
	mIsVRon = isVRon;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	
	mLineArray = {};
	
	mIsDrawing = false;
	mGoodStartingPoint = false;
		
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH - 25 * SCALE_FACTOR, ROOM_SIDE_WALL_WIDTH - 10 * SCALE_FACTOR, ROOM_HEIGHT, true, true, 1, 2);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
		

	mDrawingShader = CVmShaderProgram("drawingShader.glsl");

	mTime = 0;
	mReversedTime = 0;
	
	var offsetFromFarWall = mMainRoom.GetRoomDepth()/2 - 15.0 * SCALE_FACTOR;
	var offset = 10 * SCALE_FACTOR;
	
	var connector1 = DrawingsConnector([1.0, 0, 0], 1, 2);
	connector1.SetPosition([-offset, 0, offsetFromFarWall]);
	connector1.Rotate(85, 0, 1, 0);
	
	var connector2 = DrawingsConnector([0, 0, 1], 1, 2);
	connector2.SetPosition([offset, 0, offsetFromFarWall]);
	connector2.Rotate(135, 0, 1, 0);
	
	connector1.SetLinkedConnector(connector2);
	connector2.SetLinkedConnector(connector1);
	
	
	var offsetFromSideWall = mMainRoom.GetRoomWidth()/2.0 - 10 * SCALE_FACTOR;
	offset -= 3 * SCALE_FACTOR;
	
	var connector3 = DrawingsConnector([1.0, 1.0, 0], 1, 2);
	connector3.SetPosition([offsetFromSideWall, 0, offset]);
	connector3.Rotate(85 * 2, 0, 1, 0);
	
	var connector4 = DrawingsConnector([0, 1.0, 1.0], 1, 2);
	connector4.SetPosition([offsetFromSideWall, 0, -offset]);
	connector4.Rotate(115 * 2, 0, 1, 0);
	
	connector3.SetLinkedConnector(connector4);
	connector4.SetLinkedConnector(connector3);
	
	
	var connector5 = DrawingsConnector([1.0, 0.0, 1.0], 1, 2);
	connector5.SetPosition([-offsetFromSideWall, 0, offset]);
	connector5.Rotate(85 * 2 - 90, 0, 1, 0);
	
	var connector6 = DrawingsConnector([0, 1.0, 0.6], 1, 2);
	connector6.SetPosition([-offsetFromSideWall, 0, -offset]);
	connector6.Rotate(115 * 2 - 90, 0, 1, 0);
	
	connector5.SetLinkedConnector(connector6);
	connector6.SetLinkedConnector(connector5);
	
	mConnectors = {};
	
	aadd(mConnectors, connector1);
	aadd(mConnectors, connector2);
	aadd(mConnectors, connector3);
	aadd(mConnectors, connector4);
	aadd(mConnectors, connector5);
	aadd(mConnectors, connector6);
	
	
	mControllerBeingUsedIndex = 0;
	
	global var control = ViveController();
	global var controllerHidden = true;
	control.SetRotation(90, 0, 1, 0);
	control.Hide();
	
	mIsControllerInLight = false;
		
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
	
	mDrawingsAlpha = 0;
	
	mDrawingsArray = {};
	mDrawingsAlphaArray = {};
	mIsDrawingConnectedArray = {};
	mStartingConnectorsArray = {};
	
	mEverythingIsConnectedText = Text("In life, everything is connected", 2);
	mEverythingIsConnectedText.SetPosition([0, 7.0 * SCALE_FACTOR, mMainRoom.GetRoomDepth()/2 - 0.1 * SCALE_FACTOR]);
	mEverythingIsConnectedText.Rotate(180, 0, 1, 0);
}


 
 function Level1::Init(lights, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Position = [-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + [0, -100 * SCALE_FACTOR, 0];
	mLight1Position = [0, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR];
	mLight2Position = [0, 10.0 * SCALE_FACTOR, -20.0 * SCALE_FACTOR];
	
	mLight0 = lights[0];
	mLight0.SetPosition(mLight0Position);
	mLight0.SetDiffuse(1, 1, 1);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetPosition(mLight1Position);
	mLight1.SetDiffuse(1, 1, 1);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition(mLight2Position);
	mLight2.SetDiffuse(1, 1, 1);
	mLight2.Enable();
	
		
	mElevator = elevator;
	mElevator.SetLightsRange(0,0);
	
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();


	
	mEnding = false;
	mIsLevelCompleted = false;
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 1.5;
	
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	var lightPos = mLight1.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
	
	mCameraYoffset = mCamera.GetPosition().y - mOpenglTranslationOffset.y - mElevatorFinalPosition.y;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */


/*
 * Render method
 */
function Level1::Render()
{	
	// If the user teleported modifying the mOpenglTranslationOffset, the lights will be in the wrong places. So at each frame I reset their 
	// position, but note that I'm not setting the position acoordint to the offset: since in the GameManager the offset was used for the glTranslate(), at
	// this point the world is already moved, and since I'm moving the light directly with opengl (so that the effect can be seen also with the Vive),
	// I don't need to add the offset to the position, it's already taken care of
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
	
	// I put the controller in front of the camera, for the debugging purposes
	control.SetPosition(mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR);
	
	if(KeyPressed("M"))
	{
		if(controllerHidden)
			control.Unhide();
		else
			control.Hide();
			
		controllerHidden = !controllerHidden;
	}
	
		
	// The elevator is always present, so it's always drawn
	mElevator.Draw();
		
	if(mIsVRon)
	{
		mController1.Draw();
		mController2.Draw();
	}
	
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_STARTED:
		{
			mMainRoom.Draw();

			glLineWidth(5);
			
			mDrawingShader.Start();	
				mDrawingShader.SetParameter("time", mTime);

				// I iterate over all drawings
				for(var i = 0; i < len(mDrawingsArray); i++)
				{
					// I get the vertices and alpha value for the current drawing
					var vertexArray = mDrawingsArray[i];

					// Depending on the kind of line we have to pass different things to the shader. This is the case that the line is "connected" to the connectors.
					if(mIsDrawingConnectedArray[i])
					{
						var startingConnector = mStartingConnectorsArray[i];
						var linkedConnector = startingConnector.GetLinkedConnector();
						
						mDrawingShader.SetParameter("lineIsConnected", true);
						mDrawingShader.SetParameter("startColor", startingConnector.GetDefaultLightColor());
						mDrawingShader.SetParameter("finalColor", linkedConnector.GetDefaultLightColor());
						mDrawingShader.SetParameter("startPoint", startingConnector.GetPosition());
						mDrawingShader.SetParameter("endPoint", linkedConnector.GetPosition());
					}
					else
					{
						var alpha = mDrawingsAlphaArray[i];
						mDrawingShader.SetParameter("alpha", alpha);
						mDrawingShader.SetParameter("lineIsConnected", false);
					}
					
					// I iterate over all vertices, two by two: the first one is the starting point of a single line, the second one is the end point
					for(var i = 0; i < len(vertexArray); i += 2)
					{
						var point0 = vertexArray[i];
						var point1 = vertexArray[i+1];
						
						glBegin(GL_LINES);
							glVertex(point0);
							glVertex(point1);		
						glEnd();
					}
				}
			
			mDrawingShader.Stop();
			
			mEverythingIsConnectedText.Draw();
			
			control.Draw();
		
			mTime += 0.01;
			
			// I update the time variable (used for the shader) of the connectors and draw them; note: I only draw the connector object now, without the
			// light cones. This is because the light cones are transparent and need to be drawn last in the scene, otherwise the transparency would be wrong
			foreach(var connector in mConnectors)
			{
				connector.UpdateTimeVariable();
				connector.Draw();
			}
			
			// To draw the light cones I disable writing into the Z-buffer: they only need to read from it
			glDepthMask(GL_FALSE); 
			
			// Now I draw the light cones
			foreach(var connector in mConnectors)
				connector.DrawLightCone(false);
			
			// Restore the depth buffer as it was
			glDepthMask(GL_TRUE); 

			break;
		}
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level1::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		case STATUS_ELEVATOR_MOVING: 
		{			
			
		    // I make sure that the camera doesn't go out of the elevator while it's going up
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();
	
			// I check if the elevator is halfway through the transtition; if this is the case, I change its lights range for the rendering (but only
			// if I didn't do so already)
			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2.0 && mElevator.GetLightsRange().y < 1)
				 mElevator.SetLightsRange(1,2);
			
			// I make sure that the camera goes up with the elevator by increasing the y along with the elevator's
			cameraPosition.y = mCameraYoffset + elevatorPos.y;
	   	    
			// To make the shaking camera effect, I randomly move the x and y axis with random values
		    cameraPosition.y += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
		    cameraPosition.x += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
			
			// I set the new (shaken and at level with the elevator) position
			mCamera.SetPosition(cameraPosition + mOpenglTranslationOffset);
			
			// I check if the elevator reached its destination, and if this is so I open the door and change status
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
			}
	
			break;
		}		
		// This is the case where the elevator arrived, BUT the player is still inside
		case STATUS_ELEVATOR_ARRIVED:
		{
			// I check if the player goes out from the elevator. Note: I'm not checking that he exits from the doors; he can pass through walls right now.
			// If the player comes out, I close the doors and change status
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{
			// I make sure that the player stay's inside the room and outside of the elevator
			if(!mIsVRon && mElevator.IsPointInElevator(cameraPosition) || !mMainRoom.IsPointInRoom(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
		    	
			// Now I check whether there is a controller inside the light cone of a connector, in order to change its light. There are a lot of cases to consider,
			// because controllers can get in and out of light cones, and depending on whether the player is drawing while doing it changes everything	
			foreach(var connector in mConnectors)
	    	{
	    		// This is the case where a controller goes inside the light the first time; I need to change the light only if:
	    		// 1) this connector is not connected to another one already (in this case I have to leave the "active" color);
	    		// 2) if the player is drawing, this connector IS NOT the starting connector (i.e. the connector where he started to draw);
	    		// 3) there is actually a controller in the light cone;
	    		// 4) the controller wasn't here before 
				if(!connector.IsConnected() && connector != mStartingActiveConnector && connector.IsObjectInCone(control.GetObj()) && !mIsControllerInLight)
				{
					connector.SetLightColorActive();
					mIsControllerInLight = true;
					mCurrentActiveConnector = connector;
				}
				// If it's not the case above, maybe the controller has just left the light cone and its color need to change back to what it was.
				// I need to to this if:
				// 1) this connector is not connected to another one already;
				// 2) this connector was the one currently active;
				// 3) there actually was a controller inside;
				// 4) now the controller isn't inside anymore
				else if(!connector.IsConnected() && connector == mCurrentActiveConnector && mIsControllerInLight  && !connector.IsObjectInCone(control.GetObj()))
				{
					// If the current connector wasn't the starting connector while drawing, I reset the light color, otherwise I simply change variables
					// to state the fact that there is no controller inside any connector now.
					// Basically, this is the case when the player has started drawing inside a connector, moved to another one and went in and out of this connector,
					// but didn't stop drawing. In this case we have to behave like he wasn't drawing, i.e. reseting the color. Otherwise, if the player
					// while drawing goes in and out of the starting connector, the light always need to be in the "active" state
					if(mCurrentActiveConnector != mStartingActiveConnector)
						connector.ResetLightColor();
					
					mIsControllerInLight = false;
					mCurrentActiveConnector = Void;
				}
	    	}

		    	
	    	var usingController1 = mInputManager.IsPressingPrimaryButton(1);
			var usingController2 = mInputManager.IsPressingPrimaryButton(2);
			
			var firstTimeUsingController = (usingController1 || usingController2) && mControllerBeingUsedIndex == 0;
			var wasUsingController1 = (usingController1 && mControllerBeingUsedIndex == 1);
			var wasUsingController2 = (usingController2 && mControllerBeingUsedIndex == 2);
				 
			// I check if the user has clicked with the mouse or whatever; if that is the case I need to check "where" he clicked    	
	    	if(firstTimeUsingController || wasUsingController1 || wasUsingController2)
			{				
				// If it's the first time, I need to do some things
				if(firstTimeUsingController)
				{
					// I save the index of the controller used and save the fact that the player is drawing
					mControllerBeingUsedIndex = usingController1 ? 1 : 2;
					mIsDrawing = true;
					
					// I get the first point in the drawing
	    			mPreviousPoint = mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR;
	    			
	    			var vertexArray = {};
	    			
	    			// I add an empty array to the drawings array; it will be filled with every point as soon as they are found
	    			aadd(mDrawingsArray, vertexArray);
	    			
	    			// I also set the alpha value of the drawing to 1
	    			aadd(mDrawingsAlphaArray, 1.0);
	    			
	    			
	    			// If the player's controller was inside a connector, then mCurrentActiveConnector is not void. In that case, 
	    			// this drawing is a potential "connected" drawing
	    			if(mCurrentActiveConnector != Void)
	    			{
	    				// I state that this line is connected; I don't know for sure, but it's starting in the right place, so I give it the 
	    				// benefit of the doubt. If later I find out that it's not connected, I'll change this boolean to false
	    				aadd(mIsDrawingConnectedArray, true);
	    				
	    				mGoodStartingPoint = true;
	    				mStartingActiveConnector = mCurrentActiveConnector;
	    				aadd(mStartingConnectorsArray, mCurrentActiveConnector);
    				}
    				else
    				{
    					// If it's a random drawing, I state that it's not "connected", and put Void as starting connector to indicate that there is none 
    					// (I need it as a placeholder, so that every array always has the same size; it keeps things easier)
    					aadd(mIsDrawingConnectedArray, false);
    					aadd(mStartingConnectorsArray, Void);
					}
				}
	    		else
	    		{
	    			var currentPoint;
	    			
	    			if(mIsVRon)
    					currentPoint = mInputManager.GetController(mControllerBeingUsedIndex).GetControllerTipCoordinates();
    				else
	    				currentPoint = mCamera.GetPosition() - mOpenglTranslationOffset + mCamera.GetDirection() * 3 * SCALE_FACTOR;
							
					// I obtain from the array of drawings the last one, which is the drawing the player is creating now
					var vertexArray = mDrawingsArray[len(mDrawingsArray) - 1];
					
					// I add the points to the array
					aadd(vertexArray, mPreviousPoint);
					aadd(vertexArray, currentPoint);
					
					mPreviousPoint = currentPoint;
				/*	
				    THE CODE BELOW IS NOT USED ANYMORE.
				    Since it took me hours to figure out how to align an object in the direction of a vector, I keep this code for future reference;
				    it might come in handy.

					// Taking the direction that goes from the previous point to the current one. Note that the order of the difference is important:
					// I need the direction that goes from the previous point to the current one
					var vec = Norm(mPreviousPoint - currentPoint);
					
					// To compute the angle around which to rotate the object, I compute the cross product between this vector and the up vector (the vector
					// that tells me which way is up); the result will be a vector perpendicular to the 2, which I normalize to use it as a normal.
					// I then switch sign, otherwise it turns on the opposite side
					var axis = -Norm(vec ^ [0, 1, 0]);
					
					// I now compute the angle for the rotation. The formula derives from "easy" trigonometry (lookup "finding angle between 2 vectors").
					// I'm not sure why the final angle is shifted by 180 degrees; that's why I subtract 180
					var angle = acos((Norm(vec) * [0, 1, 0])) * RAD_TO_GRAD - 180; 
				
					// Creating the new mesh, a very thin box, as tall as the distance between the 2 points
					var stickMesh = CVmNewMesh(VRP_BOX, 0, [0.0, 0.0, 0.0], [0.003 * SCALE_FACTOR, Modulus(currentPoint - mPreviousPoint), 0.001 * SCALE_FACTOR]); 
					var line = CVmObj(stickMesh);
					
					// Since the center of the box is at its feet, moving it at the coordinates of the previous point and then applying the rotation works perfectly
					line.SetPosition(mPreviousPoint);
					line.SetRotation(angle, axis.x, axis.y, axis.z);
					
					// Adding the new mesh to the array, to draw it in the render function
					aadd(mLineArray, line);
				*/
	    		}
    		}
    		
    		else
    		{
    			// If the user was drawing until now, I need to check where he stopped
    			if(mControllerBeingUsedIndex != 0)
    			{
    				// The first thing I do is reset the index of the controller being used: no controller is being used now
    				mControllerBeingUsedIndex = 0;
    				
    				// The player is not drawing anymore
    				mIsDrawing = false;
    				
    				// If the player ended the drawing inside a light cone, if it's not connected already and he started in the right spot (i.e. inside
    				// another connector), we might have a good line (i.e. a line that we don't have to erase)
    				if(mCurrentActiveConnector != Void && !mCurrentActiveConnector.IsConnected() && mGoodStartingPoint)
    				{
    					// If the connector linked to the starting connector (i.e. the connector where the player started drawing) is indeed this one,
    					// we have a good line
    					if(mStartingActiveConnector.GetLinkedConnector() == mCurrentActiveConnector)
    					{
    						// I state that these connectors are now actually "connected"
    						mStartingActiveConnector.SetIsConnected(true);
    						mCurrentActiveConnector.SetIsConnected(true);
    						
    						// I reset the variables and set that the controller isn't in the light (even though it is, otherwise it will never be considered out)
    						mStartingActiveConnector = Void;
    						mCurrentActiveConnector = Void;
    						mIsControllerInLight = false;
    					}
    					// Otherwise, I state that this line is no good and needs to be erased soon; also, I reset the color of the starting connector
    					// (because if I reached this code I'm sure that there was a starting connector)
    					else
    					{
							mIsDrawingConnectedArray[len(mIsDrawingConnectedArray) - 1] = false;
    						mStartingActiveConnector.ResetLightColor();
						}
    				}	
    				// If the drawing was totally random and didn't start in any connector or didn't finish in one, the line is no good
    				else
    				{    					
    					// If the user started inside the connector, I set that the line isn't actually connected, I reset the light of that one, and reset the variable
    					if(mStartingActiveConnector != Void)
						{
							mIsDrawingConnectedArray[len(mIsDrawingConnectedArray) - 1] = false;
							mStartingActiveConnector.ResetLightColor();
							mStartingActiveConnector = Void;
						}
					}
    					
					// In any case, I reset the boolean
					mGoodStartingPoint = false;
    			}
    			
    		}
    		
			// For any lines drawn in the past I decrease its alpha values. Since I'm going to remove objects from the arrays while iterating (when the alpha
			// value reaches 0) I'm starting from the last element, going backwards. Also, if the user is currently drawing I skip the last one, which
			// is the drawing that the user is currently creating, so I don't have to check it
    		var startingPoint = mIsDrawing ? len(mDrawingsAlphaArray) - 2 : len(mDrawingsAlphaArray) - 1;
    			
			for(var i = startingPoint; i >= 0; i--)
			{
				// I only procede if this current drawing isn't "connected", i.e. a line that is connected between 2 connectors; 
				// in that case the line needs to stay visible always
				if(!mIsDrawingConnectedArray[i])
				{
					// If the alpha value of the current drawing is greater than 0, I decrease it; if it reaches 0, I remove the drawing and its alpha from the arrays
					if(mDrawingsAlphaArray[i] > 0)
						mDrawingsAlphaArray[i] -= 0.01;
					else
					{
						adel(mDrawingsArray, i);
						adel(mDrawingsAlphaArray, i);
						adel(mIsDrawingConnectedArray, i);
						adel(mStartingConnectorsArray, i);
					}
				}
			}
	    		
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}


/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level1::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	if(intersectedPlane == -1)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	isWall = true;
	
	return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level1::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level1::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

function Level1::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, [1, 1, 1]); 
	glLight(GL_LIGHT1, GL_DIFFUSE, [1, 1, 1]); 
	glLight(GL_LIGHT2, GL_DIFFUSE, [1, 1, 1]);
}
