
#define STATUS_ELEVATOR_MOVING 0
#define STATUS_ELEVATOR_ARRIVED 1
#define STATUS_LEVEL_STARTED 2

// The multiplier used to speedup the objects when the player uses the clock
#define TIME_CLOCK_VELOCITY_MULTIPLIER 3.0

#include <Clock.s3d>

class Level3
{
	var mIsVRon;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	
	// "Room" object that contains the whole room
	var mMainRoom;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
	
	// Booleans that indicate whether the elevator has appeared and if it's already open or not
	var mIsElevatorPresent;
	var mIsElevatorOpen;
	
	// "Room" object that represent the elevator
	var mElevator;
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;
	
	
	var mIsUsingClock;
	
	var mMainClock;
	var mTimeDirection;
	
	
	var mClocks;
	var mNumberOfClocks;
	var mNumberOfClockRows;
	
	var mOpenglTranslationOffset;
	
	var mController1;
	var mController2;
	
	var mFrontText;
	
	var mStarObjects;
	
	// Private functions
	CreateStarThing();
	CreateCylinderThing();
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	SetupOpenglLights();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function Level3::Level3(isVRon, inputManager, soundManager)
{		
	mIsVRon = isVRon;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	
		
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH, ROOM_SIDE_WALL_WIDTH, ROOM_HEIGHT, true, 1, 2);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
		

	mMainClock = Clock(1, 2);
	mMainClock.Translate(0, 5 * SCALE_FACTOR, 14 * SCALE_FACTOR);

	// Initially the time runs forward
	mTimeDirection = 1;
	
		
	// Creating texts object for the scene
	mFrontText = Text("Time is relative", 2.0);
	mFrontText.Rotate(180, 0, 1, 0);
	var textPos = [2 * SCALE_FACTOR, 8.0 * SCALE_FACTOR, mMainRoom.GetRoomDepth()/2.0 - 0.1 * SCALE_FACTOR];
	var textBoundingBox = [textPos.x - mFrontText.GetWidthOfLine(0) * 2.0, textPos.y - 2.5 * SCALE_FACTOR, textPos.x + mFrontText.GetWidthOfLine(0) * 2.0, textPos.y + 2.5 * SCALE_FACTOR];
	mFrontText.SetPosition(textPos);
	
	mNumberOfClocks = 8;
	mNumberOfClockRows = 6;
	mClocks = {};
	
	var step = mMainRoom.GetRoomWidth()/mNumberOfClocks;
	var heightStep = mMainRoom.GetRoomHeight()/mNumberOfClockRows;
	
	for(var i = 0; i < mNumberOfClockRows; i++)
	{
		for(var j = 0; j < mNumberOfClocks; j++)
		{
			var newClock = Clock(1, 2);
			
			var x = (mMainRoom.GetRoomWidth()/2.0 - 2.0 * SCALE_FACTOR) - step * (j - mNumberOfClocks/2) - mMainRoom.GetRoomWidth()/2.0 - (step/2.0)*(i % 2);
			var y = (mMainRoom.GetRoomHeight()/ 2.0 - 3.0 * SCALE_FACTOR - heightStep*i) ;
			var z = mMainRoom.GetRoomDepth() - 0.3 * SCALE_FACTOR;
			
			aadd(mClocks, newClock);
			
			// These coordinates are used if the clocks aren't put as children of the main room; I'll leave it for now as a reminder
//			var x = 0 + (mMainRoom.GetRoomWidth()/2.0 - 2.0) - step * (j - mNumberOfClocks/2) - mMainRoom.GetRoomWidth()/2.0 - (step/2.0)*(i % 2);
//			var y = mMainRoom.GetRoomHeight() - 4.0 - heightStep*i;
//			var z = mMainRoom.GetRoomDepth()/2.0 - 0.3;
			
			var position = [x, y, z];
			
			if(position.x >= textBoundingBox[0] && position.x <= textBoundingBox[2]
			&& position.y >= textBoundingBox[1] - mMainRoom.GetRoomHeight()/ 2.0&& position.y <= textBoundingBox[3] - mMainRoom.GetRoomHeight()/ 2.0)
			{
				continue;
			}
				
		
			position.x += Rand(1) == 0 ? Rand(8)/30.0 * SCALE_FACTOR : -Rand(8)/30.0 * SCALE_FACTOR;
			position.y += Rand(1) == 0 ? Rand(2)/2.0 * SCALE_FACTOR : -Rand(2)/2.0 * SCALE_FACTOR;
			
			// If the position is below the floor (taking into account that position.y is in the object's coordinate system so I have to add the half-height of
			// the room, minus the height of the circle) I re-increment the y
			while(position.y + mMainRoom.GetRoomHeight()/ 2.0 - 1 * SCALE_FACTOR <= 0)
				position.y += Rand(9)/5.0 * SCALE_FACTOR;
						
//			newClock.SetPosition(position);
			
			mAnimator.CreateRotatingTransition(newClock.GetMinutesArrowObj(), 0, (360), [0, 0, 1], 10.0, true, false);
			mAnimator.CreateRotatingTransition(newClock.GetHoursArrowObj(), 0, (360), [0, 0, 1], 80.0, true, false);
			
			mMainRoom.AddObject(newClock.GetObj(), position.x, position.y, position.z);
		}
	}
	
	
	var pyramidHeight = 3.0 * SCALE_FACTOR;
	var pyramidMesh = CVmNewMesh(VRP_POLYGONAL_PYRAMID, 120, 2.0 * SCALE_FACTOR, pyramidHeight * SCALE_FACTOR);
	
	// Need also to scale the mesh itself; if the sizes are too small, the mesh will be created with a fixxed size, so to overcome this I scale it manually
	pyramidMesh.Scale(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
	
	pyramidMesh.ShaderAdd("toonShader.glsl", 0);
	pyramidMesh.ShaderActivate(true);
	pyramidMesh.ShaderSetParameter(0, "ambient", 0, [0.04, 0.04, 0.04]);
	pyramidMesh.ShaderSetParameter(0, "diffuse", 0, [0.0, 0.0, 0.8]);
	pyramidMesh.ShaderSetParameter(0, "specular", 0, [5.0, 3.0, 3.0]);
	pyramidMesh.ShaderSetParameter(0, "shininess", 0, 50);
	pyramidMesh.ShaderSetParameter(0, "lightsRangeMin", 0, mMainRoom.GetLightsRange().x);
	pyramidMesh.ShaderSetParameter(0, "lightsRangeMax", 0, mMainRoom.GetLightsRange().y);
	pyramidMesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, SCALE_FACTOR);
	pyramidMesh.ShaderSetParameter(0, "alpha", 0, 1.0);
	
	
	var pyramidObj1 = CVmObj(pyramidMesh); 
	var pyramidObj2 = CVmObj(pyramidMesh); 
	var pyramidObj3 = CVmObj(pyramidMesh); 
	var pyramidObj4 = CVmObj(pyramidMesh);  
	var pyramidObj5 = CVmObj(pyramidMesh); 
	var pyramidObj6 = CVmObj(pyramidMesh);  
	var pyramidObj7 = CVmObj(pyramidMesh); 
	var pyramidObj8 = CVmObj(pyramidMesh);  
		
	global var pyramidObj = CVmObj();
	pyramidObj.AddChild(pyramidObj1, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj2, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj3, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj4, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj5, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj6, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj7, 0, 0, 0);
	pyramidObj.AddChild(pyramidObj8, 0, 0, 0);
	
	pyramidObj2.SetPivotPoint(0, pyramidHeight / 3.0, 0);
	pyramidObj2.Rotate(180, 0, 0, 1);
	
	pyramidObj3.SetPivotPoint(0, pyramidHeight / 3.0, 0);
	pyramidObj3.Rotate(90, 0, 0, 1);
	
	pyramidObj4.SetPivotPoint(0, pyramidHeight / 3.0, 0);
	pyramidObj4.Rotate(-90, 0, 0, 1);
	
	pyramidObj5.SetPivotPoint(0, pyramidHeight / 3.0, 0);
	pyramidObj5.Rotate(90, 1, 0, 0);
	
	pyramidObj6.SetPivotPoint(0, pyramidHeight / 3.0, 0);
	pyramidObj6.Rotate(-90, 1, 0, 0);
	
//	mMainRoom.AddObject(pyramidObj, mMainRoom.GetRoomWidth()/2.0 - 5.0 * SCALE_FACTOR, mMainRoom.GetRoomHeight() / 2.0 - 5.0 * SCALE_FACTOR, mMainRoom.GetRoomDepth() - 10.0 * SCALE_FACTOR);
	
	
//	var waypoint0 = pyramidObj.GetPosition();
//	var waypoint1 = waypoint0 + [-mMainRoom.GetRoomWidth()/2.0 - 10.0 * SCALE_FACTOR, 0, 0];
//	var waypoint2 = waypoint1 + [0, 0, -mMainRoom.GetRoomDepth()/2.0 - 10.0 * SCALE_FACTOR];
//	var waypoint3 = waypoint2 + [mMainRoom.GetRoomWidth()/2.0 - 10.0 * SCALE_FACTOR, 0, 0];
//	mAnimator.CreateTransition(pyramidObj, waypoint0, {waypoint1, waypoint2, waypoint3}, 5.0, true);
	
	mAnimator.CreateRotatingTransition(pyramidObj, 0, 360, [1, 0, 0], 5.0, true, false);
	mAnimator.CreateRotationAroundPointTransition(pyramidObj, [0, mMainRoom.GetRoomHeight() / 2.0, mMainRoom.GetRoomDepth() / 2.0 - 20.0 * SCALE_FACTOR], [0, 0, 0], 20.0, true);

	mAnimator.CreateRotatingTransition(pyramidObj1, 0, 360, [0, 1, 0], 10.0, true, false);
	mAnimator.CreateRotatingTransition(pyramidObj2, 0, -360, [0, 1, 0], 10.0, true, false);
	
	var baseSize = 1.0 * SCALE_FACTOR;
	var otherPyramidHeight = 2.0 * SCALE_FACTOR;
	
//	var otherPyramidMesh = CVmNewMesh(VRP_PYRAMID, 120, baseSize, otherPyramidHeight);
//	global var otherPyramidObj1 = CVmObj(otherPyramidMesh);
//	var otherPyramidObj2 = CVmObj(otherPyramidMesh);
//	var otherPyramidObj3 = CVmObj(otherPyramidMesh);
//	var otherPyramidObj4 = CVmObj(otherPyramidMesh);
//	var otherPyramidObj5 = CVmObj(otherPyramidMesh);
//	var otherPyramidObj6 = CVmObj(otherPyramidMesh);
//	
//	otherPyramidObj2.Rotate(90, 0, 0, 1);
//	otherPyramidObj3.Rotate(180, 0, 0, 1);
//	otherPyramidObj4.Rotate(270, 0, 0, 1);
//	otherPyramidObj5.Rotate(90, 1, 0, 0);
//	otherPyramidObj6.Rotate(-90, 1, 0, 0);
//	
//	global var otherPyramidObj = CVmObj();
//	otherPyramidObj.AddChild(otherPyramidObj1, 0, 0, 0);
//	otherPyramidObj.AddChild(otherPyramidObj2, 0, -baseSize, 0);
//	otherPyramidObj.AddChild(otherPyramidObj3, baseSize, -baseSize, 0);
//	otherPyramidObj.AddChild(otherPyramidObj4, baseSize, 0, 0);
//	otherPyramidObj.AddChild(otherPyramidObj5, 0, -baseSize, 0);
//	otherPyramidObj.AddChild(otherPyramidObj6, 0, 0, -baseSize);
//	
//	otherPyramidObj.Translate(5 * SCALE_FACTOR, 5 * SCALE_FACTOR, 15 * SCALE_FACTOR);
//	
//	mAnimator.CreateScalingTransition(otherPyramidObj, [1.0, 1.0, 1.0], {[1.0, 0.3, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 0.3], [1.0, 1.0, 1.0], [0.3, 1.0, 1.0]}, 3.0, true);
//	mAnimator.CreateRotationAroundPointTransition(otherPyramidObj, otherPyramidObj.GetPosition(), otherPyramidObj.GetPosition() - [0, 0, 2.0 * SCALE_FACTOR], 3.0, true);
	
	mStarObjects = {};
	
	for(var i = 0; i < 10; i++)
		aadd(mStarObjects, CreateStarThing());
	
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}

function Level3::CreateStarThing()
{
	var baseSize = 1.0 * SCALE_FACTOR;
	var otherPyramidHeight = 2.0 * SCALE_FACTOR;
	
	var otherPyramidMesh = CVmNewMesh(VRP_PYRAMID, 120, baseSize, otherPyramidHeight);
	var otherPyramidObj1 = CVmObj(otherPyramidMesh);
	var otherPyramidObj2 = CVmObj(otherPyramidMesh);
	var otherPyramidObj3 = CVmObj(otherPyramidMesh);
	var otherPyramidObj4 = CVmObj(otherPyramidMesh);
	var otherPyramidObj5 = CVmObj(otherPyramidMesh);
	var otherPyramidObj6 = CVmObj(otherPyramidMesh);
	
	otherPyramidObj2.Rotate(90, 0, 0, 1);
	otherPyramidObj3.Rotate(180, 0, 0, 1);
	otherPyramidObj4.Rotate(270, 0, 0, 1);
	otherPyramidObj5.Rotate(90, 1, 0, 0);
	otherPyramidObj6.Rotate(-90, 1, 0, 0);
	
	var star = CVmObj();
	star.AddChild(otherPyramidObj1, 0, 0, 0);
	star.AddChild(otherPyramidObj2, 0, -baseSize, 0);
	star.AddChild(otherPyramidObj3, baseSize, -baseSize, 0);
	star.AddChild(otherPyramidObj4, baseSize, 0, 0);
	star.AddChild(otherPyramidObj5, 0, -baseSize, 0);
	star.AddChild(otherPyramidObj6, 0, 0, -baseSize);
	
//	star.Translate(5 * SCALE_FACTOR, 5 * SCALE_FACTOR, 15 * SCALE_FACTOR);
	
//	mAnimator.CreateScalingTransition(star, [1.0, 1.0, 1.0], {[1.0, 0.3, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 0.3], [1.0, 1.0, 1.0], [0.3, 1.0, 1.0]}, 3.0, true);
//	mAnimator.CreateRotationAroundPointTransition(star, otherPyramidObj.GetPosition(), otherPyramidObj.GetPosition() - [0, 0, 2.0 * SCALE_FACTOR], 3.0, true);

	var posX = mMainRoom.GetRoomWidth() / 2.0 + Rand(1) == 1 ? (Rand(10) / 5.0) * SCALE_FACTOR : -(Rand(10) / 5.0) * SCALE_FACTOR;
	var posY = mMainRoom.GetRoomHeight() / 2.0 + Rand(1) == 1 ? (Rand(10) / 5.0) * SCALE_FACTOR : -(Rand(10) / 5.0) * SCALE_FACTOR;
	var posZ = mMainRoom.GetRoomDepth() / 2.0  - 20.0 * SCALE_FACTOR + Rand(1) == 1 ? (Rand(10) / 5.0) * SCALE_FACTOR : -(Rand(10) / 5.0) * SCALE_FACTOR;
	var time = 20.0 + Rand(1) == 1 ? (Rand(10) / 2.0) : -(Rand(10) / 2.0);
	time = Rand(1) == 1 ? time : -time;
	
	outputln( [posX, posY, posZ]);

	mAnimator.CreateScalingTransition(star, [1.0, 1.0, 1.0], {[1.0, 0.3, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 0.3], [1.0, 1.0, 1.0], [0.3, 1.0, 1.0]}, 3.0, true);
//	mAnimator.CreateRotationAroundPointTransition(star, otherPyramidObj.GetPosition(), otherPyramidObj.GetPosition() - [0, 0, 2.0 * SCALE_FACTOR], 3.0, true);
	mAnimator.CreateRotationAroundPointTransition(star, [posX, posY, posZ], [0, 0, 0], time, true);

	return star;
}

 
 function Level3::Init(lights, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Position = [-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + [0, -100 * SCALE_FACTOR, 0];
	mLight1Position = [0, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR];
	mLight2Position = [0, 10.0 * SCALE_FACTOR, -20.0 * SCALE_FACTOR];
	
	mLight0 = lights[0];
	mLight0.SetPosition(mLight0Position);
	mLight0.SetDiffuse(1, 1, 1);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetPosition(mLight1Position);
	mLight1.SetDiffuse(1, 1, 1);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition(mLight2Position);
	mLight2.SetDiffuse(1, 1, 1);
	mLight2.Enable();
	
		
	mElevator = elevator;
	mElevator.SetLightsRange(0,0);
	
	
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();


	
	mEnding = false;
	mIsLevelCompleted = false;
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 1.5;
	
	
	mElevatorFinalPosition = mElevator.GetPosition();
	
	var lightPos = mLight1.GetPosition();
	
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
	
	mCameraYoffset = mCamera.GetPosition().y - mOpenglTranslationOffset.y - mElevatorFinalPosition.y;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
	
	mIsUsingClock = false;
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */

/*
 * Render method
 */
function Level3::Render()
{	
	// Move the lights back to their original position, because if the user previously teleported their position will be wrong
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
 		
	switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING:
			break;
		case STATUS_ELEVATOR_ARRIVED:
		case STATUS_LEVEL_STARTED:
			mMainRoom.Draw();
			mMainClock.Draw();
			
			mFrontText.Draw();
			
			
//			otherPyramidObj.Draw();
//			numpadObject.Draw();
			pyramidObj.Draw();
			
			foreach(var star in mStarObjects)
				star.Draw();
			break;
	}
	
	// The elevator is always present, so it's always drawn
	mElevator.Draw();
	
	if(mIsVRon)
	{
		mController1.Draw();
		mController2.Draw();
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level3::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		case STATUS_ELEVATOR_MOVING: 
		{			
		    // I make sure that the camera doesn't go out of the elevator while it's going up
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();
	
			// I check if the elevator is halfway through the transtition; if this is the case, I change its lights range for the rendering (but only
			// if I didn't do so already)
			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2 && mElevator.GetLightsRange().y < 1)
				 mElevator.SetLightsRange(1,2);
			
			// I make sure that the camera goes up with the elevator by increasing the y along with the elevator's
			cameraPosition.y = mCameraYoffset + elevatorPos.y;
	   	    
			// To make the shaking camera effect, I randomly move the x and y axis with random values
		    cameraPosition.y += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
		    cameraPosition.x += Rand(1) == 0 ? Rand(8)/500.0 : -Rand(8)/500.0;
			
			// I set the new (shaken and at level with the elevator) position
			mCamera.SetPosition(cameraPosition + mOpenglTranslationOffset);
			
			// I check if the elevator reached its destination, and if this is so I open the door and change status
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
			}
	
			break;
		}		
		// This is the case where the elevator arrived, BUT the player is still inside
		case STATUS_ELEVATOR_ARRIVED:
		{
			// I check if the player goes out from the elevator. Note: I'm not checking that he exits from the doors; he can pass through walls right now.
			// If the player comes out, I close the doors and change status
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			break;
		}
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{
			// I make sure that the player stay's inside the room and outside of the elevator
			if(!mIsVRon && mElevator.IsPointInElevator(cameraPosition) || !mMainRoom.IsPointInRoom(cameraPosition))
		    	mInputManager.RestoreCameraPosition();

			
				 
			// I check if the user has clicked with the mouse or whatever; if that is the case I need to check "where" he clicked    	
	    	if(mInputManager.IsPressingPrimaryButton())
	    	{
	    		// I get the ray that starts from the camera and goes until the end of the rendering plane. Basically I take a ray in the direction
	    		// the user is facing. It doesn't really matter where the ray ends, it's the starting point and its direction that really count.
	    		// But to be safe I make sure that the ray ends "at the end of time"
	    		var raycastOrigin = cameraPosition;
	    		var raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
	    		
	    		// I check if the clock was selected
	    		var contactPoint = IsObjectSelected(raycastOrigin, raycastEnd, mMainClock);
	    		
	    		// If the clock wasn't being used and there actually is a contact point on the clock, I state that the player is using it
	    		if(!mIsUsingClock && contactPoint != Void)
	    			mIsUsingClock = true;
	    		
	    		// If the player is using the clock...
	    		if(mIsUsingClock)
    			{    				
    				// I update the clock's arrow with regards on the direction of the previously computed ray
					mMainClock.UpdateMinutesArrow(raycastOrigin, raycastEnd);
					
					// I get the resulting direction that the arrow moved to (1: clockwise, -1: counter-clockwise, 0: didn't move)
					var timeDirection = mMainClock.GetArrowDirection();
					
					// If the direction found is different from the current direction, and the direction found wasn't 0 (in that case the arrow is still)...
					if(mTimeDirection != timeDirection && timeDirection != 0)
					{
						// ...I invert the active transitions; ALL of them. I also save the new time direction
						mAnimator.InvertTransitions();
						mTimeDirection = timeDirection;
					}
					
					// I change the scale factor of the objects, to speed them up. I always take the positive value of the direction.
					// Note that when the arrow is still, timeDirection will be 0, so in that case the scale factor becomes 0 and the object stay still
					mAnimator.ChangeScaleFactors(abs(timeDirection) * TIME_CLOCK_VELOCITY_MULTIPLIER);
    			}
	    	}
	    	// If there are no clicks...
	    	else
	    	{
	    		// The player was using the clock, now he isn't anymore
	    		if(mIsUsingClock)
	    		{
		    		mIsUsingClock = false;
	    		
		    		// If the player is not using the clock anymore I also set the speed of the objects back to normal.
		    		// Note: I don't invert make the direction go as default: the objects keep going in the direction they were going
		    		mAnimator.ChangeScaleFactors(1);
	    		}
    		}
	    		
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}


/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level3::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	if(intersectedPlane == -1)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	isWall = true;
	
	return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function Level3::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level3::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

function Level3::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, [1, 1, 1]); 
	glLight(GL_LIGHT1, GL_DIFFUSE, [1, 1, 1]); 
	glLight(GL_LIGHT2, GL_DIFFUSE, [1, 1, 1]);
}

