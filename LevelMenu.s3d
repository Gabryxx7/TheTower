
#define STATUS_LEVEL_STARTED 2

class LevelMenu
{
	var menuRoom_WidthFar;
	var menuRoom_WidthSide;
	var menuRoom_Height;
	var mIsVRon;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	var mLight0Diffuse;
	var mLight1Diffuse;
	var mLight2Diffuse;
	
	
	// "Room" object that contains the whole room
	var mMenuRoom;
	var text1;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
		
	var mOpenglTranslationOffset;
	
	var mController1;
	var mController2;
	
	// Private functions
	FadeToBlackScreen(fadeIn);
	DrawGrid(color, size);
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	SetupOpenglLights();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function LevelMenu::LevelMenu(isVRon, inputManager, soundManager)
{		
	mIsVRon = isVRon;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;	
		
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	// Creating the main room
	menuRoom_WidthFar = 45 * SCALE_FACTOR;
	menuRoom_WidthSide = 45 * SCALE_FACTOR;
	menuRoom_Height = 19 * SCALE_FACTOR;
	mMenuRoom = Room(menuRoom_WidthFar, menuRoom_WidthSide, menuRoom_Height, true, 1, 2);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	
	var txt = CVmText();
	txt.Load("THE TOWER");
	txt.SetScale(8  * SCALE_FACTOR, 8  * SCALE_FACTOR);
	txt.SetColor(1, 1, 1);
					
	text1 = CVmObj();
	text1.LinkToText(txt);
	text1.rotate(-90,0,1,0);
	// Adding each text to its portal room
	text1.SetPosition(menuRoom_WidthSide/2-(0.1*SCALE_FACTOR), menuRoom_Height/3, -menuRoom_WidthFar/3-(2.5*SCALE_FACTOR));
	
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}


 
 function LevelMenu::Init(lights, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Position = [-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + [0, -100 * SCALE_FACTOR, 0];
	mLight1Position = [0, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR];
	mLight2Position = [0, 10.0 * SCALE_FACTOR, -20.0 * SCALE_FACTOR];
	
	var diffuseFactor = 0.05;
	mLight0Diffuse = [diffuseFactor,diffuseFactor,diffuseFactor];
	mLight1Diffuse = [diffuseFactor,diffuseFactor,diffuseFactor];
	mLight2Diffuse = [diffuseFactor,diffuseFactor,diffuseFactor];
	
	mLight0 = lights[0];
	mLight0.SetPosition(mLight0Position);
	mLight0.SetDiffuse(mLight0Diffuse[0], mLight0Diffuse[1], mLight0Diffuse[2]);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetPosition(mLight1Position);
	mLight1.SetDiffuse(mLight1Diffuse[0], mLight1Diffuse[1], mLight1Diffuse[2]);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition(mLight2Position);
	mLight2.SetDiffuse(mLight2Diffuse[0], mLight2Diffuse[1], mLight2Diffuse[2]);
	mLight2.Enable();
	
	
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();	
	mCamera.SetPosition(-menuRoom_WidthSide/2 +(2*SCALE_FACTOR), 6.0 * SCALE_FACTOR, 0 * SCALE_FACTOR);
	mCamera.SetDirection(1,0,0);
	
	mEnding = false;
	mIsLevelCompleted = false;
	
	var lightPos = mLight1.GetPosition();
		
	mLevelStatus = STATUS_LEVEL_STARTED;
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */

/*
 * Render method
 */
function LevelMenu::Render()
{	
	// Move the lights back to their original position, because if the user previously teleported their position will be wrong
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
	
	switch(mLevelStatus)
	{
		case STATUS_LEVEL_STARTED:
			mMenuRoom.Draw();
       		DrawGrid([1,1,1], menuRoom_WidthFar);
       		text1.Draw();
			break;
	}
	
	if(mIsVRon)
	{
		mController1.Draw();
		mController2.Draw();
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function LevelMenu::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{			
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}


/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function LevelMenu::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	if(intersectedPlane == -1)
		intersectedPlane = mMenuRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	isWall = true;
	
	return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function LevelMenu::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function LevelMenu::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

function LevelMenu::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, mLight0Diffuse); 
	glLight(GL_LIGHT1, GL_DIFFUSE, mLight1Diffuse); 
	glLight(GL_LIGHT2, GL_DIFFUSE, mLight2Diffuse);
}


function LevelMenu::DrawGrid(color, size)
{
   /* let's not mess up current OpenGL status */
   glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
  
   glLineWidth(4);
   glDisable(GL_LIGHTING);
   glColor(color);
   var max = size / 2.0;
   var min = -max;    
   var step = size / 13.0;
   var offset = (0.01*SCALE_FACTOR);
   glBegin(GL_LINES);
   for(var i = 0; i < 3; i++){
		switch(i){
			//Roof an floor
			case 0: {
				for(var j = 0; j <= menuRoom_Height; j+=menuRoom_Height){
					for (var i = min; i <= max; i += step)
	         		{
		                glVertex(i, j, max);
		                glVertex(i, j, min);
		               
		                glVertex(max, j, i);
		                glVertex(min, j, i);
	                }	                
                }
			 	break;
			 }
			//side walls
			case 1:{
				for(var j = -1; j < 2; j+=2){
					for (var i = min; i <= max; i += step)
	         		{
		                glVertex(i, max, j*menuRoom_WidthFar/2-(j*offset));
		                glVertex(i, min, j*menuRoom_WidthFar/2-(j*offset));
		               
		                glVertex(max, i, j*menuRoom_WidthFar/2-(j*offset));
		                glVertex(min, i, j*menuRoom_WidthFar/2-(j*offset));
	                }
                }
			 	break;
			 }
			//side walls
			case 2:{
				for(var j = -1; j < 0; j+=2){
					for (var i = min; i <= max; i += step)
	         		{
		                glVertex(j*menuRoom_WidthSide/2-(j*offset), max, i);
		                glVertex(j*menuRoom_WidthSide/2-(j*offset), min, i);
		               
		                glVertex(j*menuRoom_WidthSide/2-(j*offset), i, max);
		                glVertex(j*menuRoom_WidthSide/2-(j*offset), i, min);
	                }
                }
			 	break;
			 }
		}
	}    
   glEnd();
  
   /* polite restoration of previous OpenGL status */
   glPopAttrib();   
}
