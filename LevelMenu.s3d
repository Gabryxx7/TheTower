
#define STATUS_LEVEL_STARTED 2

class LevelMenu
{
	var menuRoom_WidthFar;
	var menuRoom_WidthSide;
	var menuRoom_Height;
	var menuRoom_BordersThickness ;
	var mIsVRon;
	
	var levelSelectorsObj;
	var levelSelectors;
	var numberOfLevels;
	var towerLevelHeight;
	var towerLevelWidth;
	var towerConnectionsHeight;
	var towerConnectionsWidth;
	var towerLevels;
	var towerConnectionos;
	
	// Booleans that indicate if the level is starting or ending
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	
	var mLevelStatus;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	var mLight0Diffuse;
	var mLight1Diffuse;
	var mLight2Diffuse;
	
	
	// "Room" object that contains the whole room
	var mMenuRoom;
	var text1;
	
	// Shader to display silhouettes around object. Normally a "Room" object would to that, but the portals are a special case, and we need to manually
	// draw the silhouettes for the portals' frames
	var mSilhouetteShader;
	var mSpotShader;
	var mToonShader;
	var mAlphaShader;
		
	var mOpenglTranslationOffset;
	
	var mController1;
	var mController2;
	
	// Private functions
	FadeToBlackScreen(fadeIn);
	DrawGrid(gridCOlor, drawFront, drawBack, drawLeft, drawRight, drawRoof, drawFloor);
	
	// Public functions
	Init(lights, elevator, openglTranslationOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	GetOpenglTransformOffset();
	SetupOpenglLights();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function LevelMenu::LevelMenu(isVRon, inputManager, soundManager)
{		
	mIsVRon = isVRon;
	
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	mToonShader = CVmShaderProgram("toonShader.glsl");	
	mAlphaShader = CVmShaderProgram("colorModulatorShader.glsl");	
	
	mInputManager = inputManager;
	mSoundManager = soundManager;	
		
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	// Creating the main room
	menuRoom_WidthFar = 45 * SCALE_FACTOR;
	menuRoom_WidthSide = 45 * SCALE_FACTOR;
	menuRoom_Height = 19 * SCALE_FACTOR;
	
	menuRoom_BordersThickness =  2*SCALE_FACTOR;
	mMenuRoom = GlassBox(menuRoom_WidthFar, menuRoom_Height, menuRoom_WidthSide,  menuRoom_BordersThickness);
	mMenuRoom.SetPosition([0,0,-menuRoom_WidthFar/2]);
	
//	mMenuRoom = Room(menuRoom_WidthFar, menuRoom_WidthSide, menuRoom_Height, true, 1, 2);
	
	// Instantiating the silhouette shader, to draw outlines
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	
	var txt = CVmText();
	txt.Load("THE TOWER");
	txt.SetScale(8  * SCALE_FACTOR, 8  * SCALE_FACTOR);
	txt.SetColor(1, 1, 1);
					
	text1 = CVmObj();
	text1.LinkToText(txt);
	text1.rotate(-90,0,1,0);
	// Adding each text to its portal room
	text1.SetPosition(menuRoom_WidthSide/2-(0.1*SCALE_FACTOR), menuRoom_Height/3, -menuRoom_WidthFar/3-(2.5*SCALE_FACTOR));	
	
	towerLevelHeight = 20*SCALE_FACTOR;
	towerLevelWidth =  25*SCALE_FACTOR;
	towerConnectionsHeight = 14 * SCALE_FACTOR;
	towerConnectionsWidth = 21*SCALE_FACTOR;
	
	towerLevels = CVmObj();
	numberOfLevels = 50;
	for(var i = 0; i < numberOfLevels; i++){
		towerLevels.AddChild(CVmObj(CVmNewMesh(VRP_BOX,1, [-towerLevelWidth/2, -towerLevelHeight/2, 0], [towerLevelWidth/2, towerLevelHeight/2, 0], towerLevelWidth)), 0,(towerConnectionsHeight + towerLevelHeight)*i,0);
		
		if(i != numberOfLevels-1)
			towerLevels.AddChild(CVmObj(CVmNewMesh(VRP_BOX,1, [-towerConnectionsWidth/2, -towerConnectionsHeight/2, 0], [towerConnectionsWidth/2, towerConnectionsHeight/2, 0], towerConnectionsWidth)), 0, (towerConnectionsHeight/2 + towerLevelHeight/2) +(towerConnectionsHeight + towerLevelHeight)*i, -towerLevelWidth/2 + towerConnectionsWidth/2);
	}
	
	towerLevels.SetPosition(-towerLevelWidth*5, -towerLevelHeight*(numberOfLevels/2), menuRoom_WidthFar/2 - towerConnectionsWidth/2);
	
	levelSelectors = {};
	levelSelectorsObj = CVmObj();
	var elementPerRow = 2;
	var spacing = 0.5*SCALE_FACTOR;
	var startingY = 0;
	var width = 4*SCALE_FACTOR;
	var height = 1.5*SCALE_FACTOR;
	var thickness = 0.1*SCALE_FACTOR;
	var scale = 0.15;
	var pos;
	var levels = 4;
	for(var i = 0; i < levels; i++){		
		if( i > 0 && (i % elementPerRow) == 0)
			startingY += (height+thickness*2) + spacing;
			
		pos = [(width+thickness*2)*(i % elementPerRow) + spacing*(i % elementPerRow), startingY, 0];
			
		var selector = LevelMenuSelector(mAnimator, i, [0,0,0], width, height, thickness, [1,1,1], [1,0,0], scale);
		aadd(levelSelectors, selector);
		levelSelectorsObj.AddChild(selector.GetObj(), pos.x, pos.y, pos.z);
	}
	
	var objScale = 2.5;
	levelSelectorsObj.SetScale(objScale, objScale, 0);
	levelSelectorsObj.SetPosition(-(menuRoom_WidthFar/2 - (width*2)), menuRoom_Height/2-height*2, -menuRoom_WidthSide/2+0.02*SCALE_FACTOR);
	
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}


 
 function LevelMenu::Init(lights, elevator, openglTransformOffset)
{	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
		
	mLight0Position = [-towerLevelWidth*4.8, 0, 0];
	mLight1Position = [-towerLevelWidth*4.8, 0, 0];
	mLight2Position = [0, menuRoom_Height/2, 0];
	
	var diffuseFactor = 0.05;
	mLight0Diffuse = [1, 0, 0];
	mLight1Diffuse = [0, 1, 1];
	mLight2Diffuse = [0.5, 0.5, 0.5];
	
	mLight0 = lights[0];
	mLight0.SetPosition(mLight0Position);
	mLight0.SetDiffuse(mLight0Diffuse[0], mLight0Diffuse[1], mLight0Diffuse[2]);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetPosition(mLight1Position);
	mLight1.SetDiffuse(mLight1Diffuse[0], mLight1Diffuse[1], mLight1Diffuse[2]);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetPosition(mLight2Position);
	mLight2.SetDiffuse(mLight2Diffuse[0], mLight2Diffuse[1], mLight2Diffuse[2]);
	mLight2.Enable();
	
	
	// Retrieving the input manager and setting the initial camera's position
	mCamera = mInputManager.GetActiveCamera();	
	mCamera.SetPosition(-menuRoom_WidthSide/2 +(2*SCALE_FACTOR), 6.0 * SCALE_FACTOR, 0 * SCALE_FACTOR);
	mCamera.SetDirection(1,0,0);
	
	mEnding = false;
	mIsLevelCompleted = false;
	
	var lightPos = mLight1.GetPosition();
		
	mLevelStatus = STATUS_LEVEL_STARTED;
}


/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */

/*
 * Render method
 */
function LevelMenu::Render()
{	
//	// Move the lights back to their original position, because if the user previously teleported their position will be wrong
//	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
// 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
// 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
 	
//	glEnable(GL_FOG);
// 	glFog(GL_FOG_MODE, GL_EXP);
// 	glFog(GL_FOG_DENSITY, 1);
// 	glFog(GL_FOG_START, 1);
// 	glFog(GL_FOG_END, 20);
// 	glFog(GL_FOG_COLOR, [0,0,1,0.5]);
	
	switch(mLevelStatus)
	{
		case STATUS_LEVEL_STARTED:
       		DrawGrid([1,1,1], false, false, false, true, true, true);
       		text1.Draw();
		
			mToonShader.Start();
				mToonShader.SetParameter("ambient", [1, 1, 1]);
				mToonShader.SetParameter("diffuse", [1, 1, 1]);
				mToonShader.SetParameter("specular", [1, 1, 1]);
				mToonShader.SetParameter("shininess", 0);
				mToonShader.SetParameter("SCALE_FACTOR", SCALE_FACTOR);
				mToonShader.SetParameter("alpha", 1.0);
				mToonShader.SetParameter("lightsRangeMin", 2);
				mToonShader.SetParameter("lightsRangeMax", 2);
				mMenuRoom.Draw([1,1,1,0,1,1], [1,1,1,1,1,1]);
				
				mToonShader.SetParameter("diffuse", [1, 1, 1]);
				mToonShader.SetParameter("specular", [1, 1, 1]);
				mToonShader.SetParameter("shininess", 0);
				mToonShader.SetParameter("lightsRangeMin", 0);
				mToonShader.SetParameter("lightsRangeMax", 1);
	       		towerLevels.Draw();
			mToonShader.Stop();
			
			
		mAlphaShader.Start();
			mAlphaShader.SetParameter("time", 0);
			mAlphaShader.SetParameter("alpha", 0.3);
			mAlphaShader.SetParameter("startingColor", [0.6, 0.6, 1]);
			mAlphaShader.SetParameter("finalColor", [0.6, 0.6, 1]);
			mMenuRoom.Draw([0,0,0,1,0,0], [0,0,0,0,0,0]);
		mAlphaShader.Stop();
		
		levelSelectorsObj.Draw();
			
		break;
	}
	
	if(mIsVRon)
	{
		mController1.Draw();
		mController2.Draw();
	}
}


/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
  
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function LevelMenu::UpdateLogic(dt)
{
	// First off, let's update the player's position and orientation
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	switch(mLevelStatus)
	{
		// This is the case where the level is starting and the elevator is moving up
		
		// Case where the player is out of the elevator. It's the main status of the level
		case STATUS_LEVEL_STARTED:
		{		
			for(var i = 0; i < len(levelSelectors); i++){
				var res = levelSelectors[i].IsBeingPointedBy(mCamera, cameraPosition, true);
				outputln();
				output(i);
				output(" ");
				outputln(res);
			}	
			break;
		}
	}
		
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}


/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function LevelMenu::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	var intersectedPlane = -1;

	if(intersectedPlane == -1)
		intersectedPlane = mMenuRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	isWall = true;
	
	return intersectedPlane == 0;
}


/*
 * Method called by the GameManager to check if the level is completed
 */
function LevelMenu::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function LevelMenu::GetOpenglTransformOffset()
{
	return mOpenglTranslationOffset; 
}

function LevelMenu::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset;
}

function LevelMenu::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, mLight0Diffuse); 
	glLight(GL_LIGHT1, GL_DIFFUSE, mLight1Diffuse); 
	glLight(GL_LIGHT2, GL_DIFFUSE, mLight2Diffuse);
}


function LevelMenu::DrawGrid(gridCOlor, drawFront, drawBack, drawLeft, drawRight, drawRoof, drawFloor)
{
   /* let's not mess up current OpenGL status */
//   glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
  
   glLineWidth(4);
   glDisable(GL_LIGHTING);
   glColor(gridCOlor);
   var max = menuRoom_WidthFar / 2.0;
   var min = -max;    
   var step = menuRoom_WidthFar / 13.0;
   var offset = (0.15*SCALE_FACTOR);
   glBegin(GL_LINES);
   for(var n = 0; n < 3; n++){
		switch(n){
			//Roof an floor
			case 0: {
				var y = 0; 
				for(var j = (drawFloor ? 0 : menuRoom_Height); j <= (drawRoof ? menuRoom_Height : 0); j+=menuRoom_Height){
					for (var i = min; i <= max; i += step)
	         		{
	         			if(j == 0)
	         				y = offset;
	         			else if( j == menuRoom_Height)
	         				y = menuRoom_Height-offset;
	         			else
	         				y = j;
	         				
		                glVertex(i, y, max);
		                glVertex(i, y, min);
		               
		                glVertex(max, y, i);
		                glVertex(min, y, i);
	                }	                
                }
			 	break;
			 }
			//side walls
			case 1:{
				var z = 0;
				for(var j = (drawLeft ? -1 : 1); j < (drawRight ? 2: 0); j+=2){
					for (var i = min; i <= max; i += step)
	         		{
	         			if(j < 0)
	         				z = offset;
	         			else if( j > 0)
	         				z = -offset;
	         			else
	         				z = 0;
		                glVertex(i, max, j*menuRoom_WidthFar/2+z);
		                glVertex(i, min, j*menuRoom_WidthFar/2+z);
		               
		                glVertex(max, i, j*menuRoom_WidthFar/2+z);
		                glVertex(min, i, j*menuRoom_WidthFar/2+z);
	                }
                }
			 	break;
			 }
			//side walls
			case 2:{
				var x = 0;
				for(var j = (drawBack ? -1 : 1); j < (drawFront ? 2 : 0); j+=2){
					for (var i = min; i <= max; i += step)
	         		{
	         			if(j < 0)
	         				x = offset;
	         			else if( j > 0)
	         				x = -offset;
	         			else
	         				x = 0;
		                glVertex(j*menuRoom_WidthSide/2+x, max, i);
		                glVertex(j*menuRoom_WidthSide/2+x, min, i);
		               
		                glVertex(j*menuRoom_WidthSide/2+x, i, max);
		                glVertex(j*menuRoom_WidthSide/2+x, i, min);
	                }
                }
			 	break;
			 }
		}
	}    
   glEnd();
  
   /* polite restoration of previous OpenGL status */
   glPopAttrib();   
}
