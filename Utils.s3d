function Print(strings, objects)
{
	if(valtype(strings) == "A")
	{
			output(strings[0] + ": ");
		output(objects[0]);
		
		for(var i = 1; i < len(strings); i++)
		{
			output("; " + strings[i] + ": ");
			output(objects[i]);
		}
		
		output("\n");
	}
	else
	{
		output(strings + ": ");
		output(objects);
		output("\n");
	}
}

// Doesn't support arrays
function PrintDebugBox(strings, objects)
{
	var totalText = "";
	
	if(valtype(strings) == "A")
	{
		for(var i = 0; i < len(strings); i++)
		{
			totalText += strings[i] + ": ";
			
			if(valtype(objects[i]) == "B")
				totalText += objects[i] ? "True" : "False";
			else
				totalText += str(objects[i]);
				
			totalText += ";\n ";
		}
		
		totalText += "\n";
	}
	else
	{
		totalText = strings;
	
		if(valtype(objects) == "B")
			totalText += objects ? "True" : "False";
		else
			totalText += str(objects);
	}
	
	ConsoleColor(1, 1, 0, 0.5);
	ConsoleFilledRect(0.4, 0.94, 0.2, 0.05);
	ConsoleColor(0, 0, 0, 1);
	ConsoleFont("Arial", 20);
	ConsoleText(0.40, 0.9, totalText);
	
}

/*
 * This function checks if a line segment intersects the given object; if it does, it returns the contact point, or Void otherwise
 * 
 * raycastOrigin: (vector) the start point of the line segment
 * raycastEnd: (vector) the end point of the line segment
 * object: (object) the object to check
 */
function IsObjectSelected(raycastOrigin, raycastEnd, object)
{	
	var contactPoint = Void;
	
	object.IsColliding(raycastOrigin, raycastEnd, &contactPoint);
	
	return contactPoint;
}

/*
 * This function checks if a line segment intersects a plane; if it does, it returns the contact point, or Void otherwise.
 * A line segment is defined by the start point and the end point. 
 * A plane is defined with a point belonging to the plane and the normal to the plane
 * 
 * raycastOrigin: (vector) the start point of the line segment
 * raycastEnd: (vector) the end point of the line segment
 * planePoint: (vector) the point belonging to the plane
 * planeNormal: (vector) the vector perpendicular to the plane
 */
function FindIntersectionInPlane(raycastOrigin, raycastEnd, planePoint, planeNormal)
{
	/*
	 * The code and the explanation for this implementation was found here: 
	 * https://www.youtube.com/watch?v=fIu_8b2n8ZM
	 * https://github.com/BSVino/MathForGameDevelopers/blob/line-plane-intersection/math/collision.cpp
	 */
	var pointInPlane = Void;
	
	var v = raycastEnd - raycastOrigin;
	var w = planePoint - raycastOrigin;

	var k = (w * planeNormal) / (v * planeNormal);

	// If k is between 0 and 1 there was an intersection, otherwise there wasn't
	if(k >= 0 && k <= 1)
		pointInPlane = raycastOrigin + k * v;

	return pointInPlane;
	
	
	/*
	 * Below there is the old code, which I keep just in case; it ASSUMED that there was an intersection and it found the contact point
	 */
//	var pointInPlane = Void;
//	
//	// I first need to check if the raycast intersects the plane. To do that, I first get the direction of the raycast and I normalize it. The idea is 
//	// to do the dot product between the direction of the raycast and the plane normal, and study the sign of the result. But this is not enough,
//	// since the plane has a physical point where it's placed in the space, so we also need to check whether the raycast starts from one side of the plane or the other
//	var raycastDirection = Norm(raycastOrigin - raycastEnd);
//	
//	// I get the direction between the starting point of the line and the plane, and normalize it. This helps me to find out on which side of the plane the ray
//	// starts, by doing the dot product with the normal. The result will have positive values if the ray starts from one side, and negative values from the other side
//	var directionToPlane = Norm(raycastOrigin - planePoint);
//	
//	// Doing the dot products
//	var raycastNormalProduct = raycastDirection * planeNormal;
//	var directionToPlaneNormalProduct = directionToPlane * planeNormal;
//	
//	// If the dot products have the same sign then the raycast is intersecting the plane. So, to check that easily I multiply the results and check the sign; if
//	// it's positive, the ray intersects the plane, so we can look for the contact point
//	if(raycastNormalProduct * directionToPlaneNormalProduct > 0)
//	{
//		/* Consider the ray as a line, with line equation r(t) = p0 + p1 * T where p0 is the starting point of the ray and p1 the ending point. To find the
//		 * contact point on the plane, we have to find the right T and solve the equation. 
//		 * Now consider a point q in the plane and the plane's normal n. For a point x to be on the plane this has to be true: n * (q - x) = 0 where the "*" 
//		 * is the dot product. This has to be true because all points in the plane have to be perpendicular to n, so if we take from the point q that we
//		 * know belongs to the plane and a random point x and take the vector that goes from one to the other, this vector has to be perpendicular to n for
//		 * x to be on the plane; so the dot product has to be zero.
//		 * Now, from that equation we need to substitute the "x" with the ray's equation:
//		 * n * (q - p0 - p1 * T) = 0 --> n * (q - p0) - n * p1 * T = 0 --> n * (q - p0) = n * p1 * T --> n * (q - p0) / (p1 * n) = T 
//		 * This is the equation we need to solve to get the right T; we have all the ingredients */
//		var T = planeNormal * (planePoint - raycastOrigin) / (planeNormal * raycastEnd);
//		
//		// Now that we have T, let's solve the ray's equation and we've got our point
//		pointInPlane = raycastOrigin + (raycastEnd * T);
//	}
//	
//	return pointInPlane;
}

/*
 * Ausiliary function that computes the normal of a planar object, using heuristics. The planar object is assumed to be vertical (i.e. perpendicular to the z axis)
 */
function ComputeNormalOfPlanarObject(object)
{
	// I get 4 points that belong to the object (even if the object is smaller than this, it's assumed to be a plane, so it's considered infinite)
	var p0 = object.LocalToWorld([0, 0, 0]);
	var p1 = object.LocalToWorld([0, 1 * SCALE_FACTOR, 0]);
	var p2 = object.LocalToWorld([0, 0, 0]);
	var p3 = object.LocalToWorld([1 * SCALE_FACTOR, 0, 0]);
	
	// I get 2 vectors from these 4 points, so that the vectors are "attached" to the plane
	var vec1 = p1 - p0;
	var vec2 = p3 - p2;
	
	// Now I compute the cross product between the vector, which gives as a result a vector that is perpendicular to the 2 vectors, and since the vectors
	// where "attached" to the plane, the vector is basically the normal to the plane. I normalize it to make it an "official" normal
	var normal = Norm(vec1 ^ vec2);
	
	return normal;
}


/*
 * Ausiliary method that adds the oon shader to an object, instead of having to put the same code over and over when using the toon shader
 */
function AddToonShaderToMesh(mesh, ambient, diffuse, specular, shininess, lightsRangeMin, lightsRangeMax, scaleFactor, alpha)
{
	if(USE_TOON_SHADER == 2) 
	{		
		mesh.ShaderAdd("antishader.glsl", 0);
		mesh.ShaderActivate(true);
	}
	else if(USE_TOON_SHADER == 1)
	{
		mesh.ShaderAdd("toonShader.glsl", 0);
		mesh.ShaderActivate(true);		
	}
	else if(USE_TOON_SHADER == 0){
		mesh.ShaderActivate(false);				
	}
	
	mesh.ShaderSetParameter(0, "ambient", 0, ambient);
	mesh.ShaderSetParameter(0, "diffuse", 0, diffuse);
	mesh.ShaderSetParameter(0, "specular", 0, specular);
	mesh.ShaderSetParameter(0, "shininess", 0, shininess);
	mesh.ShaderSetParameter(0, "lightsRangeMin", 0, lightsRangeMin);
	mesh.ShaderSetParameter(0, "lightsRangeMax", 0, lightsRangeMax);
	mesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, scaleFactor);
	mesh.ShaderSetParameter(0, "alpha", 0, alpha);
}

/*
 * This is an auxiliary function that creates cone-thing objects, used in Level0 and Level4
 * 
 * lightsRangeMin: (integer) the min number of the range of opengl lights that have to be used in the cel shader to render the object
 * lightsRangeMax: (integer) the max number of the range of opengl lights that have to be used in the cel shader to render the object
 * baseSize: optional (float) the base size of the object; if not defined, a random one will be chosen
 * pyramidHeight: optional (float) height of a single pyramid in the object; if not defined, a random one will be chosen
 * color: optional (vector[3]) the color of the object; if not defined, a random one will be chosen
 */
function CreateStarThing(lightsRangeMin, lightsRangeMax, baseSize, pyramidHeight, color, ambient)
{
	if(baseSize == Void)
		baseSize = 0.3 * SCALE_FACTOR + (Rand(4) / 10.0) * SCALE_FACTOR;
		
	if(pyramidHeight == Void)
		pyramidHeight = 1.0 * SCALE_FACTOR + (Rand(8) / 10.0) * SCALE_FACTOR;
	
	var pyramidMesh = CVmNewMesh(VRP_PYRAMID, 120, baseSize, pyramidHeight);
	var cubeSize = pyramidHeight >= baseSize ? pyramidHeight : baseSize;
	cubeSize += baseSize/2;
	var boundingCubeMesh = CVmNewMesh(VRP_BOX, 1, [-cubeSize, -cubeSize, -cubeSize], [cubeSize, cubeSize, cubeSize]);
	boundingCubeMesh.Hide();
	
	if(color == Void)
		color = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
	
//	mesh, ambient, diffuse, specular, shininess, lightsRangeMin, lightsRangeMax, scaleFactor, alpha
	ambient = valtype(ambient) == "" ? [0.04, 0.04, 0.04] : ambient;
	AddToonShaderToMesh(pyramidMesh, ambient, color, [0.4, 0.4, 0.4], 50, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 1.0);
	
	var star = CVmObj(boundingCubeMesh);
	var pyramidObj1 = CVmObj(pyramidMesh);
	var pyramidObj2 = CVmObj(pyramidMesh);
	var pyramidObj3 = CVmObj(pyramidMesh);
	var pyramidObj4 = CVmObj(pyramidMesh);
	var pyramidObj5 = CVmObj(pyramidMesh);
	var pyramidObj6 = CVmObj(pyramidMesh);
	
	pyramidObj2.Rotate(90, 0, 0, 1);
	pyramidObj3.Rotate(180, 0, 0, 1);
	pyramidObj4.Rotate(270, 0, 0, 1);
	pyramidObj5.Rotate(90, 1, 0, 0);
	pyramidObj6.Rotate(-90, 1, 0, 0);
	
	star.AddChild(pyramidObj1);
	star.AddChild(pyramidObj2, 0, -baseSize, 0);
	star.AddChild(pyramidObj3, baseSize, -baseSize, 0);
	star.AddChild(pyramidObj4, baseSize, 0, 0);
	star.AddChild(pyramidObj5, 0, -baseSize, 0);
	star.AddChild(pyramidObj6, 0, 0, -baseSize);

	return star;
}

/*
 * This is an auxiliary function that creates cone-thing objects, used in Level0 and Level4; works just like CreateStarThing()
 * 
 * lightsRangeMin: (integer) the min number of the range of opengl lights that have to be used in the cel shader to render the object
 * lightsRangeMax: (integer) the max number of the range of opengl lights that have to be used in the cel shader to render the object
 * coneHeight: optional (float) height of a single cone in the object; if not defined, a random one will be chosen
 * color: optional (vector[3]) the color of the object; if not defined, a random one will be chosen
 */
function CreateConeThing(lightsRangeMin, lightsRangeMax, coneHeight, color)
{
	if(coneHeight == Void)
		coneHeight = Rand(1) == 0 ? 3.0 * SCALE_FACTOR - (Rand(10) / 10.0) * SCALE_FACTOR : 3.0 * SCALE_FACTOR + (Rand(10) / 10.0) * SCALE_FACTOR;
		
	var coneMesh = CVmNewMesh(VRP_POLYGONAL_PYRAMID, 120, 2.0 * SCALE_FACTOR, coneHeight * SCALE_FACTOR);
	
	// Need also to scale the mesh itself; if the sizes are too small, the mesh will be created with a fixxed size, so to overcome this I scale it manually
	coneMesh.Scale(SCALE_FACTOR, SCALE_FACTOR, SCALE_FACTOR);
	
	if(color == Void)
		color = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		
	AddToonShaderToMesh(coneMesh, [0.04, 0.04, 0.04], color, [0.4, 0.4, 0.4], 50, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 1.0);
	
	var coneContainerObj = CVmObj(coneMesh); 
	var coneObj2 = CVmObj(coneMesh); 
	var coneObj3 = CVmObj(coneMesh); 
	var coneObj4 = CVmObj(coneMesh);  
	var coneObj5 = CVmObj(coneMesh); 
	var coneObj6 = CVmObj(coneMesh);  
	var coneObj7 = CVmObj(coneMesh); 
	var coneObj8 = CVmObj(coneMesh);  
		
	coneContainerObj.AddChild(coneObj2, 0, 0, 0);
	coneContainerObj.AddChild(coneObj3, 0, 0, 0);
	coneContainerObj.AddChild(coneObj4, 0, 0, 0);
	coneContainerObj.AddChild(coneObj5, 0, 0, 0);
	coneContainerObj.AddChild(coneObj6, 0, 0, 0);
	
	coneObj2.SetPivotPoint(0, coneHeight / 3.0, 0);
	coneObj2.Rotate(180, 0, 0, 1);
	
	coneObj3.SetPivotPoint(0, coneHeight / 3.0, 0);
	coneObj3.Rotate(90, 0, 0, 1);
	
	coneObj4.SetPivotPoint(0, coneHeight / 3.0, 0);
	coneObj4.Rotate(-90, 0, 0, 1);
	
	coneObj5.SetPivotPoint(0, coneHeight / 3.0, 0);
	coneObj5.Rotate(90, 1, 0, 0);
	
	coneObj6.SetPivotPoint(0, coneHeight / 3.0, 0);
	coneObj6.Rotate(-90, 1, 0, 0);
	
	return coneContainerObj;
}

/*
 * Ausilairy function that adds silhouette lines to planar object (potentially cubic)
 * 
 * object: (CVmObj) object to which the lines will be added
 * silhouetteThickness: (float) thickness of the lines
 * width: (float) width of the object
 * height: (float) height of the object
 * zOffset: optional (float) the offset used for the z axis to position the lines; used in case the object is almost planar (like a cube), to add lines to a face
 */
function AddSilhouetteLinesToPlanarObject(object, silhouetteThickness, width, height, xOffset, yOffset, zOffset)
{
	var halfWidth = width / 2.0;
	var halfHeight = height / 2.0;
	
	if(xOffset == Void)
		xOffset = 0;
		
	if(yOffset == Void)
		yOffset = 0;
		
	if(zOffset == Void)
		zOffset = 0;
	
	// Mesh for the silhouette lines used in the borders
	var silhouetteLineHalfWidth = silhouetteThickness / 2.0;
	
	var innerSilhouetteVerticalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfHeight, 0], [silhouetteLineHalfWidth, halfHeight, 0], 2, 2);
	var innerSilhouetteHorizzontalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfWidth, 0], [silhouetteLineHalfWidth, halfWidth, 0], 2, 2);
	var outerSilhouetteVerticalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfHeight, 0], [silhouetteLineHalfWidth, halfHeight, 0], 2, 2);
	var outerSilhouetteHorizzontalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfWidth, 0], [silhouetteLineHalfWidth, halfWidth, 0], 2, 2);
	
	// Black material for the lines
	var silhouetteMaterial = CVmMaterial();
	silhouetteMaterial.diffuse = [0, 0, 0];
	silhouetteMaterial.ambient = [0, 0, 0];
	silhouetteMaterial.specular = [0, 0, 0];
	
	innerSilhouetteVerticalLine.ForceMaterial(silhouetteMaterial);
	innerSilhouetteHorizzontalLine.ForceMaterial(silhouetteMaterial);
	outerSilhouetteVerticalLine.ForceMaterial(silhouetteMaterial);
	outerSilhouetteHorizzontalLine.ForceMaterial(silhouetteMaterial);

	var innerSilhouetteLeft = CVmObj(innerSilhouetteVerticalLine);
	var innerSilhouetteRight = CVmObj(innerSilhouetteVerticalLine);
	var innerSilhouetteTop = CVmObj(innerSilhouetteHorizzontalLine);
	var innerSilhouetteBottom = CVmObj(innerSilhouetteHorizzontalLine);
	
	var outerSilhouetteLeft = CVmObj(outerSilhouetteVerticalLine);
	var outerSilhouetteRight = CVmObj(outerSilhouetteVerticalLine);
	var outerSilhouetteTop = CVmObj(outerSilhouetteHorizzontalLine);
	var outerSilhouetteBottom = CVmObj(outerSilhouetteHorizzontalLine);
	
	innerSilhouetteTop.Rotate(90, 0, 0, 1);
	innerSilhouetteBottom.Rotate(90, 0, 0, 1);
	outerSilhouetteTop.Rotate(90, 0, 0, 1);
	outerSilhouetteBottom.Rotate(90, 0, 0, 1);
	
	// Adding the silhouette lines to the object; I use a very small z value to move the lines as close as possible to the object without having Z-fighting
	object.AddChild(innerSilhouetteLeft, halfWidth - silhouetteLineHalfWidth + xOffset, yOffset, -0.0005 * SCALE_FACTOR + zOffset);
	object.AddChild(innerSilhouetteRight, -halfWidth + silhouetteLineHalfWidth + xOffset, yOffset, -0.0005 * SCALE_FACTOR + zOffset);
	object.AddChild(innerSilhouetteTop, xOffset, halfHeight - silhouetteLineHalfWidth + yOffset, -0.0005 * SCALE_FACTOR + zOffset);
	object.AddChild(innerSilhouetteBottom, xOffset, -halfHeight + silhouetteLineHalfWidth + yOffset, -0.0005 * SCALE_FACTOR + zOffset);
	
	object.AddChild(outerSilhouetteLeft, halfWidth - silhouetteLineHalfWidth + xOffset, yOffset, 0.0005 * SCALE_FACTOR + zOffset);
	object.AddChild(outerSilhouetteRight, -halfWidth + silhouetteLineHalfWidth + xOffset, yOffset, 0.0005 * SCALE_FACTOR + zOffset);
	object.AddChild(outerSilhouetteTop, xOffset, halfHeight - silhouetteLineHalfWidth + yOffset, 0.0005 * SCALE_FACTOR + zOffset);
	object.AddChild(outerSilhouetteBottom, xOffset, -halfHeight + silhouetteLineHalfWidth + yOffset, 0.0005 * SCALE_FACTOR + zOffset);
}

/*
 * Ausiliary function that creates a wall that simulates a glass; the glass has also borders at each sides
 * 
 * wallWidth: (float) width of the wall
 * wallHeight: (float) height of the wall
 * borderThickness: (float) thickness of the borders around the glass
 * lightsRangeMin: (integer) the min number of the range of opengl lights that have to be used in the cel shader to render the glass wall
 * lightsRangeMax: (integer) the max number of the range of opengl lights that have to be used in the cel shader to render the glass wall
 */
function CreateGlassWall(wallWidth, wallHeight, borderThickness, lightsRangeMin, lightsRangeMax, glassAlpha)
{
	var halfWidth = wallWidth / 2.0;
	var halfHeight = wallHeight / 2.0;
	var halfThickness = borderThickness / 2.0;
	
	if(glassAlpha == Void)
		glassAlpha = 0.5;
	
	// The glass mesh is smaller than the wall, because it takes into account the borders
	var glassMesh = CVmNewMesh(VRP_PLANE, 1, [-halfWidth + borderThickness, -halfHeight + borderThickness, 0], [halfWidth - borderThickness, halfHeight - borderThickness, 0], 2, 2);
	
	// Adding the toon shader to the glass wall; by using a low value for the alpha it simulates the glass
	AddToonShaderToMesh(glassMesh, [0.4, 0.4, 0.4], [0.5, 0.5, 0.5], [0.2, 0.2, 0.2], 0, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 0.5);
	
	var glassWallObj = CVmObj(glassMesh);
	
	// Meshes for the borders
	var verticalBorderMesh = CVmNewMesh(VRP_PLANE, 1, [-halfThickness, -halfHeight, 0], [halfThickness, halfHeight, 0], 2, 2);
	var horizzontalBorderMesh = CVmNewMesh(VRP_PLANE, 1, [-halfWidth + halfThickness, -halfThickness, 0], [halfWidth - halfThickness, halfThickness, 0], 2, 2);
	
	var leftBorderObj = CVmObj(verticalBorderMesh);
	var rightBorderObj = CVmObj(verticalBorderMesh);
	var topBorderObj = CVmObj(horizzontalBorderMesh);
	var bottomBorderObj = CVmObj(horizzontalBorderMesh);
	
	// Mesh for the silhouette lines used in the borders
	var silhouetteLineHalfWidth = 0.02 * SCALE_FACTOR;
	
	// I add the silhouettes from either side of the plane
	var innerSilhouetteVerticalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfHeight + borderThickness, 0], [silhouetteLineHalfWidth, halfHeight - borderThickness, 0], 2, 2);
	var innerSilhouetteHorizzontalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfWidth + borderThickness, 0], [silhouetteLineHalfWidth, halfWidth - borderThickness, 0], 2, 2);
	var outerSilhouetteVerticalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfHeight, 0], [silhouetteLineHalfWidth, halfHeight, 0], 2, 2);
	var outerSilhouetteHorizzontalLine = CVmNewMesh(VRP_PLANE, 1, [-silhouetteLineHalfWidth, -halfWidth, 0], [silhouetteLineHalfWidth, halfWidth, 0], 2, 2);

	// Black material for the lines
	var silhouetteMaterial = CVmMaterial();
	silhouetteMaterial.diffuse = [0, 0, 0];
	silhouetteMaterial.ambient = [0, 0, 0];
	silhouetteMaterial.specular = [0, 0, 0];
	
	innerSilhouetteVerticalLine.ForceMaterial(silhouetteMaterial);
	innerSilhouetteHorizzontalLine.ForceMaterial(silhouetteMaterial);
	outerSilhouetteVerticalLine.ForceMaterial(silhouetteMaterial);
	outerSilhouetteHorizzontalLine.ForceMaterial(silhouetteMaterial);

	var innerSilhouetteLeft = CVmObj(innerSilhouetteVerticalLine);
	var innerSilhouetteRight = CVmObj(innerSilhouetteVerticalLine);
	var innerSilhouetteTop = CVmObj(innerSilhouetteHorizzontalLine);
	var innerSilhouetteBottom = CVmObj(innerSilhouetteHorizzontalLine);
	
	var outerSilhouetteLeft = CVmObj(outerSilhouetteVerticalLine);
	var outerSilhouetteRight = CVmObj(outerSilhouetteVerticalLine);
	var outerSilhouetteTop = CVmObj(outerSilhouetteHorizzontalLine);
	var outerSilhouetteBottom = CVmObj(outerSilhouetteHorizzontalLine);
	
	innerSilhouetteTop.Rotate(90, 0, 0, 1);
	innerSilhouetteBottom.Rotate(90, 0, 0, 1);
	outerSilhouetteTop.Rotate(90, 0, 0, 1);
	outerSilhouetteBottom.Rotate(90, 0, 0, 1);
	
	AddToonShaderToMesh(verticalBorderMesh, [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [0.0, 0.0, 0.0], 50, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 1.0);
	AddToonShaderToMesh(horizzontalBorderMesh, [1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [0.0, 0.0, 0.0], 50, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 1.0);
	
	// Adding the borders to the wall
	glassWallObj.AddChild(leftBorderObj, halfWidth - halfThickness, 0, 0);
	glassWallObj.AddChild(rightBorderObj, -halfWidth + halfThickness, 0, 0);
	glassWallObj.AddChild(topBorderObj, 0, halfHeight - halfThickness, 0);
	glassWallObj.AddChild(bottomBorderObj, 0, -halfHeight + halfThickness, 0);
	
	// Adding the silhouette lines to the wall where the borders are, using a very low z offset to avoid Z fighting but at the same time making
	// it look like they're attached to the wall
	glassWallObj.AddChild(innerSilhouetteLeft, halfWidth - borderThickness, 0, -0.003 * SCALE_FACTOR);
	glassWallObj.AddChild(innerSilhouetteRight, -halfWidth + borderThickness, 0, -0.003 * SCALE_FACTOR);
	glassWallObj.AddChild(innerSilhouetteTop, 0, halfHeight - borderThickness - silhouetteLineHalfWidth, -0.003 * SCALE_FACTOR);
	glassWallObj.AddChild(innerSilhouetteBottom, 0, -halfHeight + borderThickness + silhouetteLineHalfWidth, -0.003 * SCALE_FACTOR);
	
	glassWallObj.AddChild(outerSilhouetteLeft, halfWidth, 0, -0.003 * SCALE_FACTOR);
	glassWallObj.AddChild(outerSilhouetteRight, -halfWidth, 0, -0.003 * SCALE_FACTOR);
	glassWallObj.AddChild(outerSilhouetteTop, 0, halfHeight - silhouetteLineHalfWidth, -0.003 * SCALE_FACTOR);
	glassWallObj.AddChild(outerSilhouetteBottom, 0, -halfHeight + silhouetteLineHalfWidth, -0.003 * SCALE_FACTOR);
	
	return glassWallObj;
}

/*
 * Util function that changes the lights color when the user presses certain keys; the parameters must be passed as reference
 */
function UpdateLightsColor(light1Diffuse, light2Diffuse)
{
	// First light
	if(keypressed("U"))
	{
		light1Diffuse.x += 0.01;
		print("light1Diffuse", light1Diffuse);
	}
	if(keypressed("J"))
	{
		light1Diffuse.x -= 0.01;
		print("light1Diffuse", light1Diffuse);
	}
	if(keypressed("I"))
	{
		light1Diffuse.y += 0.01;
		print("light1Diffuse", light1Diffuse);
	}
	if(keypressed("K"))
	{
		light1Diffuse.y -= 0.01;
		print("light1Diffuse", light1Diffuse);
	}
	if(keypressed("O"))
	{
		light1Diffuse.z += 0.01;
		print("light1Diffuse", light1Diffuse);
	}
	if(keypressed("L"))
	{
		light1Diffuse.z -= 0.01;
		print("light1Diffuse", light1Diffuse);
	}
	

	// Second light
	if(keypressed("F"))
	{
		light2Diffuse.x += 0.01;
		print("light2Diffuse", light2Diffuse);
	}
	if(keypressed("V"))
	{
		light2Diffuse.x -= 0.01;
		print("light2Diffuse", light2Diffuse);
	}
	if(keypressed("G"))
	{
		light2Diffuse.y += 0.01;
		print("light2Diffuse", light2Diffuse);
	}
	if(keypressed("B"))
	{
		light2Diffuse.y -= 0.01;
		print("light2Diffuse", light2Diffuse);
	}
	if(keypressed("H"))
	{
		light2Diffuse.z += 0.01;
		print("light2Diffuse", light2Diffuse);
	}
	if(keypressed("N"))
	{
		light2Diffuse.z -= 0.01;
		print("light2Diffuse", light2Diffuse);
	}
}


/**In order to change something in the position, is possible to use the following regular expression in the Notepad++ find and replace
 * "\[(\-[0-9]|[0-9])\*size.x,(\s*)(\-[0-9]|[0-9])\*size.y,(\s*)(\-[0-9]|[0-9])\]"
 * and use this to substitute the data 
 * "[$1*size.x, $3*size.y, $5]"
 * 
 * where
 * $1 = the multiplier of size.x
 * $2 = the space after the coma after size.x
 * $3 = the multiplier of size.y
 * $4 = the space after the coma after size.y
 * $5 = the z coordinate
 */
function GenerateNumberPositions(number, offset, size, spacing, direction){
	var ret = {};
	direction = valtype(direction) == "" ? 1 : direction;
	size = valtype(size) != "A" && valtype(size) != "V" ? [size, size] : size;
	spacing = valtype(spacing) != "A" && valtype(spacing) != "V" ? [spacing, spacing] : spacing;
	
	switch(number){	
		case 0:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;
		case 1:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			//Height
			aadd(ret, [0*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//		
			
			aadd(ret, [0*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			//Top
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			break;
			
		case 2:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//			
			
			//Height
			aadd(ret, [1*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//					
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;
		
		case 3:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;		
		
		case 4:
			//Base
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//		
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;	
		
		case 5:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//s
			
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;			
		
		case 6:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//s
			
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;	
		
		case 7:
			//Base
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;		
		
		case 8:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;		
		
		case 9:
			//Base
			aadd(ret, [1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//				
			
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [-2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [0*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [1*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 8*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 9*(size.y+spacing.y), 0] + offset);//				
			break;
	}
	
	if(direction == 2){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.z, tmp.y, tmp.x];
		}
	}
	else if(direction == 3){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.y, tmp.x, tmp.z];
		}
	}else if(direction == -1){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [-tmp.x, tmp.y, tmp.z];
		}
	}else if(direction == -2){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.z, tmp.y, -tmp.x];
		}
	}else if(direction == -3){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.y, -tmp.x, tmp.z];
		}
	}
	
	return ret;
}

function CreateEnemyPositions(number, offset, size, spacing, direction){
	var ret = {};
	direction = valtype(direction) == "" ? 1 : direction;
	size = valtype(size) != "A" && valtype(size) != "V" ? [size, size] : size;
	spacing = valtype(spacing) != "A" && valtype(spacing) != "V" ? [spacing, spacing] : spacing;
	
	switch(number){	
		case 0:
			//Base
			aadd(ret, [3*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [4*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-4*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-5*(size.x+spacing.x), 0*(size.y+spacing.y), 0] + offset);//
						
			aadd(ret, [0*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-4*(size.x+spacing.x), 1*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [1*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 2*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [4*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [5*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//			
			aadd(ret, [-1*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-4*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-5*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-6*(size.x+spacing.x), 3*(size.y+spacing.y), 0] + offset);//
			
			aadd(ret, [0*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [3*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [4*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [5*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-1*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-4*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-5*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-6*(size.x+spacing.x), 4*(size.y+spacing.y), 0] + offset);//	
			
			aadd(ret, [0*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [4*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [5*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//			
			aadd(ret, [-1*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-4*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-5*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-6*(size.x+spacing.x), 5*(size.y+spacing.y), 0] + offset);//
			
			
			aadd(ret, [0*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [4*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//		
			aadd(ret, [-1*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-3*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-4*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-5*(size.x+spacing.x), 6*(size.y+spacing.y), 0] + offset);//
			
			
			aadd(ret, [0*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//	
			aadd(ret, [-1*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			aadd(ret, [-2*(size.x+spacing.x), 7*(size.y+spacing.y), 0] + offset);//
			break;
	}
	
	if(direction == 2){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.z, tmp.y, tmp.x];
		}
	}
	else if(direction == 3){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.y, tmp.x, tmp.z];
		}
	}else if(direction == -1){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [-tmp.x, tmp.y, tmp.z];
		}
	}else if(direction == -2){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.z, tmp.y, -tmp.x];
		}
	}else if(direction == -3){
		var tmp;
		for(var i = 0; i < len(ret); i++){
			tmp = ret[i];
			ret[i] = [tmp.y, -tmp.x, tmp.z];
		}
	}
	
	return ret;	
}

function GenerateColors(step){	
	var colors = {};
	var rgb = [1, 0, 0];
	while(rgb[1] <= 1){
		rgb += [0, step, 0];
		rgb -= [step, 0, 0];
		aadd(colors, [rgb[0], rgb[1], rgb[2]]);
	}
	
	while(rgb[2] <= 1){
		rgb += [0, 0, step];
		rgb -= [0, step, 0];
		aadd(colors, [rgb[0], rgb[1], rgb[2]]);
	}
	
	while(rgb[1] <= 1){
		rgb += [0, step, 0];
		aadd(colors, [rgb[0], rgb[1], rgb[2]]);
	}
	
	while(rgb[0] <= 1){
		rgb += [step, 0, 0];
		aadd(colors, [rgb[0], rgb[1], rgb[2]]);
	}
	
	while(rgb[1] >= 0){
		rgb -= [0, step, 0];
		aadd(colors, [rgb[0], rgb[1], rgb[2]]);
	}
	
	while(rgb[2] >= 0){
		rgb -= [0, 0, step];
		aadd(colors, [rgb[0], rgb[1], rgb[2]]);
	}
	
	return colors;
}


