function Print(strings, objects)
{
	if(valtype(strings) == "A")
	{
			output(strings[0] + ": ");
		output(objects[0]);
		
		for(var i = 1; i < len(strings); i++)
		{
			output("; " + strings[i] + ": ");
			output(objects[i]);
		}
		
		output("\n");
	}
	else
	{
		output(strings + ": ");
		output(objects);
		output("\n");
	}
}

// Doesn't support arrays
function PrintDebugBox(strings, objects)
{
	var totalText = "";
	
	if(valtype(strings) == "A")
	{
		for(var i = 0; i < len(strings); i++)
		{
			totalText += strings[i] + ": ";
			
			if(valtype(objects[i]) == "B")
				totalText += objects[i] ? "True" : "False";
			else
				totalText += str(objects[i]);
				
			totalText += ";\n ";
		}
		
		totalText += "\n";
	}
	else
	{
		totalText = strings;
	
		if(valtype(objects) == "B")
			totalText += objects ? "True" : "False";
		else
			totalText += str(objects);
	}
	
	ConsoleColor(1, 1, 0, 0.5);
	ConsoleFilledRect(0.4, 0.94, 0.2, 0.05);
	ConsoleColor(0, 0, 0, 1);
	ConsoleFont("Arial", 20);
	ConsoleText(0.40, 0.9, totalText);
	
}

/*
 * This function checks if a line segment intersects the given object; if it does, it returns the contact point, or Void otherwise
 * 
 * raycastOrigin: (vector) the start point of the line segment
 * raycastEnd: (vector) the end point of the line segment
 * object: (object) the object to check
 */
function IsObjectSelected(raycastOrigin, raycastEnd, object)
{	
	var contactPoint = Void;
	
	object.IsColliding(raycastOrigin, raycastEnd, &contactPoint);
	
	return contactPoint;
}

/*
 * This function checks if a line segment intersects a plane; if it does, it returns the contact point, or Void otherwise.
 * A line segment is defined by the start point and the end point. 
 * A plane is defined with a point belonging to the plane and the normal to the plane
 * 
 * raycastOrigin: (vector) the start point of the line segment
 * raycastEnd: (vector) the end point of the line segment
 * planePoint: (vector) the point belonging to the plane
 * planeNormal: (vector) the vector perpendicular to the plane
 */
function FindIntersectionInPlane(raycastOrigin, raycastEnd, planePoint, planeNormal)
{
	var pointInPlane = Void;
	
	// I first need to check if the raycast intersects the plane. To do that, I first get the direction of the raycast and I normalize it. The idea is 
	// to do the dot product between the direction of the raycast and the plane normal, and study the sign of the result. But this is not enough,
	// since the plane has a physical point where it's placed in the space, so we also need to check whether the raycast starts from one side of the plane or the other
	var raycastDirection = Norm(raycastOrigin - raycastEnd);
	
	// I get the direction between the starting point of the line and the plane, and normalize it. This helps me to find out on which side of the plane the ray
	// starts, by doing the dot product with the normal. The result will have positive values if the ray starts from one side, and negative values from the other side
	var directionToPlane = Norm(raycastOrigin - planePoint);
	
	// Doing the dot products
	var raycastNormalProduct = raycastDirection * planeNormal;
	var directionToPlaneNormalProduct = directionToPlane * planeNormal;
	
	// If the dot products have the same sign then the raycast is intersecting the plane. So, to check that easily I multiply the results and check the sign; if
	// it's positive, the ray intersects the plane, so we can look for the contact point
	if(raycastNormalProduct * directionToPlaneNormalProduct > 0)
	{
		/* Consider the ray as a line, with line equation r(t) = p0 + p1 * T where p0 is the starting point of the ray and p1 the ending point. To find the
		 * contact point on the plane, we have to find the right T and solve the equation. 
		 * Now consider a point q in the plane and the plane's normal n. For a point x to be on the plane this has to be true: n * (q - x) = 0 where the "*" 
		 * is the dot product. This has to be true because all points in the plane have to be perpendicular to n, so if we take from the point q that we
		 * know belongs to the plane and a random point x and take the vector that goes from one to the other, this vector has to be perpendicular to n for
		 * x to be on the plane; so the dot product has to be zero.
		 * Now, from that equation we need to substitute the "x" with the ray's equation:
		 * n * (q - p0 - p1 * T) = 0 --> n * (q - p0) - n * p1 * T = 0 --> n * (q - p0) = n * p1 * T --> n * (q - p0) / (p1 * n) = T 
		 * This is the equation we need to solve to get the right T; we have all the ingredients */
		var T = planeNormal * (planePoint - raycastOrigin) / (planeNormal * raycastEnd);
		
		// Now that we have T, let's solve the ray's equation and we've got our point
		pointInPlane = raycastOrigin + (raycastEnd * T);
	}
	
	return pointInPlane;
}

function ComputeNormalOfPlanarObject(object)
{
	var p0 = object.LocalToWorld([0, 0, 0]);
	var p1 = object.LocalToWorld([0, 1 * SCALE_FACTOR, 0]);
	var p2 = object.LocalToWorld([0, 0, 0]);
	var p3 = object.LocalToWorld([1 * SCALE_FACTOR, 0, 0]);
	
	var vec1 = p1 - p0;
	var vec2 = p3 - p2;
	
	var normal = Norm(vec1 ^ vec2);
	
	return normal;
}
