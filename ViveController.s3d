 
class ViveController
{
	var mViveController;
	
	var mControllerIndex;

	// Shader to draw the silhouettes of the objects contained in the ViveController
	var mSilhouetteShader;
	
	var mIsActionAvailable;
	
	var mTipLocalCoordinates;
	
	var mBoundingBox;
	
	var mWidth;
	var mHeight;
	var mDepth;
	
	var mIsVisible;
	
	var mBorderShader;
	
	// Public functions
	Draw();
	GetObj();
	GetIndex();
	SetActionAvailable(isActionAvailable);
	GetControllerTipCoordinates();
	GetDirection();
	SetPosition(position);
	GetPosition();
	SetRotationMatrix(matrix);
	GetRotationMatrix();
	Rotate(angle, x, y, z);
	SetRotation(angle, x, y, z);
	LocalToWorld(point);
	Hide();
	Unhide();
	SetScale(x, y, z);
	IsVisible();
	GetBoundingBox();
	GetWidth();
	GetHeight();
	GetDepth();
	IsCollidingBBox(object);
};


function ViveController::ViveController(controllerIndex)
{
	mControllerIndex = controllerIndex;
	
	var controllerMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Body/body.aam");
	

	mViveController = CVmObj(controllerMesh);
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/Button/button.aam")));
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/Led/led.aam")));
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/Left_grip/l_grip.aam")));
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/Right_Grip/r_grip.aam")));
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/System_Button/sys_button.aam")));
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/Trackpad/trackpad.aam")));
	mViveController.AddChild(CVmObj(CVmNewMesh("Vive_Controller_Mesh/Exported/Trigger/trigger.aam")));

	mBoundingBox = controllerMesh.GetBoundingBox();
	var point1 = [mBoundingBox[0], mBoundingBox[1], mBoundingBox[2]];
	var point2 = [mBoundingBox[3], mBoundingBox[4], mBoundingBox[5]];
	
	mWidth = abs(point2.x - point1.x);
	mHeight = abs(point2.y - point1.y);
	mDepth = abs(point2.z - point1.z);
	
	mTipLocalCoordinates = [0, 0, -mBoundingBox[5] + mBoundingBox[5] / 5.0];
	
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	
	mIsActionAvailable = false;
	
	mIsVisible = true;
	
	mBorderShader = CVmShaderProgram("void main(void) { gl_Position = ftransform(); }", "void main (void) { gl_FragColor = vec4(0.8, 0.8, 0.0, 1.0); }", true);
}

/*
 * This method draws the ViveController and any objects that was added to it. It makes sure to draw each object's silhouette and on top of it
 * the object itself using any shader that was added to it
 */
function ViveController::Draw()
{
	if(mIsActionAvailable)
	{
    	glCullFace (GL_FRONT);
    	
		mViveController.SetScale(1.03 , 1.03, 1.03);
	
		mBorderShader.Start();		
			mViveController.Draw();
		mBorderShader.Stop();
	
		// Now I draw the front faces
		glCullFace (GL_BACK);
		
		// Reactivate the shader and reset the scale
		mViveController.SetScale(1.0, 1.0, 1.0);
	}
	
	mViveController.Draw(VR_NO_CULLING);
}

function ViveController::GetObj()
{
	return mViveController;
}

function ViveController::GetIndex()
{
	return mControllerIndex;
}

function ViveController::SetActionAvailable(isActionAvailable)
{
	mIsActionAvailable = isActionAvailable;
}

function ViveController::GetControllerTipCoordinates()
{
	return mViveController.LocalToWorld(mTipLocalCoordinates);
}

function ViveController::GetDirection()
{
	var center = mViveController.LocalToWorld([0, 0, 0]);
	var tip = mViveController.LocalToWorld(mTipLocalCoordinates);
	
	return (tip - center);
}

function ViveController::SetPosition(position)
{
	mViveController.SetPosition(position);
}

function ViveController::GetPosition()
{
	return mViveController.GetPosition();
}

function ViveController::SetRotationMatrix(matrix)
{
	mViveController.SetRotationMatrix(matrix);
}

function ViveController::GetRotationMatrix()
{
	return mViveController.GetRotationMatrix();
}


function ViveController::Rotate(angle, x, y, z)
{
	mViveController.RotateAbs(angle, x, y, z);
}

function ViveController::SetRotation(angle, x, y, z)
{
	mViveController.SetRotation(angle, x, y, z);
}

function ViveController::LocalToWorld(point)
{
	return mViveController.LocalToWorld(point);
}

function ViveController::Hide()
{
	mViveController.Hide();
	mIsVisible = false;
}

function ViveController::Unhide()
{
	mViveController.Unhide();
	mIsVisible = true;
}

function ViveController::SetScale(x, y, z)
{
	return mViveController.SetScale(x, y, z);
}

function ViveController::IsVisible()
{
	return mIsVisible;
}

function ViveController::GetBoundingBox()
{
	return mBoundingBox;
}

function ViveController::GetWidth()
{
	return mWidth;
}

function ViveController::GetHeight()
{
	return mHeight;
}

function ViveController::GetDepth()
{
	return mDepth;
}

function ViveController::IsCollidingBBox(object)
{
	return mViveController.IsCollidingBBox(object);
}
