 
class ViveController
{
	var mViveController;
	
	var mControllerIndex;

	// Shader to draw the silhouettes of the objects contained in the ViveController
	var mSilhouetteShader;
	
	var mIsActionAvailable;
	
	var mTipLocalCoordinates;
	
	var mBoundingBox;
	
	var mWidth;
	var mHeight;
	var mDepth;
	
	var mIsVisible;
	
	var mBorderShader;
	
	var controllerMesh;
	var buttonMesh;
	var ledMesh;
	var leftGripMesh;
	var rightGripMesh;
	var systemButtonMesh;
	var trackpadMesh;
	var triggerMesh;
	
	var bodyObj;
	var buttonObj;
	var ledObj;
	var leftGripObj;
	var rightGripObj;
	var systemButtonObj;
	var trackpadObj;
	var triggerObj;
	
	var trackpadPointPos;
	var trackpadPointMesh;
	var trackpadPointObj;
	
	var buttonDepth;
	var trackpadDepth;
	var gripDepth;
	var leftGripPos;
	var rightGripPos;
	var systemButtonPos;
	var trackpadPos;
	var buttonPos;
	var triggerRange;
	var trackpadPointRange;
	
	// Public functions
	Draw();
	GetObj();
	GetIndex();
	SetActionAvailable(isActionAvailable);
	GetControllerTipCoordinates();
	GetDirection();
	SetPosition(position);
	GetPosition();
	SetRotationMatrix(matrix);
	GetRotationMatrix();
	Rotate(angle, x, y, z);
	SetRotation(angle, x, y, z);
	LocalToWorld(point);
	Hide();
	Unhide();
	SetScale(x, y, z);
	IsVisible();
	GetBoundingBox();
	GetWidth();
	GetHeight();
	GetDepth();
	IsCollidingBBox(object);
	UpdateStatus(touchPadCoord, triggerCoord, isMenuPressed, isTriggerPressed, isGripPressed, isTouchpadPressed);
};


function ViveController::ViveController(controllerIndex)
{
	mControllerIndex = controllerIndex;
	
	controllerMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Body/body.aam");
	buttonMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Button/button.aam");
	ledMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Led/led.aam");
	leftGripMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Left_grip/l_grip.aam");
	rightGripMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Right_Grip/r_grip.aam");
	systemButtonMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/System_Button/sys_button.aam");
	trackpadMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Trackpad/trackpad.aam");
	triggerMesh = CVmNewMesh("Vive_Controller_Mesh/Exported/Trigger/trigger.aam");
	
	
	bodyObj = CVmObj(controllerMesh);
	buttonObj = CVmObj(buttonMesh);
	ledObj = CVmObj(ledMesh);
	leftGripObj = CVmObj(leftGripMesh);
	rightGripObj = CVmObj(rightGripMesh);
	systemButtonObj = CVmObj(systemButtonMesh);
	trackpadObj = CVmObj(trackpadMesh);
	triggerObj = CVmObj(triggerMesh);
	
	buttonPos = buttonObj.GetPosition();
	leftGripPos = leftGripObj.GetPosition();
	rightGripPos = rightGripObj.GetPosition();
	systemButtonPos = systemButtonObj.GetPosition();
	trackpadPos = trackpadObj.GetPosition();
	triggerRange = [3,3];
	trackpadPointRange = [3,3];
	
	buttonDepth = 0.0075*SCALE_FACTOR;
	trackpadDepth = 0.015*SCALE_FACTOR;
	gripDepth = 0.004*SCALE_FACTOR;
	
	trackpadPointMesh = CVmNewMesh(VRP_CIRCLE, 30, 0.008*SCALE_FACTOR, 1);
	trackpadPointObj = CVmObj(trackpadPointMesh);
	trackpadPointPos = trackpadPos+[0, 0.05*SCALE_FACTOR, 0];
	trackpadObj.AddChild(trackpadPointObj);
	
	mViveController = CVmObj();
	mViveController.AddChild(bodyObj);
	mViveController.AddChild(buttonObj);
	mViveController.AddChild(ledObj);
	mViveController.AddChild(leftGripObj);
	mViveController.AddChild(rightGripObj);
	mViveController.AddChild(systemButtonObj);
	mViveController.AddChild(trackpadObj);
	mViveController.AddChild(triggerObj);

	mBoundingBox = controllerMesh.GetBoundingBox();
	var point1 = [mBoundingBox[0], mBoundingBox[1], mBoundingBox[2]];
	var point2 = [mBoundingBox[3], mBoundingBox[4], mBoundingBox[5]];
	
	mWidth = abs(point2.x - point1.x);
	mHeight = abs(point2.y - point1.y);
	mDepth = abs(point2.z - point1.z);
	
	mTipLocalCoordinates = [0, 0, -mBoundingBox[5] + mBoundingBox[5] / 5.0];
	
	mSilhouetteShader = CVmShaderProgram("silhouetteShader.glsl");
	
	mIsActionAvailable = false;
	
	mIsVisible = true;
	
	mBorderShader = CVmShaderProgram("void main(void) { gl_Position = ftransform(); }", "void main (void) { gl_FragColor = vec4(0.8, 0.8, 0.0, 1.0); }", true);
}

/*
 * This method updates the visual status of the vive controller
 */
function ViveController::UpdateStatus(touchPadCoord, triggerCoord, isMenuPressed, isTriggerPressed, isGripPressed, isTouchpadPressed){
	if(touchPadCoord[0] < 0){
		trackpadPointObj.Hide();		
	}
	else{
		trackpadPointObj.Unhide();
		trackpadPointPos = trackpadPos+[touchPadCoord[0]/trackpadPointRange[0], trackpadPointPos.y, touchPadCoord[1]/trackpadPointRange[1]];	
		trackpadPointObj.SetPosition(trackpadPointPos);
	}
	
	if(triggerCoord[0] > 0){
		triggerObj.SetRotation(triggerCoord[0],0,0,1);
		//Rotate trigger around tip point
	}
	
	if(isMenuPressed){
		buttonObj.SetPosition(buttonPos - [0, buttonDepth, 0]);
	}
	else{
		buttonObj.SetPosition(buttonPos);		
	}
	
	if(isGripPressed){
		leftGripObj.SetPosition(leftGripPos + [gripDepth, 0, 0]);
		rightGripObj.SetPosition(rightGripPos - [gripDepth, 0, 0]);
	}
	else{
		leftGripObj.SetPosition(leftGripPos);
		rightGripObj.SetPosition(rightGripPos);		
	}
	
	if(isTouchpadPressed){
		trackpadObj.SetPosition(trackpadPos - [0, trackpadDepth, 0]);
	}
	else{
		trackpadObj.SetPosition(trackpadPos);		
	}
}

/*
 * This method draws the ViveController and any objects that was added to it. It makes sure to draw each object's silhouette and on top of it
 * the object itself using any shader that was added to it
 */
function ViveController::Draw()
{
	if(mIsActionAvailable)
	{
    	glCullFace (GL_FRONT);
    	
		mViveController.SetScale(1.03 , 1.03, 1.03);
	
		mBorderShader.Start();		
			mViveController.Draw();
		mBorderShader.Stop();
	
		// Now I draw the front faces
		glCullFace (GL_BACK);
		
		// Reactivate the shader and reset the scale
		mViveController.SetScale(1.0, 1.0, 1.0);
	}
	
	mViveController.Draw(VR_NO_CULLING);
}

function ViveController::GetObj()
{
	return mViveController;
}

function ViveController::GetIndex()
{
	return mControllerIndex;
}

function ViveController::SetActionAvailable(isActionAvailable)
{
	mIsActionAvailable = isActionAvailable;
}

function ViveController::GetControllerTipCoordinates()
{
	return mViveController.LocalToWorld(mTipLocalCoordinates);
}

function ViveController::GetDirection()
{
	var center = mViveController.LocalToWorld([0, 0, 0]);
	var tip = mViveController.LocalToWorld(mTipLocalCoordinates);
	
	return (tip - center);
}

function ViveController::SetPosition(position)
{
	mViveController.SetPosition(position);
}

function ViveController::GetPosition()
{
	return mViveController.GetPosition();
}

function ViveController::SetRotationMatrix(matrix)
{
	mViveController.SetRotationMatrix(matrix);
}

function ViveController::GetRotationMatrix()
{
	return mViveController.GetRotationMatrix();
}


function ViveController::Rotate(angle, x, y, z)
{
	mViveController.RotateAbs(angle, x, y, z);
}

function ViveController::SetRotation(angle, x, y, z)
{
	mViveController.SetRotation(angle, x, y, z);
}

function ViveController::LocalToWorld(point)
{
	return mViveController.LocalToWorld(point);
}

function ViveController::Hide()
{
	mViveController.Hide();
	mIsVisible = false;
}

function ViveController::Unhide()
{
	mViveController.Unhide();
	mIsVisible = true;
}

function ViveController::SetScale(x, y, z)
{
	return mViveController.SetScale(x, y, z);
}

function ViveController::IsVisible()
{
	return mIsVisible;
}

function ViveController::GetBoundingBox()
{
	return mBoundingBox;
}

function ViveController::GetWidth()
{
	return mWidth;
}

function ViveController::GetHeight()
{
	return mHeight;
}

function ViveController::GetDepth()
{
	return mDepth;
}

function ViveController::IsCollidingBBox(object)
{
	return mViveController.IsCollidingBBox(object);
}
