class Target{	
	var mObj;
	var mHit;
	var mShootDelay;
	var mLives;
	var mColor;
	var mActualColor;
	var mHitColor;
	var mMesh;
	var mSpeed;
	
	var mColorTransitionTime;
	var mScalingTransitionTime;
	var mIsChangingColor;
	
	var mHitTime;
	var mShootTime;
	var mLaserMesh;
	
	var mAnimator;
	
	var mKilled;
	var mKilledTime;
	
	var mLaserSpeed;
	var mLaserMaxDistance;
	
	var mHasLasers;
	var mMoving;
	var mRotating;
	var mColorTransition;
	
	Draw();
	GetObj();
	IsCollidingBBoxOnly(startPos, endPos);
	GetLives();
	RemoveLife();
	Update(mMainRoom);
	UpdateTransition(mMainRoom);
	UpdateColor();
	Kill();
	IsDead();
	Hit();	
	SetPosition(x,y,z);
	GetMesh();
	HandleEnemyLaser(cameraPosition);
	IsCollidingBBox(object);
};

function Target::Target(mesh, lives, shootDelay, color, hitColor, speed, hasLasers, moving, rotating, colorTransition, laserSpeed, laserMesh, laserMaxDistance,  animator){
	mAnimator = animator; 
	mObj = mesh.__GetName() == "CVMNEWMESH" || mesh.__GetName() == "CVMMESH" ? CVmObj(mesh) : mesh;
	mLives = lives;
	mShootDelay = shootDelay;
	mColor = color;
	mHitColor = hitColor;
	mSpeed = speed;
	mActualColor = color;
	mHasLasers = hasLasers;
	mMoving = moving;
	mRotating = rotating;
	mColorTransition = colorTransition;
	
	mLaserSpeed = laserSpeed;
	mLaserMesh = laserMesh;
	mLaserMaxDistance = laserMaxDistance;
	
	mIsChangingColor = -1;
	mColorTransitionTime = 0.15;
	
	mScalingTransitionTime = 0.25;
	
	mHitTime = 0;
	mShootTime = 0;
	
	mKilledTime = -1;
	mKilled = false;
	
	if(mRotating){		
		var rotationAxis = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		mAnimator.CreateRotatingTransition(mObj, 0, 360, rotationAxis, 5.0 + Rand(5) / 2.0, true, false);
	}
	
	if(mColorTransition){
		var color1 = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		var color2 = [Rand(10) / 10.0, Rand(10) / 10.0, Rand(10) / 10.0];
		mAnimator.CreateToonShaderColorTransition(mObj.GetMesh(), color1, color2, 3.5, true);}
	}

function Target::Draw(){
	mObj.Draw();
}

function Target::GetObj(){
	return mObj;
}

function Target::IsCollidingBBoxOnly(startPos, endPos){
	return mObj.IsCollidingBBoxOnly(startPos, endPos);
}

function Target::GetLives(){
	return mLives;
}

function Target::RemoveLife(){
	return --mLives;
}

function Target::Hit(){
	mIsChangingColor = 1;
	return !mKilled;
}

function Target::Update(mMainRoom){
	UpdateColor();
	if(!mKilled && mMoving){
		UpdateTransition(mMainRoom);
	}
}

function Target::Kill(){
	mKilled = true;
	mKilledTime = GetTime();
	mAnimator.CreateScalingTransition(mObj, [1, 1, 1], [0, 0, 0], mScalingTransitionTime, false, 3);
}

function Target::UpdateTransition(mMainRoom){
	if(!mAnimator.HaveTransition(mObj,0)){
		var roomPos = mMainRoom.GetPosition();
		var roomWidthHalved = mMainRoom.GetRoomWidth() / 2.0;
		var roomHeightHalved = mMainRoom.GetRoomHeight() / 2.0;
		var roomDepthHalved = mMainRoom.GetRoomDepth() / 2.0;
		
		var posX = (roomPos.x - mMainRoom.GetRoomWidth() / 2.0) + Rand(mMainRoom.GetRoomWidth() - 10.0 * SCALE_FACTOR);
		var posY = (roomPos.y - mMainRoom.GetRoomHeight() / 2.0 +  5.0 * SCALE_FACTOR) + Rand(mMainRoom.GetRoomHeight() - 10.0 * SCALE_FACTOR);
		var posZ = (roomPos.z) + Rand(mMainRoom.GetRoomDepth() - 10.0 * SCALE_FACTOR);
		
		var targetPos = mObj.GetPosition();
		
		var newPosX = [targetPos.x + roomWidthHalved, targetPos.y, targetPos.z];
		var newPosY = [targetPos.x, targetPos.y + roomHeightHalved, targetPos.z];
		var newPosZ = [targetPos.x, targetPos.y, targetPos.z + roomDepthHalved];
		
		var pos = [0, 0, 0];
		
		pos.x = mMainRoom.IsPointInRoom(newPosX) ? newPosX.x : targetPos.x - roomWidthHalved;
		pos.y = mMainRoom.IsPointInRoom(newPosY) ? newPosY.y : targetPos.y - roomHeightHalved;
		pos.z = mMainRoom.IsPointInRoom(newPosZ) ? newPosZ.z : targetPos.z - roomDepthHalved;

//				var time = ToFloat(Rand(3.0) + 1.0);
		var time = 3.0;
	
		mAnimator.CreateTransition(mObj, mObj.GetPosition(), [posX, posY, posZ], mSpeed, false, 2);		
	}
	
}

function Target::UpdateColor(){
	if(mIsChangingColor != -1){
		if(mIsChangingColor == 1){
			mAnimator.CreateToonShaderColorTransition(mObj.GetMesh(), mColor, mHitColor, mColorTransitionTime, false);
			if(!mKilled)
				mAnimator.CreateScalingTransition(mObj, [1, 1, 1], [0.8, 0.8, 0.8], mColorTransitionTime, false, 3);
			mHitTime = GetTime();
			mIsChangingColor = 2;				
		}
		else if(mIsChangingColor == 2 && GetTime()-mHitTime > (mColorTransitionTime*1000)){
			mAnimator.CreateToonShaderColorTransition(mObj.GetMesh(), mHitColor, mColor, mColorTransitionTime, false);
			if(!mKilled)
				mAnimator.CreateScalingTransition(mObj, [0.8, 0.8, 0.8], [1,1,1], mColorTransitionTime, false, 3);
			mIsChangingColor = -1;
		}	
	}
}

function Target::SetPosition(x,y,z){
	mObj.SetPosition(valtype(x) != "A" && valtype(x) != "V" ? [x,y,z] : x);
}

function Target::GetMesh(){
	return mObj.GetMesh();
}

function Target::IsDead(){
	return mKilled && GetTime() - mKilledTime > (mScalingTransitionTime*1000);
}

function Target::HandleEnemyLaser(cameraPosition){
	if(GetTIme()-mShootTime > mShootDelay && mHasLasers){
		mShootTime = GetTime();
		var pos = mObj.GetPosition();
		var laserObj = CvmObj(mLaserMesh);
		mAnimator.CreateTransition(laserObj, pos, [cameraPosition.x-pos.x, cameraPosition.y-pos.y, cameraPosition.z-pos.z]*mLaserMaxDistance, mLaserSpeed, false, 0);
		return laserObj;
	}
	return null;
} 

function Target::IsCollidingBBox(object){
	return mObj.IsCollidingBBox(object);
}