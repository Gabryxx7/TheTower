class Target{	
	var mObj;
	var mHit;
	var mShootDelay;
	var mTotalLives;
	var mLives;
	var mColor;
	var mActualColor;
	var mHitColor;
	var mMesh;
	var mSpeed;
	
	var mColorTransitionTime;
	var mScalingTransitionTime;
	var mIsChangingColor;
	
	var mHitTime;
	var mShootTime;
	var mLaserMesh;
	
	var mAnimator;
	
	var mKilled;
	var mKilledTime;
	
	var mLaserSpeed;
	var mLaserMaxDistance;
	
	Draw();
	GetObj();
	IsCollidingBBoxOnly(startPos, endPos);
	GetLives();
	ResetLife();
	RemoveLife();
	Update(mMainRoom);
	UpdateTransition(mMainRoom);
	UpdateColor();
	Kill();
	IsDead();
	Hit();	
	SetPosition(x,y,z);
	GetMesh();
	HandleEnemyLaser(cameraPosition);
	IsCollidingBBox(object);
};

function Target::Target(mesh, lives, shootDelay, color, hitColor, speed, laserSpeed, laserMesh, laserMaxDistance,  animator){
	mAnimator = animator; 
	mObj = mesh.__GetName() == "CVMNEWMESH" || mesh.__GetName() == "CVMMESH" ? CVmObj(mesh) : mesh;
	mTotalLives = lives;
	mLives = lives;
	mShootDelay = shootDelay;
	mColor = color;
	mHitColor = hitColor;
	mSpeed = speed;
	mActualColor = color;
	
	mLaserSpeed = laserSpeed;
	mLaserMesh = laserMesh;
	mLaserMaxDistance = laserMaxDistance;
	
	mIsChangingColor = -1;
	mColorTransitionTime = 0.15;
	
	mScalingTransitionTime = 0.25;
	
	mHitTime = 0;
	mShootTime = 0;
	
	mKilledTime = -1;
	mKilled = false;
}

function Target::Draw(){
	mObj.Draw();
}

function Target::GetObj(){
	return mObj;
}

function Target::IsCollidingBBoxOnly(startPos, endPos){
	return mObj.IsCollidingBBoxOnly(startPos, endPos);
}

function Target::GetLives(){
	return mLives;
}

function Target::ResetLife(){
	mLives = mTotalLives;
	mAnimator.CreateScalingTransition(mObj, [0.0, 0.0, 0.0], [1,1,1], mColorTransitionTime, false, 3);
	mKilledTime = -1;
	mKilled = false;
	
}

function Target::RemoveLife(){
	return --mLives;
}

function Target::Hit(){
	mIsChangingColor = 1;
	return !mKilled;
}

function Target::Update(mMainRoom){
	UpdateColor();
	if(!mKilled){
		UpdateTransition(mMainRoom);
	}
}

function Target::Kill(){
	mKilled = true;
	mKilledTime = GetTime();
	mAnimator.CreateScalingTransition(mObj, [1, 1, 1], [0, 0, 0], mScalingTransitionTime, false, 3);
}

function Target::UpdateTransition(mMainRoom){
	if(!mAnimator.HaveTransition(mObj,0)){
		var roomPos = mMainRoom.GetPosition();
		var roomWidthHalved = mMainRoom.GetRoomWidth() / 2.0;
		var roomHeightHalved = mMainRoom.GetRoomHeight() / 2.0;
		var roomDepthHalved = mMainRoom.GetRoomDepth() / 2.0;
		
		var posX = (roomPos.x - mMainRoom.GetRoomWidth() / 2.0) + Rand(mMainRoom.GetRoomWidth() - 10.0 * SCALE_FACTOR);
		var posY = (roomPos.y - mMainRoom.GetRoomHeight() / 2.0 +  5.0 * SCALE_FACTOR) + Rand(mMainRoom.GetRoomHeight() - 10.0 * SCALE_FACTOR);
		var posZ = (roomPos.z) + Rand(mMainRoom.GetRoomDepth() - 10.0 * SCALE_FACTOR);
		
		var targetPos = mObj.GetPosition();
		
		var newPosX = [targetPos.x + roomWidthHalved, targetPos.y, targetPos.z];
		var newPosY = [targetPos.x, targetPos.y + roomHeightHalved, targetPos.z];
		var newPosZ = [targetPos.x, targetPos.y, targetPos.z + roomDepthHalved];
		
		var pos = [0, 0, 0];
		
		pos.x = mMainRoom.IsPointInRoom(newPosX) ? newPosX.x : targetPos.x - roomWidthHalved;
		pos.y = mMainRoom.IsPointInRoom(newPosY) ? newPosY.y : targetPos.y - roomHeightHalved;
		pos.z = mMainRoom.IsPointInRoom(newPosZ) ? newPosZ.z : targetPos.z - roomDepthHalved;

		var time = 3.0;
	
		mAnimator.CreateTransition(mObj, mObj.GetPosition(), [posX, posY, posZ], mSpeed, false, 2);		
	}
}

function Target::UpdateColor(){
	if(mIsChangingColor != -1){
		if(mIsChangingColor == 1){
			mAnimator.CreateToonShaderColorTransition(mObj.GetMesh(), mColor, mHitColor, mColorTransitionTime, false);
			if(!mKilled)
				mAnimator.CreateScalingTransition(mObj, [1, 1, 1], [0.8, 0.8, 0.8], mColorTransitionTime, false, 3);
			mHitTime = GetTime();
			mIsChangingColor = 2;				
		}
		else if(mIsChangingColor == 2 && GetTime()-mHitTime > (mColorTransitionTime*1000)){
			mAnimator.CreateToonShaderColorTransition(mObj.GetMesh(), mHitColor, mColor, mColorTransitionTime, false);
			if(!mKilled)
				mAnimator.CreateScalingTransition(mObj, [0.8, 0.8, 0.8], [1,1,1], mColorTransitionTime, false, 3);
			mIsChangingColor = -1;
		}	
	}
}

function Target::SetPosition(x,y,z){
	mObj.SetPosition(valtype(x) != "A" && valtype(x) != "V" ? [x,y,z] : x);
}

function Target::GetMesh(){
	return mObj.GetMesh();
}

function Target::IsDead(){
	return mKilled && GetTime() - mKilledTime > (mScalingTransitionTime*1000);
}

function Target::HandleEnemyLaser(cameraPosition){
	if(GetTIme()-mShootTime > mShootDelay){
		mShootTime = GetTime();
		var pos = mObj.GetPosition();
		var laserObj = CvmObj(mLaserMesh);
		
		// Now I need to rotate the laser object so that it points towards the player. First, I take the direction that goes from the previous 
		// point to the current one. Note that the order of the difference is important: I need the direction that goes from the previous point
		// to the current one
		var vec = Norm(pos - cameraPosition);
		
		// To compute the angle around which to rotate the object, I compute the cross product between this vector and the up vector (the vector
		// that tells me which way is up); the result will be a vector perpendicular to the 2, which I normalize to use it as a normal.
		// I then switch sign, otherwise it turns on the opposite side
		var axis = -Norm(vec ^ [0, 1, 0]);
		
		// I now compute the angle for the rotation. The formula derives from "easy" trigonometry (lookup "finding angle between 2 vectors").
		// I'm not sure why the final angle is shifted by 180 degrees; that's why I subtract 180
		var angle = acos((Norm(vec) * [0, 1, 0])) * RAD_TO_GRAD - 180; 
		
		laserObj.SetRotation(angle, axis.x, axis.y, axis.z);
		
		mAnimator.CreateTransition(laserObj, pos, [cameraPosition.x-pos.x, cameraPosition.y-pos.y, cameraPosition.z-pos.z]*mLaserMaxDistance, mLaserSpeed, false, 0);
		return laserObj;
	}
	return null;
} 

function Target::IsCollidingBBox(object){
	return mObj.IsCollidingBBox(object);
}