class Numpad{	
	var mButtonsObjs;
	var mPressedButtonsObjs;
	var mUnpressedButtonsObjs;
	var mTextsObjs;
	var mScreenTextsMeshes;
	var mCharOnScreen;
	var mHolderObj;
	var mHolderSizes;
	var mScreenObj;
	var mScreenNumbersObj;
	var mScreenTextSize;
	var mMaxDigitsOnScreen;
	var mCharacters;
	var mUnpressedButtonColor;
	var mPressedButtonColor;
	var mWrongCodeColor;
	var mTextColor;
	var mButtonsThickness;
	var mButtonsWidth;
	var mOriginalButtonPos;
	var mOriginalTextPos;
	var mTextOffset;
	var mTimefromLastAction;
	var mNumpadPosition;
	
	Draw(drawButtons, drawPressedButtons, drawText);
	DrawHolder();
	DrawScreen();
	DrawScreenNumbers();
	GetButtonsObjs();
	GetHolderObj();
	GetHolderSizes();
	GetUnpressedButtonsObjs();
	GetPressedButtonsObjs();
	GetTextsObjs();
	GetUnpressedButtonColor();
	GetPressedButtonColor();
	GetWrongCodeColor();
	GetTextColor();
	GetButtonObj(buttonChar);
	GetNumpadCharacters();	
	AnimateButton(buttonChar, mAnimator);
	PressButton(buttonChar);
	PressPointedButton(mCamera, cameraPosition);
	PressTouchedButton(objPos, dt, pViveObj, controllerIndex);
	UnpressButton(buttonChar);
	UnpressAllButtons();
	PressAllButtons();
	
	IsCameraInNumpadRange(cameraPosition, range);
};


function Numpad::Numpad(buttonsText, tilesSize, spaceSize, tilesThickness, numpadPosition, unpressedButtonColor, pressedButtonColor, wrongCodeColor, textColor, holderSize, maxDigitsOnScreen){
	mTimefromLastAction = 0;
	mNumpadPosition = numpadPosition;
	mTextsObjs = {};
	mButtonsObjs = {};
	mScreenTextsMeshes = {};
	mScreenObj =  CvmObj();
	mCharOnScreen = {};
	mPressedButtonsObjs = {};
	mUnpressedButtonsObjs = {};
	mCharacters = {};
	mOriginalButtonPos = {};
	mOriginalTextPos = {};
	mPressedButtonColor = pressedButtonColor;
	mUnpressedButtonColor = unpressedButtonColor;
	mWrongCodeColor = wrongCodeColor;
	mTextColor = textColor;
	mButtonsThickness = tilesThickness;
	mButtonsWidth = tilesSize;
	mTextOffset = 0.02*SCALE_FACTOR;
	mHolderSizes = holderSize;
	mHolderObj = CvmObj(CVmNewMesh(VRP_BOX, 1, [-holderSize.x/2, 0, 0], [holderSize.x/2, holderSize.y, 0], holderSize.z));	
	mHolderObj.SetPosition(numpadPosition.x+mButtonsWidth, 0, numpadPosition.z-mButtonsThickness);
	
	mScreenTextSize = mButtonsWidth * 0.7;

	var withHolder = false;
	if(valtype(holderSize) == "A")
		withHolder = true;
		
	
	var buttonMesh = CVmNewMesh(VRP_BOX, 1, [-mButtonsWidth/2, -mButtonsWidth/2, 0], [mButtonsWidth/2, mButtonsWidth/2, 0], mButtonsThickness);
	var offsetY = mButtonsWidth + spaceSize;
	var offsetX = mButtonsWidth + spaceSize;
	var offsetZ = mButtonsThickness;
	
	var txt;
	var txtObj;
	var buttonObj;
	var num = 9;
	var rows = 0;
	var cols = 0;
	for(var i = 0; i < len(buttonsText) ; i++){	
		if(buttonsText[i] == "\n"){
			if(cols == 0){
				mMaxDigitsOnScreen = valtype(maxDigitsOnScreen) == "I" ? maxDigitsOnScreen : rows+2;
				mScreenObj.AddChild(CvmObj(CVmNewMesh(VRP_PLANE, 1, [-(mMaxDigitsOnScreen*mScreenTextSize)/2-0.2*SCALE_FACTOR, -offsetY/2, 0], [(mMaxDigitsOnScreen*mScreenTextSize)/2+0.2*SCALE_FACTOR, offsetY/2, 0], 2, 2)));
				mScreenObj.SetPosition(numpadPosition + [offsetX*(rows-1)/2, +spaceSize-mButtonsWidth,-mButtonsThickness + 0.1*SCALE_FACTOR]);
				mScreenNumbersObj = CVmObj();
				mScreenNumbersObj.SetPosition(numpadPosition + [offsetX*(rows-1)/2, +spaceSize-mButtonsWidth, -mButtonsThickness + 0.1*SCALE_FACTOR]);
			}
			i++;
			cols++;
			rows = 0;	
		}			
		var buttonPos = numpadPosition + [(offsetX * (rows++)), -offsetY*(cols), 0] ;
		
		txt = CVmText();		
		txt.Load(upper(buttonsText[i]));
		txt.SetColor(textColor.r, textColor.g, textColor.b);
		
		
		txtObj = CVmObj();
		txtObj.LinkToText(txt);
		txtObj.SetScale(0.1,0.1,0.1);
		txtObj.SetPosition(buttonPos.x-(0.1*SCALE_FACTOR), buttonPos.y - (1.65*SCALE_FACTOR), buttonPos.z + mTextOffset);
		
		buttonObj = CVmObj(buttonMesh);
		buttonObj.SetPosition(buttonPos.x, buttonPos.y - (1.5*SCALE_FACTOR), buttonPos.z);	
		
		aadd(mCharacters, lower(buttonsText[i]));
		aadd(mOriginalButtonPos, buttonObj.GetPosition());
		aadd(mOriginalTextPos, txtObj.GetPosition());
		aadd(mTextsObjs, txtObj);
		aadd(mButtonsObjs, buttonObj);
		aadd(mUnpressedButtonsObjs, buttonObj);	
		
		
		var screenTxt = CVmText();		
		screenTxt.Load(upper(buttonsText[i]));
		screenTxt.SetColor(textColor.r, textColor.g, textColor.b);
		aadd(mScreenTextsMeshes, screenTxt);
	}	
}


function Numpad::Draw(drawUnpressedButtons, drawPressedButtons, drawText){
	if(valtype(drawUnpressedButtons) == "")
		drawUnpressedButtons = 1;		
	
	if(valtype(drawText) == "")
		drawText = 1;
		
	if(valtype(drawPressedButtons) == "")
		drawPressedButtons = 0;
		
	if(drawUnpressedButtons == 1){
		for(var i = 0; i < len(mUnpressedButtonsObjs); i++)
			mUnpressedButtonsObjs[i].Draw();			
	}
	
	if(drawPressedButtons == 1){
		for(var i = 0; i < len(mPressedButtonsObjs); i++)
			mPressedButtonsObjs[i].Draw();			
	}
	
	if(drawText == 1){
		for(var i = 0; i < len(mTextsObjs); i++)
			mTextsObjs[i].Draw();				
	}
}

function Numpad::DrawHolder(){
	mHolderObj.Draw();
}

function Numpad::DrawScreen(){
	mScreenObj.Draw();
}

function Numpad::DrawScreenNumbers(){
	mScreenNumbersObj.Draw();
}


function Numpad::GetButtonsObjs(){	
	return mButtonsObjs;
}

function Numpad::GetHolderObj(){
	return mHolderObj;
}

function Numpad::GetHolderSizes(){
	return mHolderSizes;
}

function Numpad::GetButtonObj(buttonChar){	
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters == buttonChar)
			return mButtonsObjs[i];
	}
}

function Numpad::GetNumpadCharacters(){
	return mCharacters;
}


function Numpad::GetUnpressedButtonsObjs(){	
	return mUnpressedButtonsObjs;
}

function Numpad::GetPressedButtonsObjs(){	
	return mPressedButtonsObjs;
}

function Numpad::GetTextsObjs(){
	return mTextsObjs;
}

function Numpad::GetUnpressedButtonColor(){
	return mUnpressedButtonColor;
}

function Numpad::GetPressedButtonColor(){
	return mPressedButtonColor;
}

function Numpad::GetWrongCodeColor(){
	return mWrongCodeColor;
}

function Numpad::GetTextColor(){
	return mTextColor;
}

function Numpad::AnimateButton(buttonChar, mAnimator){	
	var charPos = -1;
	//CHeck if char is present in the numpad
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters[i] == buttonChar)
			charPos = i;
	}
	if(charPos == -1)
		return false;
		
	mAnimator.CreateTransition(mButtonsObjs[charPos], mOriginalButtonPos[charPos], {mOriginalButtonPos[charPos] - [0, 0, mButtonsThickness*0.8], mOriginalButtonPos[charPos]}, 0.25, false);
	mAnimator.CreateTransition(mTextsObjs[charPos], mOriginalTextPos[charPos], {mOriginalTextPos[charPos] - [0, 0, mButtonsThickness*0.8], mOriginalTextPos[charPos]}, 0.25, false);
	return true;
}

function Numpad::PressPointedButton(mCamera, cameraPosition){	
	var raycastOrigin = cameraPosition;
	var raycastEnd = raycastOrigin + mCamera.GetDirection() * mCamera.GetZFar();
	var contactPoint;
	
	for(var i = 0; i < len(mButtonsObjs); i++){
		contactPoint = IsObjectSelected(raycastOrigin, raycastEnd, mButtonsObjs[i]);
		if(contactPoint != Void){
			PressButton(mCharacters[i]);
			return mCharacters[i];	
		}	
	}
	
	return "";
}

//-1 not present, 0 already pressed, 1 was not pressed, now it is pressed
function Numpad::PressButton(buttonChar){
	var charPos = -1;
	//CHeck if char is present in the numpad
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters[i] == buttonChar)
			charPos = i;
	}
	
	if(charPos == -1)
		return -1;
	
	//If it's present, I should check if it is already pressed
	var alreadyPressed = false;
	for(var i = 0; i < len(mPressedButtonsObjs); i++){
		if(mPressedButtonsObjs[i] == mButtonsObjs[charPos])
			alreadyPressed = true;
	}
	
	//I add it anyway to the screen (Pressing multiple times)	
	var charObj = CVmObj();
	charObj.LinkToText(mScreenTextsMeshes[charPos]);
	aadd(mCharOnScreen, charObj);
	charObj.SetScale(0.1,0.1,0.1);
	mScreenNumbersObj.AddChild(charObj, -(mMaxDigitsOnScreen*mScreenTextSize)/2 + (len(mCharOnScreen)-1)*mScreenTextSize +mScreenTextSize/4, -0.15*SCALE_FACTOR, 0.05*SCALE_FACTOR);
	
	//If it is not already pressed, I add it to the pressed buttons vector
	if(!alreadyPressed){
		aadd(mPressedButtonsObjs, mButtonsObjs[charPos]);
		//If it was not pressed, I have to remove it from the unpressed buttons
		for(var i = 0; i < len(mUnpressedButtonsObjs); i++){
			if(mUnpressedButtonsObjs[i] == mButtonsObjs[charPos]){
				adel(mUnpressedButtonsObjs, i);	
				return 1;
			}			
		}	
	}
	else 
		return 0; //if it was pressed already then there is nothing to do here
	
	return 1;
}

function Numpad::UnpressButton(buttonChar){	
	var charPos = -1;
	//CHeck if char is present in the numpad
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters[i] == buttonChar)
			charPos = i;
	}
	
	if(charPos == -1)
		return false;
	
	//If it's present, I should check if it is pressed or unpressed
	var alreadyUnpressed = false;
	for(var i = 0; i < len(mUnpressedButtonsObjs); i++){
		if(mUnpressedButtonsObjs[i] == mButtonsObjs[charPos])
			alreadyUnpressed = true;
	}
	
	//If it is pressed, I add it to the unpressed buttons vector
	if(!alreadyUnpressed){
		aadd(mUnpressedButtonsObjs, mButtonsObjs[charPos]);	
	}
	else 
		return true; //if it was pressed already then there is nothing to do here
		
	//If it was pressed, I have to remove it from the pressed buttons
	for(var i = 0; i < len(mPressedButtonsObjs); i++){
		if(mPressedButtonsObjs[i] == mButtonsObjs[charPos]){
			adel(mPressedButtonsObjs, i);	
			return true;				
		}			
	}	
	
	return true;
}

function Numpad::PressTouchedButton(objPos, dt, inputManager, controllerIndex){
	mTimefromLastAction += dt;
	var usingVive = valtype(inputManager) == "" ? false : true;
	var buttonPos;
	var maxDepth = mButtonsThickness * 0.8;
	var offsets = [mButtonsWidth/2, mButtonsWidth/2, mButtonsThickness];
	for(var i = 0; i < len(mButtonsObjs); i++){
		buttonPos = mOriginalButtonPos[i];
		if(objPos.x >= buttonPos.x - offsets.x && objPos.x <= buttonPos.x + offsets.x
		&& objPos.y >= buttonPos.y - offsets.y && objPos.y <= buttonPos.y + offsets.y){
			if(objPos.z >= buttonPos.z - maxDepth && objPos.z <= buttonPos.z){
				mButtonsObjs[i].SetPosition([mOriginalButtonPos[i].x, mOriginalButtonPos[i].y, objPos.z]);
				mTextsObjs[i].SetPosition([mOriginalTextPos[i].x, mOriginalTextPos[i].y, objPos.z + mTextOffset]);
				if(mTimefromLastAction > 0.4){
					mTimefromLastAction = 0;
					if(PressButton(mCharacters[i]) > -1){
						if(usingVive){
							inputManager.VibrateController(controllerIndex, 100);
						}
						return mCharacters[i];						
					}
				}
				return "";
			}
		}
		else{
			mButtonsObjs[i].SetPosition(mOriginalButtonPos[i]);
			mTextsObjs[i].SetPosition(mOriginalTextPos[i]);
		}
	}	
	return "";
}

function Numpad::PressAllButtons(){	
	while(len(mPressedButtonsObjs) > 0){
		adel(mPressedButtonsObjs, 0);		
	}	
	
	while(len(mUnpressedButtonsObjs) > 0){
		adel(mUnpressedButtonsObjs, 0);		
	}
	
	for(var i = 0; i < len(mButtonsObjs); i++){		
		aadd(mPressedButtonsObjs, mButtonsObjs[i]);	
	}
}

function Numpad::UnpressAllButtons(){		
	//Remove chars from the screen
	while(len(mCharOnScreen) > 0){
		mScreenNumbersObj.RemoveChild(mCharOnScreen[0]);
		adel(mCharOnScreen, 0);		
	}
			
	//All buttons must NOT be pressed
	while(len(mPressedButtonsObjs) > 0){
		adel(mPressedButtonsObjs, 0);		
	}	
	
	//Insted, they must be Pressed
	while(len(mUnpressedButtonsObjs) > 0){
		adel(mUnpressedButtonsObjs, 0);		
	}
	
	for(var i = 0; i < len(mButtonsObjs); i++){		
		aadd(mUnpressedButtonsObjs, mButtonsObjs[i]);	
	}
}


function Numpad::IsCameraInNumpadRange(cameraPosition, range){
	return (cameraPosition.x > (mNumpadPosition.x - range)) && (cameraPosition.x < (mNumpadPosition.x + range)) &&
		   (cameraPosition.z > (mNumpadPosition.z - range)) && (cameraPosition.z < (mNumpadPosition.z + range));
}