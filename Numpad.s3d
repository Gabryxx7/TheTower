class Numpad{	
	var mButtonsObjs;
	var mPressedButtonsObjs;
	var mUnpressedButtonsObjs;
	var mTextsObjs;
	var mCharacters;
	var mUnpressedButtonColor;
	var mPressedButtonColor;
	var mWrongCodeColor;
	var mTextColor;
	
	Draw(drawButtons, drawPressedButtons, drawText);
	GetButtonsObjs();
	GetUnpressedButtonsObjs();
	GetPressedButtonsObjs();
	GetTextsObjs();
	GetUnpressedButtonColor();
	GetPressedButtonColor();
	GetWrongCodeColor();
	GetTextColor();
	GetButtonObj(buttonChar);
	GetNumpadCharacters();	
	PressButton(buttonChar);
	UnpressButton(buttonChar);
	UnpressAllButtons();
	PressAllButtons();
};


function Numpad::Numpad(buttonsText ,tilesSize, spaceSize, tilesThickness, numpadPosition, unpressedButtonColor, pressedButtonColor, wrongCodeColor, textColor){
	mTextsObjs = {};
	mButtonsObjs = {};
	mPressedButtonsObjs = {};
	mUnpressedButtonsObjs = {};
	mCharacters = {};
	mPressedButtonColor = pressedButtonColor;
	mUnpressedButtonColor = unpressedButtonColor;
	mWrongCodeColor = wrongCodeColor;
	mTextColor = textColor;
	
	var buttonMesh = CVmNewMesh(VRP_BOX, 1, [-tilesSize/2, -tilesSize/2, 0], [tilesSize/2, tilesSize/2, 0], tilesThickness);
	var offsetY = tilesSize + spaceSize;
	var offsetX = tilesSize + spaceSize;
	var offsetZ = tilesThickness;
	
	var txt;
	var txtObj;
	var buttonObj;
	var num = 9;
	var rows = 0;
	var lines = 0;
	for(var i = 0; i < len(buttonsText) ; i++){	
		if(buttonsText[i] == " "){
			i++;
			lines++;
			rows = 0;	
		}			
		var buttonPos = numpadPosition + [(offsetX * (rows++)), -offsetY*(lines), 0] ;
		
		txt = CVmText();		
		txt.Load(buttonsText[i]);
		txt.SetColor(textColor.r, textColor.g, textColor.b);
		
		txtObj = CVmObj();
		txtObj.LinkToText(txt);
		txtObj.SetScale(0.1,0.1,0.1);
		txtObj.SetPosition(buttonPos.x-(0.1*SCALE_FACTOR), buttonPos.y - (1.65*SCALE_FACTOR), buttonPos.z + 0.05*SCALE_FACTOR);
		
		buttonObj = CVmObj(buttonMesh);
		buttonObj.SetPosition(buttonPos.x, buttonPos.y - (1.5*SCALE_FACTOR), buttonPos.z);	
		
		aadd(mCharacters, lower(buttonsText[i]));
		aadd(mTextsObjs, txtObj);
		aadd(mButtonsObjs, buttonObj);
		aadd(mUnpressedButtonsObjs, buttonObj);	
	}	
}


function Numpad::Draw(drawUnpressedButtons, drawPressedButtons, drawText){
	if(valtype(drawUnpressedButtons) == "")
		drawUnpressedButtons = 1;		
	
	if(valtype(drawText) == "")
		drawText = 1;
		
	if(valtype(drawPressedButtons) == "")
		drawPressedButtons = 0;
		
	if(drawUnpressedButtons == 1){
		for(var i = 0; i < len(mUnpressedButtonsObjs); i++)
			mUnpressedButtonsObjs[i].Draw();			
	}
	
	if(drawPressedButtons == 1){
		for(var i = 0; i < len(mPressedButtonsObjs); i++)
			mPressedButtonsObjs[i].Draw();			
	}
	
	if(drawText == 1){
		for(var i = 0; i < len(mTextsObjs); i++)
			mTextsObjs[i].Draw();				
	}
}

function Numpad::GetButtonsObjs(){	
	return mButtonsObjs;
}

function Numpad::GetButtonObj(buttonChar){	
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters == buttonChar)
			return mButtonsObjs[i];
	}
}

function Numpad::GetNumpadCharacters(){
	return mCharacters;
}


function Numpad::GetUnpressedButtonsObjs(){	
	return mUnpressedButtonsObjs;
}

function Numpad::GetPressedButtonsObjs(){	
	return mPressedButtonsObjs;
}

function Numpad::GetTextsObjs(){
	return mTextsObjs;
}

function Numpad::GetUnpressedButtonColor(){
	return mUnpressedButtonColor;
}

function Numpad::GetPressedButtonColor(){
	return mPressedButtonColor;
}

function Numpad::GetWrongCodeColor(){
	return mWrongCodeColor;
}

function Numpad::GetTextColor(){
	return mTextColor;
}

function Numpad::PressButton(buttonChar){
	var charPos = -1;
	//CHeck if char is present in the numpad
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters[i] == buttonChar)
			charPos = i;
	}
	
	if(charPos == -1)
		return false;
	
	//If it's present, I should check if it is already pressed
	var alreadyPressed = false;
	for(var i = 0; i < len(mPressedButtonsObjs); i++){
		if(mPressedButtonsObjs[i] == mButtonsObjs[charPos])
			alreadyPressed = true;
	}
	
	//If it is not already pressed, I add it to the pressed buttons vector
	if(!alreadyPressed)
		aadd(mPressedButtonsObjs, mButtonsObjs[charPos]);
	else 
		return true; //if it was pressed already then there is nothing to do here
		
	//If it was not pressed, I have to remove it from the unpressed buttons
	for(var i = 0; i < len(mUnpressedButtonsObjs); i++){
		if(mUnpressedButtonsObjs[i] == mButtonsObjs[charPos]){
			adel(mUnpressedButtonsObjs, i);	
			return true;				
		}			
	}	
	
	return true;
}

function Numpad::UnpressButton(buttonChar){	
	var charPos = -1;
	//CHeck if char is present in the numpad
	for(var i = 0; i < len(mCharacters); i++){
		if(mCharacters[i] == buttonChar)
			charPos = i;
	}
	
	if(charPos == -1)
		return false;
	
	//If it's present, I should check if it is pressed or unpressed
	var alreadyUnpressed = false;
	for(var i = 0; i < len(mUnpressedButtonsObjs); i++){
		if(mUnpressedButtonsObjs[i] == mButtonsObjs[charPos])
			alreadyUnpressed = true;
	}
	
	//If it is pressed, I add it to the unpressed buttons vector
	if(!alreadyUnpressed)
		aadd(mUnpressedButtonsObjs, mButtonsObjs[charPos]);
	else 
		return true; //if it was pressed already then there is nothing to do here
		
	//If it was pressed, I have to remove it from the pressed buttons
	for(var i = 0; i < len(mPressedButtonsObjs); i++){
		if(mPressedButtonsObjs[i] == mButtonsObjs[charPos]){
			adel(mPressedButtonsObjs, i);	
			return true;				
		}			
	}	
	
	return true;
}

function Numpad::PressAllButtons(){	
	while(len(mPressedButtonsObjs) > 0){
		adel(mPressedButtonsObjs, 0);		
	}	
	
	while(len(mUnpressedButtonsObjs) > 0){
		adel(mUnpressedButtonsObjs, 0);		
	}
	
	for(var i = 0; i < len(mButtonsObjs); i++){		
		aadd(mPressedButtonsObjs, mButtonsObjs[i]);	
	}
}

function Numpad::UnpressAllButtons(){	
	while(len(mPressedButtonsObjs) > 0){
		adel(mPressedButtonsObjs, 0);		
	}	
	
	while(len(mUnpressedButtonsObjs) > 0){
		adel(mUnpressedButtonsObjs, 0);		
	}
	
	for(var i = 0; i < len(mButtonsObjs); i++){		
		aadd(mUnpressedButtonsObjs, mButtonsObjs[i]);	
	}
}