class Level5
{
	var mIsVRon;
	
	// Booleans that indicate if the level is starting or ending
	var mStarting;
	var mEnding;
	var mIsLevelCompleted;
	var mEndTimer;
	var mLevelStatus;
	
	// When the player steps into the elevator, this constant hold the time (in milliseconds) until the next level is rendered
	var mTimeToEnd;
	
	// Manager for user inputs
	var mInputManager;
	
	// "Animator" object; used to create transitions and rotations for the objects
	var mAnimator;
	
	// "SoundManager" object; used to play the music and sounds. May need to move this to the "GameManager" class in the future, since it's more like a global thing
	var mSoundManager;
	
	// Active camera
	var mCamera;
	
	// Lights used to render the scene. mLight0 is used to render the portals' rooms, while mLight1 is used to render the "normal" scene
	var mLight0;
	var mLight1;	
	var mLight2;
	
	var mLight0Position;
	var mLight1Position;
	var mLight2Position;
	
	// "Room" object that contains the whole room
	var mMainRoom;
	
	// Arrays that contain the reference to the portal rooms, the portal frames (i.e. the rectangle's where we can see the portals' rooms) 
	// and the normals of the frames
	var mPortalFrames;
	var mPortalFramesNormals;
	var mPortalFramesGlassWalls;	
	// This array contains the reference to the currently visible portal's frames
	var mCurrentlyVisiblePortalFrames;
		
	// World coordinates for the bounding box that contains the "square" of portals' frames
	var mPortalsBoxLowerCorner;
	var mPortalsBoxUpperCorner;
	
	// Booleans that indicate whether the elevator has appeared and if it's already open or not
	var mIsElevatorPresent;
	var mIsElevatorOpen;
	
	// "Room" object that represent the elevator
	var mElevator;	
	
	var mElevatorFinalPosition;
	var mElevatorTravelDistance;
	var mElevatorTravelTime;
	var mCameraYoffset;	
	var mOpenglTranslationOffset;	
	var mPreviousOpenglTranslationOffset;
	
	// Vive controllers
	var mController1;
	var mController2;
	
	var mTranslateFactor;

	var mProvaObj;
	var mMaskObj;
	// Private functions
	DrawAllPortals();
	DrawPortal(portalFrame1, portalFrameNormal1, portalFrame2, portalFrameNormal2);
	
	// Public functions
	Init(lights, elevator, openglTransformOffset);
	Render();
	UpdateLogic(dt);
	IsLevelCompleted();
	GetElevator();
	IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall);
	GetOpenglTransformOffset();
	SetOpenglTransformOffset(mOpenglTranslationOffset);
	SetupOpenglLights();
	GetLevelPreview();
};


/*
 * Constructor. Takes as parameter the input manager of the application
 */
function Level5::Level5(isVRon, inputManager, soundManager)
{
	mIsVRon = isVRon;
	
	mInputManager = inputManager;
	mSoundManager = soundManager;
	
	mTranslateFactor = [0.0, 0.0, -20.0 * SCALE_FACTOR];
//	mTranslateFactor = [0.0, 0.0, 0.0];
		
	// Creating the object that will handle transitions and rotations of objects
	mAnimator = Animator();
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH, ROOM_SIDE_WALL_WIDTH, ROOM_HEIGHT, true, 1, 2, true, true, false);
	
	mMainRoom.Translate(mTranslateFactor.x,  mTranslateFactor.y, mTranslateFactor.z);
		
	// At start, the elevator is not present, nor its doors are open
	mIsElevatorPresent = false;
	mIsElevatorOpen = false;
	
	// Creating the main room
	mMainRoom = Room(ROOM_FAR_WALL_WIDTH, ROOM_SIDE_WALL_WIDTH, ROOM_HEIGHT, true, 1, 2);
	
	mMainRoom.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);
	// Sizes of the portal frames, i.e. the rectangles from where the portal rooms can be seen
	var halfWidth = PORTAL_ROOM_FAR_WALL_WIDTH/2.0;
	var halfHeight = PORTAL_ROOM_HEIGHT/2.0;
	
	// Creating the mesh for the frames; it's the same for every portal room, since they all have the same size
	var portalFrameMesh = CVmNewMesh(VRP_PLANE, 1, [-halfWidth, -halfHeight, 0], [halfWidth, halfHeight, 0], 2, 2);
	
	// Linking the frame objects to the mesh
	var portalFrameObj1 = CVmObj(portalFrameMesh);
	var portalFrameObj2 = CVmObj(portalFrameMesh);
	var portalFrameObj3 = CVmObj(portalFrameMesh);
	var portalFrameObj4 = CVmObj(portalFrameMesh);
	
	// Moving the frames so that they form a sort of cube
	portalFrameObj1.Translate(0, halfHeight, 0);	
	portalFrameObj2.Translate(halfWidth, halfHeight, -halfWidth);
	portalFrameObj3.Translate(0, halfHeight, -halfWidth * 2.0);
	portalFrameObj4.Translate(-halfWidth, halfHeight, -halfWidth);
		
	// Translate the frames again to move away from the origin
	portalFrameObj1.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);
	var maskMesh = CVmNewMesh("GuyFawkesMask.aam");
	maskMesh.Scale(SCALE_FACTOR - 0.8 * SCALE_FACTOR, SCALE_FACTOR - 0.8 * SCALE_FACTOR, SCALE_FACTOR - 0.8 * SCALE_FACTOR);
	mMaskObj = CVmObj(maskMesh);
	mMaskObj.SetRotation(180, 0,1,0);
	mMaskObj.SetPosition(portalFrameObj1.GetPosition()+[0,0,3*SCALE_FACTOR]);
	
	portalFrameObj2.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);	
	var provaMesh = CVmNewMesh("provaMesh.AAM");
	provaMesh.Scale(SCALE_FACTOR - 0.8 * SCALE_FACTOR, SCALE_FACTOR - 0.8 * SCALE_FACTOR, SCALE_FACTOR - 0.8 * SCALE_FACTOR);
	mProvaObj = CVmObj(provaMesh);
	mProvaObj.SetPosition(portalFrameObj2.GetPosition());
	portalFrameObj3.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);
	portalFrameObj4.Translate(mTranslateFactor.x, mTranslateFactor.y, mTranslateFactor.z);
	
	// Rotating the frames, so that each one reflects its portal's room orientation
	portalFrameObj2.Rotate(90, 0, 1, 0);
	portalFrameObj3.Rotate(180, 0, 1, 0);
	portalFrameObj4.Rotate(-90, 0, 1, 0);
	
	// Normals for each frame; used to check which frames are visible from the player position in a given moment
	var frameNormal1 = [0, 0, 1];
	var frameNormal2 = [1, 0, 0];
	var frameNormal3 = [0, 0, -1];
	var frameNormal4 = [-1, 0, 0];
	
	// I compute the world coordinates of the bounding box of the frames by exploiting the positions of the first and third (which are opposite)
	var frame1Pos = portalFrameObj1.GetPosition();
	var frame3Pos = portalFrameObj3.GetPosition();
	mPortalsBoxLowerCorner = portalFrameObj1.GetPosition() - [halfWidth, halfHeight, 0];
	mPortalsBoxUpperCorner = portalFrameObj3.GetPosition() + [halfWidth, halfHeight, 0];
	
	var glassWall1 = CreateGlassWall(PORTAL_ROOM_FAR_WALL_WIDTH, PORTAL_ROOM_HEIGHT, 0.5 * SCALE_FACTOR, mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y);
	var glassWall2 = CreateGlassWall(PORTAL_ROOM_FAR_WALL_WIDTH, PORTAL_ROOM_HEIGHT, 0.5 * SCALE_FACTOR, mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y);
	var glassWall3 = CreateGlassWall(PORTAL_ROOM_FAR_WALL_WIDTH, PORTAL_ROOM_HEIGHT, 0.5 * SCALE_FACTOR, mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y);
	var glassWall4 = CreateGlassWall(PORTAL_ROOM_FAR_WALL_WIDTH, PORTAL_ROOM_HEIGHT, 0.5 * SCALE_FACTOR, mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y);
	
	glassWall1.Rotate(180, 0, 1, 0);
	glassWall2.Rotate(-90, 0, 1, 0);
	glassWall3.Rotate(0, 0, 1, 0);
	glassWall4.Rotate(90, 0, 1, 0);
	
	glassWall1.SetPosition(portalFrameObj1.GetPosition() + [0, 0, 0.003 * SCALE_FACTOR]);
	glassWall2.SetPosition(portalFrameObj2.GetPosition() + [0.003 * SCALE_FACTOR, 0, 0]);
	glassWall3.SetPosition(portalFrameObj3.GetPosition() + [0, 0, -0.003 * SCALE_FACTOR]);
	glassWall4.SetPosition(portalFrameObj4.GetPosition() + [-0.003 * SCALE_FACTOR, 0, 0]);
	
	mPortalFrames = {};
	mPortalFramesNormals = {};
	mPortalFramesGlassWalls = {};
	
	aadd(mPortalFrames, portalFrameObj1);
	aadd(mPortalFrames, portalFrameObj2);
	
	aadd(mPortalFramesNormals, frameNormal1);
	aadd(mPortalFramesNormals, frameNormal2);
	aadd(mPortalFramesNormals, frameNormal3);
	aadd(mPortalFramesNormals, frameNormal4);
	
	aadd(mPortalFramesGlassWalls, glassWall1);
	aadd(mPortalFramesGlassWalls, glassWall2);
	aadd(mPortalFramesGlassWalls, glassWall3);
	aadd(mPortalFramesGlassWalls, glassWall4);
		
	// Now I create the elevator, as a "Elevator" object; the width and depth are a little less than the size of the frames, otherwise we get z-buffer problems
	var elevatorWidth = PORTAL_ROOM_FAR_WALL_WIDTH - 0.01 * SCALE_FACTOR;
	var elevatorDepth = PORTAL_ROOM_SIDE_WALL_WIDTH - 0.16 * SCALE_FACTOR;
	var elevatorHeight = PORTAL_ROOM_HEIGHT;
	
	mElevator = Elevator(elevatorWidth, elevatorDepth, elevatorHeight, mMainRoom.GetLightsRange().x, mMainRoom.GetLightsRange().y);
		
	// Positioning the room so that is right behind the first portal frame
	mElevator.SetPosition(portalFrameObj1.GetPosition() - [0, 0, elevatorDepth - 0.04 * SCALE_FACTOR]);
				
	// At start I hide the elevator; it will appear later
	mElevator.Hide();
	
	// Text for the elevator
	var elevatorText = Text("The Tower");
	mElevator.AddObject(elevatorText.GetObj(), -0.2 * SCALE_FACTOR, 0, 0.001);
	
	// Creating the object that will handle transitions and rotations of objects
	// Sounds when the player steps in the right direction
	mSoundManager.AddSound("sounds/Mi1.wav", 0);
	mSoundManager.AddSound("sounds/Fa#2.wav", 1);
	mSoundManager.AddSound("sounds/Sol3.wav", 2);
	mSoundManager.AddSound("sounds/La4.wav", 3);
	mSoundManager.AddSound("sounds/Si5.wav", 4);
	mSoundManager.AddSound("sounds/Do#6.wav", 5);
	mSoundManager.AddSound("sounds/Mi7.wav", 6);

	// If the Vive is on, I get the reference to the controllers
	if(mIsVRon)
	{
		mController1 = mInputManager.GetController(1);
		mController2 = mInputManager.GetController(2);
	}
}

function Level5::Init(lights, elevator, openglTransformOffset){
	
	mOpenglTranslationOffset = openglTransformOffset;
	
	foreach(var light in lights)
		light.Disable();
	
	mLight0 = lights[0];
	mLight0.SetDiffuse(1, 1, 1);
	mLight0.Enable();
	
	mLight1 = lights[1];
	mLight1.SetDiffuse(1, 1, 1);
	mLight1.Enable();
	
	mLight2 = lights[2];
	mLight2.SetDiffuse(1, 1, 1);
	mLight2.Enable();
	
		
	mElevator = elevator;
	
	mCamera = mInputManager.GetActiveCamera();

	mEnding = false;
	mIsLevelCompleted = false;
	mTimeToEnd = 2500;
	
	mElevatorTravelDistance = 100.0 * SCALE_FACTOR;
	mElevatorTravelTime = !DEBUG_MODE ? 15.0 : 1.5;

	mElevatorFinalPosition = mElevator.GetPosition();
	
	mLight1.SetPosition(mLight1.GetPosition() - [0, mElevatorTravelDistance, 0]);
	mLight2.SetPosition(mLight2.GetPosition() - [0, mElevatorTravelDistance, 0]);
	
	mLight0Position = mLight0.GetPosition();
	mLight1Position = mLight1.GetPosition();
	mLight2Position = mLight2.GetPosition();
		
	mAnimator.CreateTransition(mElevator, mElevatorFinalPosition + [0, -mElevatorTravelDistance, 0], mElevatorFinalPosition, mElevatorTravelTime, false);
	
	mCameraYoffset = mElevatorTravelDistance / mElevatorTravelTime;
	mPreviousOpenglTranslationOffset = mOpenglTranslationOffset; 
	mOpenglTranslationOffset.y += mElevatorTravelDistance;
	
	mLevelStatus = STATUS_ELEVATOR_MOVING;
}

/* ****************************************************** *
 * **************** RENDER METHODS ********************** *
 * ****************************************************** */


/*
 * Render method
 */
function Level5::Render()
{			
	// To avoid problems with the lights when using teleportation and the Vive, I reset the light's position to their current place at each frame		
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
 	
	
	// The first thing we need to do is draw the portals. Since they are peculiar, it is best to draw them first, otherwise there might be glitches
	DrawAllPortals();
	
	// We draw the main room
	if(!mEnding || mElevator.IsElevatorOpen())
		mMainRoom.Draw();
		
	// Drawing the glass walls for the frames
	foreach(var glassWall in mPortalFramesGlassWalls)
		glassWall.Draw();
	
	// And the elevator, which is hidden at the start (so the draw won't do a thing at first)
	mElevator.Draw();
	
	mProvaObj.Draw();
	mMaskObj.Draw();
	
	if(mIsVRon)
	{
		mController1.Draw();
		mController2.Draw();
	}
}

/*
 * This method draws every portal in the scene. This function MUST be called after the opening of a SceneBegin()/SceneEnd() block, 
 * otherwise it won't give out any results
 */
function Level5::DrawAllPortals()
{	
	// We need to find out which portals are visible from the player's perspective, so we need its position.
	// Note: to get the ACTUAL position I need to subtract the opengl offset, in case the user has teleported previously
	var currentCameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
	// To render the portal we need the stencil buffer
	glEnable(GL_STENCIL_TEST);
	
	// I empty at each frame the array with the currently visible frames, so that I can re-fill it
	mCurrentlyVisiblePortalFrames = {};
		
	// I iterate over all the portals to check which one is visible by the user
	for(var i = 0; i < len(mPortalFrames); i++) 
	{
		// I get the normal to the portal's frame, which was set manually; I also get the position of the frame
		var normal = mPortalFramesNormals[i];
		var framePos = mPortalFrames[i].GetPosition();
		
		// I compute the scalar product between the normal and the direction vector between the camera's position and the frame's position.
		var dotProduct = normal * ((currentCameraPosition) - framePos);
		
		// If the dot product is positive, the portal is visible.
		// Note: in reality, if for example I move the camera around so that it gives its back to the portal, this one is still considered visible. For simplicity, 
		// I don't check the direction where the camera is facing; in any case even though it is considered visible, in the end the portal won't be rendered
		// because  XVR will know that the portal isn't actually visible from the camera perspective
		if(dotProduct >= 0)
		{
			// I render the portal, passing also the information about the light's color and position
			if(i == 0)
				DrawPortal(mPortalFrames[0], mPortalFramesNormals[0], mPortalFrames[1], mPortalFramesNormals[1]);
			else
				DrawPortal(mPortalFrames[1], mPortalFramesNormals[1], mPortalFrames[0], mPortalFramesNormals[0]);
			
			// Since it's visible, I add this to the array
			aadd(mCurrentlyVisiblePortalFrames, mPortalFrames[i]);

			// While drawing the portal, the camera was moved in order to render the portal's room. So I put it back where it was before proceding
			// Note: I need to add the opengl offset otherwise the position would not be correct
			mCamera.SetPosition(currentCameraPosition + mOpenglTranslationOffset);
		}
	}
	
	
	// A very important thing to note is that when the portals are drawn, the camera is moved to where the portals' rooms are located. Basically what happened
	// was that the light was somehow moved to the position of the camera when it was moved, and it stayed there. So basically the rest of the scene was rendered
	// as if the light was far away to the last portal's room rendered. To avoid this problem (which took a while to solve), we need to take back the light
	// used to render the main room where it was. We can't do it using XVR method SetPosition() because it won't have effect until the next frame (and it will
	// be too late, since the process will restart), so we need to force it to apply NOW using opengl functions and directly accessing at the light.
	// So I pass the old position; the 1.0 in the end signify that it is a position light (if it were 0.0 it would be considered a directional light)
	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]);


	// After drawing the portals, the stencil test is no longer needed
	glDisable(GL_STENCIL_TEST);
	
	// Now the portals are drawn, but NOT in the depth buffer. This means that when we'll draw the rest of the scene, the computed depth will be wrong.
	// To solve this, I re-draw the portal's frame, but without actually applying colors, and I do it while the depth buffer is active and clear, so that
	// the frames will be put in there and will be taken into account when drawing the rest of the scene.
	// So, first off, I dsable the color buffer
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	
	// I enable writing to the depth buffer, enable the depth test and clear the buffer
	glDepthMask(GL_TRUE);
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
	
	// Now I draw each portal, even the ones that weren't actually visible, because they still need to "occupy space"
	for(var i = 0; i < len(mPortalFrames); i++)
		mPortalFrames[i].Draw();

	// I enable the color buffer again for the rest of the scene
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
}

 /*
  * Method for drawing a single portal room in a single portal frame.
  * Note: this method modifyes the currently active SceneBegin/SceneEnd block, meaning that it closes the currently active block and opens a new one without
  * closing it. So, this function MUST be called after the opening of a SceneBegin() block, and it assures that at the end of the method a block will
  * be still open for further use (so that outside this function we still have to call SceneEnd())
  * 
  * portalFrame: (CVmObj) the frame from which the portal's room will be visible
  * portalRoom: (Room) the room that needs to be rendered and that is seen from the portal
  */
function Level5::DrawPortal(portalFrame1, portalFrameNormal1, portalFrame2, portalFrameNormal2)
{
	glPushMatrix();
	
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	glDepthMask(GL_FALSE);
	glDisable(GL_DEPTH_TEST);
	
	glStencilFunc(GL_NEVER, 1, 0xFF);	
	glStencilOp(GL_REPLACE, GL_KEEP, GL_KEEP);
	glStencilMask(0xFF);
	
	glClear(GL_STENCIL_BUFFER_BIT);
	portalFrame1.Draw();	
	
	var framePos = portalFrame2.GetPosition();	
	var translation = [framePos.x, 0, framePos.z];		
		
	// Now I move the world where the camera should be rendering the portal room (it's "minus" translation, because the glTranslate pushes the world away)
	glRotate(180, 0, 1, 0);
	glTranslate(-mOpenglTranslationOffset);
	glTranslate(-translation);
//	if(portalFrameNormal1 == [0,0,1])
		
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
	// Setting the light to its defined position
//	glLight(GL_LIGHT0, GL_POSITION, [lightPosition.x, lightPosition.y, lightPosition.z, 1.0]); 
	
	// Changing the light's color
//	glLight(GL_LIGHT0, GL_DIFFUSE, lightColor); 
					
	// Since the portal's room as to be rendered "normally", I enable the usual things (color and depth buffer, which is emptied)
	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	glDepthMask(GL_TRUE);
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
	
	// I disable writing to the stencil buffer, and I make sure that a pixel passes the stencil test ONLY if its value in the buffer is 1. That is,
	// only the pixels belonging to the previously rendered portal's frame will pass the test, so the portal's room will be rendered there and olny there
	glStencilMask(0x00);
	glStencilFunc(GL_EQUAL, 1, 0xFF);
	
	// Drawing the actual portal's room where the stencil is 1
	mMainRoom.Draw(true);
	mProvaObj.Draw(true);
	
	glCullFace(GL_BACK);
	mMaskObj.Draw(true);
	
	// I'm done with this portal, so I pop the matrix from the stack. This way the glTranslsate() that I did above will be undone, bringing the world
	// back the way it was before rendering the portal room, which is what I want
	glPopMatrix();
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]);
}




/* ****************************************************** *
 * **************** LOGIC METHODS ********************** *
 * ****************************************************** */
 
 
/*
 * Updates the logic of the game
 * 
 * dt: (float) delta time, i.e. the time between the last update and this one
 */
function Level5::UpdateLogic(dt)
{
	
	// First off, let's update the player's position and orientation and the controllers (if they're not present nothing will be done)
	mInputManager.UpdateCamera();
	mInputManager.UpdateControllers(mOpenglTranslationOffset);
	
	// Getting the camera position, minus the opengl offset used for teleporting
	var cameraPosition = mCamera.GetPosition() - mOpenglTranslationOffset;
	
//	// Checking if the new position of the camera is allowed (i.e. if it's in the room and if it isn't inside any object); if not, 
//	// I restore the previous porision. Very badly written code
//	if(!mIsVRon && !mMainRoom.IsPointInRoom(cameraPosition))
//		mInputManager.RestoreCameraPosition();
//	else if(!mIsVRon && (cameraPosition.x >= mPortalsBoxLowerCorner.x - 0.8 * SCALE_FACTOR && cameraPosition.x <= mPortalsBoxUpperCorner.x + 0.8 * SCALE_FACTOR) &&
//       	   (cameraPosition.z <= mPortalsBoxLowerCorner.z + 0.8 * SCALE_FACTOR && cameraPosition.z >= mPortalsBoxUpperCorner.z - 0.8 * SCALE_FACTOR) &&
//       	    !mIsElevatorPresent)
//   	    mInputManager.RestoreCameraPosition();
//
//    // If the level is ending (i.e. the player is inside the elevator) I make sure that the camera doesn't go out
//    if(!mIsVRon && mEnding && !mElevator.IsPointInElevator(cameraPosition))
//    	mInputManager.RestoreCameraPosition();
    	
    switch(mLevelStatus)
	{
		case STATUS_ELEVATOR_MOVING: 
		{			
		    if(!mIsVRon && !mElevator.IsPointInElevator(cameraPosition))
		    	mInputManager.RestoreCameraPosition();
			
			var elevatorPos = mElevator.GetPosition();

			if(abs(elevatorPos.y) < (mElevatorFinalPosition.y + mElevatorTravelDistance)/2.0)
			{
				mLight0Position = [-10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + mTranslateFactor;
				mLight1Position = [0, 10.0 * SCALE_FACTOR, 10.0 * SCALE_FACTOR] + mTranslateFactor;
				mLight2Position = [0, 10.0 * SCALE_FACTOR, -20.0 * SCALE_FACTOR] + mTranslateFactor;
				
				mLight0.SetPosition(mLight0Position);
				mLight1.SetPosition(mLight1Position);
				mLight2.SetPosition(mLight2Position);
			}
			
			mOpenglTranslationOffset.y -= mCameraYoffset * dt;
			
		    mOpenglTranslationOffset.x += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
		    mOpenglTranslationOffset.y += Rand(1) == 0 ? Rand(2)/500.0 : -Rand(2)/500.0;
			
			if(elevatorPos.y >= mElevatorFinalPosition.y)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mLevelStatus = STATUS_ELEVATOR_ARRIVED;
				
				mOpenglTranslationOffset = mPreviousOpenglTranslationOffset;
			}
	
			break;
		}	
		
		case STATUS_ELEVATOR_ARRIVED:
		{
			if(!mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();

				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
								
				mLevelStatus = STATUS_LEVEL_STARTED;
			}
			
			break;
		}	
		
		case STATUS_LEVEL_STARTED:
		{
			var checkRange = 2*SCALE_FACTOR;
			if(   cameraPosition.x >= mPortalFrames[0].GetPosition().x - checkRange && cameraPosition.x <= mPortalFrames[0].GetPosition().x + checkRange
			   && cameraPosition.z >= mPortalFrames[0].GetPosition().z - checkRange && cameraPosition.z <= mPortalFrames[0].GetPosition().z + checkRange){
				outputln("\nTRESPASSING PORTAL 1");
				mCamera.SetPosition(mPortalFrames[1].GetPosition().x+checkRange*2, cameraPosition.y, mPortalFrames[1].GetPosition().z+checkRange*2);
			}
			else if(   cameraPosition.x >= mPortalFrames[1].GetPosition().x - checkRange && cameraPosition.x <= mPortalFrames[1].GetPosition().x + checkRange
			   && cameraPosition.z >= mPortalFrames[1].GetPosition().z - checkRange && cameraPosition.z <= mPortalFrames[1].GetPosition().z + checkRange){
				outputln("\nTRESPASSING PORTAL 2");
				mCamera.SetPosition(mPortalFrames[0].GetPosition().x +checkRange*2, cameraPosition.y, mPortalFrames[0].GetPosition().z+checkRange*2);			   	
			 }
			// At start I hide the elevator; it will appear later
			mElevator.Hide();
			// For each portal, I need to update the position of its light
			break;
		}
		
		case STATUS_LEVEL_ENDING:
		{
			// If the elevator isn't open and the player steps in front of it, I create transitions to make the doors open, play a sound and save the fact that now it's open
			if(!mIsElevatorOpen)
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorOpenPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorOpenPosition(), 2.0, false);
				
				mIsElevatorOpen = true;
				mSoundManager.PlaySound(6, true, 1);
			}
			// Otherwise, if it's already open and the player steps inside, I close the door and prepare for the ending of the level
			else if(mIsElevatorOpen && mElevator.IsPointInElevator(cameraPosition))
			{
				var leftDoorPos = mElevator.GetLeftDoor().GetPosition();
				var rightDoorPos = mElevator.GetRightDoor().GetPosition();
				
				mAnimator.CreateTransition(mElevator.GetLeftDoor(), leftDoorPos, mElevator.GetLeftDoorClosedPosition(), 2.0, false);
				mAnimator.CreateTransition(mElevator.GetRightDoor(), rightDoorPos, mElevator.GetRightDoorClosedPosition(), 2.0, false);
				
				mIsElevatorOpen = false;
				
				// I signal that the game is about to end and get the time; I need that the transitions of the doors end before actually ending the level,
				// so I need to save the time the animations started
				mEnding = true;
				mEndTimer = GetTime();
			}
			
			// If the game is ending and it's been a while (so the doors of the elevator are closed now), I save the fact that the level has been completed
			if(mEnding && GetTime() - mEndTimer > mTimeToEnd)
				mIsLevelCompleted = true;
			
			break;
		}
	}
	
	// I update the methods of the managers
	mAnimator.UpdateTransitions(dt);
	mSoundManager.UpdateMusic(dt);
}

/*
 * This method checks where the given ray intersects the world, and returns true if that position is valid for the player
 * 
 * rayOrigin: (vector) starting point of the ray
 * rayEnd: (vector) starting point of the ray
 * contactPoint: (vector) if the ray intersects something, this parameter will be filled up with the information (needs to be passed as reference, with &)
 * normal: (vector) if the ray intersects something, this parameter will be filled up with the normal to the intersected plane (needs to be passed as reference, with &)
 * isWall: (boolean) if the ray intersects something, this parameter will be true if the interception was in a wall (needs to be passed as reference, with &)
 */
function Level5::IsPointedPositionValid(rayOrigin, rayEnd, contactPoint, normal, isWall)
{
	// I'm stating that there is no intersection
	var intersectedPlane = -1;

	// I scan each of the currently visible portal's frames, to find any interception
	foreach(var portalFrame in mCurrentlyVisiblePortalFrames)
	{
		// Check collision
		var flag = portalFrame.IsColliding(rayOrigin, rayEnd, &contactPoint, &normal);
		
		if(flag)
		{
			isWall = true;
			return false;
		}
	}
		
	// If there was no collision with the frames, I check the elevator if it's present. The method will return -1 if no interception was found,
	// 0 if a good intercetpion was found (i.e. the floor, with the elevator open), or a value > 1 indicating which part of the elevator was found (which
	// one is not relevant in this case)
	if(mIsElevatorPresent)
		intersectedPlane = mElevator.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);

	// If still no interception was found, I check the boundaries of the room
	if(intersectedPlane == -1)
		intersectedPlane = mMainRoom.CheckIntersection(rayOrigin, rayEnd, &contactPoint, &normal);
		
	// If I'm here, I definitely found a wall
	isWall = true;
	
	// If the intersection value is 0, a good point was found
	return intersectedPlane == 0;
}

/*
 * Method called by the GameManager to check if the level is completed
 */
function Level5::IsLevelCompleted()
{
	return mIsLevelCompleted;
}

function Level5::GetOpenglTransformOffset()
{
	return mOpenglTranslationOffset; 
}

function Level5::SetOpenglTransformOffset(openglTransformOffset)
{
	mOpenglTranslationOffset = openglTransformOffset; 
}

/*
 * Method called by the GameManager to check if the level is completed
 */
function Level5::GetElevator()
{
	return mElevator;
}


function Level5::SetupOpenglLights()
{
	glEnable(GL_LIGHT0);
	glEnable(GL_LIGHT1);
	glEnable(GL_LIGHT2);
	
	// Note: might need to SUBTRACT mOpenglTranslationOffset to each axis position
	glLight(GL_LIGHT0, GL_POSITION, [mLight0Position.x, mLight0Position.y, mLight0Position.z, 1.0]); 
 	glLight(GL_LIGHT1, GL_POSITION, [mLight1Position.x, mLight1Position.y, mLight1Position.z, 1.0]); 
 	glLight(GL_LIGHT2, GL_POSITION, [mLight2Position.x, mLight2Position.y, mLight2Position.z, 1.0]); 
 	
	glLight(GL_LIGHT0, GL_DIFFUSE, [1, 1, 1]); 
	glLight(GL_LIGHT1, GL_DIFFUSE, [0, 0, 1]); 
	glLight(GL_LIGHT2, GL_DIFFUSE, [1, 0, 0]);
}


function Level5::GetLevelPreview(){
	return "Level5Prev.png";
}