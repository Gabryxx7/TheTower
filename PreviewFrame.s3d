class PreviewFrame{
	var mGlassWallObj;
	var glassMesh;
	var verticalBorderMesh;
	var horizzontalBorderMesh;
	
	var mColor;
	var mSelectedColor;
	
	GetObj();
	ChangeImage(imgName);
	Draw();
	SetPosition(x,y,z);
	IsBeingPointedBy(mObject, objectPosition, distance);
};

function PreviewFrame::PreviewFrame(wallWidth, wallHeight, borderThickness, lightsRangeMin, lightsRangeMax, color, selectedColor, glassAlpha){
	var halfWidth = wallWidth / 2.0;
	var halfHeight = wallHeight / 2.0;
	var halfThickness = borderThickness / 2.0;
	
	mColor = color;
	mSelectedColor = selectedColor;
	
	if(glassAlpha == Void)
		glassAlpha = 0.5;
	
	// The glass mesh is smaller than the wall, because it takes into account the borders
	glassMesh = CVmNewMesh(VRP_PLANE, 1, [-halfWidth + borderThickness, -halfHeight + borderThickness, 0], [halfWidth - borderThickness, halfHeight - borderThickness, 0], 2, 2);	
	
	glassMesh.ShaderAdd("phongLightingWithTextureShader.glsl", 0);
	glassMesh.ShaderActivate(true);	
	glassMesh.ShaderSetParameter(0, "ambient", 0, [1.0, 1.0, 1.0]);
	glassMesh.ShaderSetParameter(0, "diffuse", 0, [0.5, 0.5, 0.5]);
	glassMesh.ShaderSetParameter(0, "specular", 0, [0.4, 0.4, 0.4]);
	glassMesh.ShaderSetParameter(0, "shininess", 0, 50);
	glassMesh.ShaderSetParameter(0, "lightsRangeMin", 0, 0);
	glassMesh.ShaderSetParameter(0, "lightsRangeMax", 0, 2);
	glassMesh.ShaderSetParameter(0, "SCALE_FACTOR", 0, SCALE_FACTOR);
	glassMesh.ShaderSetParameter(0, "alpha", 0, 1.0);
	glassMesh.ShaderSetParameter(0, "tex", 0, 1, "thetower.png");	 	
	
	mGlassWallObj = CVmObj(glassMesh);
	
	// Meshes for the borders
	verticalBorderMesh = CVmNewMesh(VRP_PLANE, 1, [-halfThickness, -halfHeight, 0], [halfThickness, halfHeight, 0], 2, 2);
	horizzontalBorderMesh = CVmNewMesh(VRP_PLANE, 1, [-halfWidth + halfThickness, -halfThickness, 0], [halfWidth - halfThickness, halfThickness, 0], 2, 2);
	
	var leftBorderObj = CVmObj(verticalBorderMesh);
	var rightBorderObj = CVmObj(verticalBorderMesh);
	var topBorderObj = CVmObj(horizzontalBorderMesh);
	var bottomBorderObj = CVmObj(horizzontalBorderMesh);
		
	AddToonShaderToMesh(verticalBorderMesh, [1.0, 1.0, 1.0], mColor, [0.0, 0.0, 0.0], 50, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 1.0);
	AddToonShaderToMesh(horizzontalBorderMesh, [1.0, 1.0, 1.0], mColor, [0.0, 0.0, 0.0], 50, lightsRangeMin, lightsRangeMax, SCALE_FACTOR, 1.0);
	
	// Adding the borders to the wall
	mGlassWallObj.AddChild(leftBorderObj, halfWidth - halfThickness, 0, 0);
	mGlassWallObj.AddChild(rightBorderObj, -halfWidth + halfThickness, 0, 0);
	mGlassWallObj.AddChild(topBorderObj, 0, halfHeight - halfThickness, 0);
	mGlassWallObj.AddChild(bottomBorderObj, 0, -halfHeight + halfThickness, 0);
	AddSilhouetteLinesToPlanarObject(mGlassWallObj, 0.04 * SCALE_FACTOR, wallWidth, wallHeight, 0);
}


function PreviewFrame::GetObj(){
	return mGlassWallObj;
}

function PreviewFrame::Draw(){
	mGlassWallObj.Draw();
}

function PreviewFrame::SetPosition(x,y,z){
	mGlassWallObj.SetPosition(x,y,z);
}

function PreviewFrame::ChangeImage(imgName){	
	glassMesh.ShaderSetParameter(0, "tex", 0, 1, imgName);	 
}

function PreviewFrame::IsBeingPointedBy(mObject, objectPosition, distance){
	var raycastOrigin = objectPosition;
	var raycastEnd = raycastOrigin + mObject.GetDirection() * distance;
	var contactPoint = IsObjectSelected(raycastOrigin, raycastEnd, mGlassWallObj);
	
	if(contactPoint != Void){
	glassMesh.ShaderSetParameter(0, "diffuse", 0, [1, 1, 1]);
		verticalBorderMesh.ShaderSetParameter(0, "diffuse", 0, mSelectedColor);
		horizzontalBorderMesh.ShaderSetParameter(0, "diffuse", 0, mSelectedColor);
		return true;		
	}
	
	glassMesh.ShaderSetParameter(0, "diffuse", 0, [0.5, 0.5, 0.5]);
	verticalBorderMesh.ShaderSetParameter(0, "diffuse", 0, mColor);
	horizzontalBorderMesh.ShaderSetParameter(0, "diffuse", 0, mColor);
		
	return false;	
}