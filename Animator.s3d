
/*
 * This class handles simple transitions and rotations of CVmObj objects.
 * To use the class, the user must create a Animator object; then by calling its method he can create transitions and rotations of any CVmObject. The
 * animation will start as soon it is created.
 * The user must call "UpdateTransitions(dt)" in the logic method so that the class can update the objects positions.
 * 
 * NOTE: every transition works in the LOCAL coordinate system of the object, meaning that the starting point and ending point (or waypoints) of the transition
 * must be given in the local coordinate system of the object. If, for example, you have to move an object toward another that is in another coordinate system,
 * you first need to obtain the coordinate of this second object in the coordinate system of the first object.
 * 
 * Another way to do it would be to not use the SetPosition() of objects, but the Translate method; in that case, the user has to pass as parameters of
 * endpoints not coordinates, but translation vectors. For instance, in the example above, the user would convert both objects positions in world coordinates
 * using LocalToWorld() method, and then take the difference of the 2 positions. The result will be the translate vector to pass as endpoint
 */
class Animator
{
	// List of objects that currently have an active transition/rotation
	var mObjects;                  
	
	// List of starting positions for every transition. For rotations, it contains the starting angle   
	var mStartingPositions;           
	
	// For every object added to the class, this array contains a boolean that states whether the object's transition/rotation is looping or not
	var mIsLoopArray;
	
	// For every transition/rotation active, this array the time specified by the user for the animation
	var mTimeArray;
	
	var mScaleFactorArray;
	
	// List of distances for every transition. It contains the distance that the object must travel. For rotations, it is empty
	var mDistanceArray;
	
	// List of directions for every transition. It contains direction the object must move to. For rotations, it is empty
	var mDirectionsArray;
	
	// These arrays contain the speed of the increments for each axis that have to be used for transitions.
	// For rotations, only the mXSpeedArray is used; it would have been better to create a new array, but since the concept for rotations is similar
	// to the one for transitions, I prefered using this same array to avoid increasing the code and the memory usage
	var mXSpeedArray;
	var mYSpeedArray;
	var mZSpeedArray;
	
	// These arrays indicate whether the given object has waypoints (so its transition is a "path"), and in that case which are the waypoints 
	// and the counter that states what is the next waypoint to visit. These arrays are only used for transitions, and for rotation objects
	// their corresponding values are empty
	var mHasWaypointsArray;
	var mWaypointsArray;
	var mWaypointsCounterArray;
	
	// These arrays are used in case of rotation objects. For each element they indicate what is the final angle they have to reach,
	// what is the delta angle (i.e. the difference between the starting angle and the current angle they're at), the axis around which they have to rotate to
	// (it's actually a vector [x, y, z]), and whether they have to reverse the rotation when they reach the limit (this is checked only if the rotation is set 
	// to be a loop). These arrays are meaningful only for rotations, so for common transitions they're empty
	var mFinalAngleArray;
	var mAngleDeltaArray;
	var mAxisArray;
	var mReverseArray;
	
	// For each object it contains the type of transition (0 == normal transition, 1 == rotation, 2 == scaling, 3 == rotation around point)
	var mTransitionTypeArray;
	
	
	// Boolean used to indicate whether the waypoints of transitions are inverted or not
	var mAreTransitionsInverted;
	
	// Public functions
	CreateTransition(object, startingPos, endingPos, time, loop);
	RemoveTransitionByObject(object, isRotating);
	CreatePathTransition(object, waypoints, time, loop);
	CreateRotatingTransition(object, startingAngle, finalAngle, axis, time, loop, reverse);
	ChangeScaleFactors(newFactor);
	CreateScalingTransition(object, startingScale, endingScale, time, loop);
	CreateRotationAroundPointTransition(object, startingPoint, centerPoint, period, loop);
	
	// Private functions
	InvertTransitions();
	UpdateTransitions(dt);
	RemoveTransitionByIndex(index);
};

/* Constructor */
function Animator::Animator()
{
	mObjects = {};
	mStartingPositions = {};
	mIsLoopArray = {};
	mTimeArray = {};
	mScaleFactorArray = {};
	mDirectionsArray = {};
	mDistanceArray = {};
	mXSpeedArray = {};
	mYSpeedArray = {};
	mZSpeedArray = {};
	
	mHasWaypointsArray = {};
	mWaypointsArray = {};
	mWaypointsCounterArray = {};
	
	mTransitionTypeArray = {};
	mFinalAngleArray = {};
	mAxisArray = {};
	mAngleDeltaArray = {};
	mReverseArray = {};
	
	mAreTransitionsInverted = false;
}

/* Method that creates a transition from startingPos to endingPos in the given time. Ending pos can be an array of positions, and if it is it will
 * create a path transition instead; in that case "time" will be the time to get from one waypoint to the other, and if "loop" is true when the object
 * will reach the last waypoint it will go back to startingPos and start the transition all over again
 * 
 * object: (CVmObj) the object to move
 * startingPos: (vector) starting position
 * endingPos: (vector or array of vectors; es.: {[0, 10, 0], [10, 10, 0]}) ending position
 * time: (float) the time it has to move from start to end (expressed in seconds)
 * loop: (boolean) whether the transition has to loop or not
 */
function Animator::CreateTransition(object, startingPos, endingPos, time, loop)
{
	// If there is already a transition active for the object, I remove it ("false" indicates a movement transition); if there isn't this doesn't do anything
	RemoveTransitionByObject(object, 0);
	
	// For starter, I move the object to the starting position, in case it wasn't there already
	object.SetPosition(startingPos);
	
	// Adding the things needed to update the object's position
	aadd(mObjects, object);
	aadd(mStartingPositions, startingPos);
	aadd(mIsLoopArray, loop);
	aadd(mTimeArray, time);
	aadd(mScaleFactorArray, 1.0);
	
	var endPoint = endingPos;
	
	// To incorporate both common transitions and path transitions (i.e. with waypoints), I check the type of "endingPos". In fact, if it's a common transition
	// it will be a vector, otherwise an array of vectors (actually, I'm assuming it's vectors; I'm trusting the user here).
	// So if the type is "A" (Array), I populate the waypoints' arrays with useful things
	if(valtype(endingPos) == "A")
	{
		// The first waypoint is the current end point, so I get it to do some computations soon
		endPoint = endingPos[0];
		
		// I'm creating a waypoints array that contains all waypoints, including the starting position, to make the update of the object's position easier
		var waypoints = {startingPos};
		
		// I add each waypoint to this array
		foreach(var waypoint in endingPos)
		{
			aadd(waypoints, waypoint);
		}
		
		// I state that this object has waypoints, and I'm passing the waypoints. I'm also starting the waypointsCounter (i.e. the variable that says what is
		// the next waypoint) to 2, since the first is the starting position and the second is the waypoint I'm already traveling to
		aadd(mHasWaypointsArray, true);
		aadd(mWaypointsArray, waypoints);
		aadd(mWaypointsCounterArray, 2);
	}
	else
	{		
		// If this object doesn't have transitions, I state so by putting "false" in the array; I also save the ending position in the waypoints array, even though
		// technically there are no waypoints (but it saves space)
		aadd(mHasWaypointsArray, false);
		aadd(mWaypointsArray, endingPos);
		aadd(mWaypointsCounterArray, 0);
	}
	
	// Computing the distance (which is the length of the difference of the 2 vectors) and the direction it has to move to
	var distance = Modulus(endPoint - startingPos);
	var direction = Norm(endPoint - startingPos);
	
	aadd(mDistanceArray, distance);	
	aadd(mDirectionsArray, direction);
	
	// For each axis, I compute the speed the component has to increment (or decrement to); it's basically "velocity = space / time". 
	// Note: I use an absolute value after the computation in order to always have positive speeds, since I'm using the "direction" vector to find out
	// whether one of these components has to be incremented or decremented
	var xSpeed = abs((startingPos.x - endPoint.x) / time);
	var ySpeed = abs((startingPos.y - endPoint.y) / time);
	var zSpeed = abs((startingPos.z - endPoint.z) / time);
	
	aadd(mXSpeedArray, xSpeed);
	aadd(mYSpeedArray, ySpeed);
	aadd(mZSpeedArray, zSpeed);

	
	// Since this is a transition, the arrays regarding rotation are filled with random things since they won't be used. I fill them anyway in order
	// to have a 1:1 ratio between transitions and rotations array, so that I can reuse the same arrays for the things that are common between
	// transitions and rotations
	aadd(mTransitionTypeArray, 0);
	aadd(mAxisArray, 0);
	aadd(mFinalAngleArray, 0);
	aadd(mAngleDeltaArray, 0);
	aadd(mReverseArray, false);
}

/* Method that creates a rotation from startingAngle to finalAngle around the given axis in the given time. 
 * 
 * object: (CVmObj) the object to move
 * startingAngle: (float) starting angle
 * finalAngle: (float) final angle
 * axis: (vector) the axis around which to rotate (i.e. [0, 1, 0])
 * time: (float) the time it has to move from start to end (expressed in seconds)
 * loop: (boolean) whether the rotation has to loop or not
 * reverse: (boolean) this is only checked if loop == true; in that case if reverse is true the loop will go back and forth from startingAngle to finalAngle
 */
function Animator::CreateRotatingTransition(object, startingAngle, finalAngle, axis, time, loop, reverse)
{		
	// If there is already a transition active for the object, I remove it ("true" indicates a rotation transition); if there isn't this doesn't do anything
	RemoveTransitionByObject(object, 1);
	
	// First off, I'm setting the starting rotation
//	object.SetRotation(startingAngle, axis);
	
	aadd(mObjects, object);
	aadd(mStartingPositions, startingAngle);
	aadd(mIsLoopArray, loop);
	aadd(mTimeArray, time);
	aadd(mScaleFactorArray, 1.0);
	
	// I state that this object has a rotation
	aadd(mTransitionTypeArray, 1);
	
	// Computing the speed of the rotation, based on the given time
	var speed = (finalAngle - startingAngle) / (time);
	
	// I am adding the speed to the mXSpeedArray, even though the X doesn't really fit; I do so tho avoid creating a completely new array
	aadd(mXSpeedArray, speed);
		
	// Filling some useful arrays
	aadd(mFinalAngleArray, finalAngle);
	aadd(mAxisArray, axis);
	aadd(mAngleDeltaArray, 0);
	aadd(mReverseArray, reverse);
	
	// Filling the not used arrays with pseudo-random content
	aadd(mYSpeedArray, 0);
	aadd(mZSpeedArray, 0);
	aadd(mDistanceArray, 0);	
	aadd(mDirectionsArray, 0);
	aadd(mHasWaypointsArray, false);
	aadd(mWaypointsArray, 0);
	aadd(mWaypointsCounterArray, 0);
}


/*
 * This method creates scaling transitions; the code is pretty much the same as for movement transitions
 */
function Animator::CreateScalingTransition(object, startingScale, endingScale, time, loop)
{		
	RemoveTransitionByObject(object, 2);
	
	// First off, I'm setting the starting scale
	object.SetScale(startingScale);
	
	aadd(mObjects, object);
	aadd(mStartingPositions, startingScale);
	aadd(mIsLoopArray, loop);
	aadd(mTimeArray, time);
	aadd(mScaleFactorArray, 1.0);
	
	// I state that this object is scaling
	aadd(mTransitionTypeArray, 2);
	
	var endScale = endingScale;
	
	if(valtype(endingScale) == "A")
	{
		endScale = endingScale[0];
		
		var waypoints = {startingScale};
		
		foreach(var waypoint in endingScale)
			aadd(waypoints, waypoint);		

		aadd(mHasWaypointsArray, true);
		aadd(mWaypointsArray, waypoints);
		aadd(mWaypointsCounterArray, 2);
	}
	else
	{		
		aadd(mHasWaypointsArray, false);
		aadd(mWaypointsArray, endingScale);
		aadd(mWaypointsCounterArray, 0);
	}
	
	var distance = Modulus(endScale - startingScale);

	aadd(mDistanceArray, distance);	
	
	var xSpeed = ((endScale.x - startingScale.x) / time);
	var ySpeed = ((endScale.y - startingScale.y) / time);
	var zSpeed = ((endScale.z - startingScale.z) / time);
	
	aadd(mXSpeedArray, xSpeed);
	aadd(mYSpeedArray, ySpeed);
	aadd(mZSpeedArray, zSpeed);

	
	// Arrays not used; filled with useless stuff
	aadd(mDirectionsArray, 0);
	aadd(mAxisArray, 0);
	aadd(mFinalAngleArray, 0);
	aadd(mAngleDeltaArray, 0);
	aadd(mReverseArray, false);
}


/*
 * This method creates rotation-around-point transitions; the code is pretty much the same as for simple rotation transitions
 */
function Animator::CreateRotationAroundPointTransition(object, startingPoint, centerPoint, period, loop)
{		
	RemoveTransitionByObject(object, 3);
	
	object.SetPosition(startingPoint);
	
	aadd(mObjects, object);
	aadd(mStartingPositions, centerPoint);
	aadd(mIsLoopArray, loop);
	aadd(mTimeArray, period);
	aadd(mScaleFactorArray, 1.0);
	
	aadd(mAxisArray, 0.0);  // This is actually the starting angle of the rotation; it's always 0; I don't want to create another array just for this
	
	// I state that this object is a rotation-around-point
	aadd(mTransitionTypeArray, 3);

	// Radius of the circle	
	var radius = Modulus(centerPoint - startingPoint);
	
	// Angular velocity; I convert the total degrees of the circle to radiants because the speed will be used to update angles that are in radiants
	var speed = (360.0 * GRAD_TO_RAD) / period;
	
	aadd(mDistanceArray, radius);
	
	// I am adding the speed to the mXSpeedArray, even though the X doesn't really fit; I do so tho avoid creating a completely new array
	aadd(mXSpeedArray, speed);
		
	// Filling some useful arrays
	aadd(mFinalAngleArray, 360.0);
	aadd(mAngleDeltaArray, 0);
	
	// Filling the not used arrays with pseudo-random content
	aadd(mYSpeedArray, 0);
	aadd(mZSpeedArray, 0);
	aadd(mDirectionsArray, 0);
	aadd(mHasWaypointsArray, false);
	aadd(mWaypointsArray, 0);
	aadd(mWaypointsCounterArray, 0);
	aadd(mReverseArray, 0);
}

/*
 * This method as to be called by the caller in its "update" function, so that the objects' positions will be constantly updated
 * 
 * dt: (float) the delta time, i.e. the time from the last frame to the current frame
 */
function Animator::UpdateTransitions(dt)
{
	// Iterating over all the objects that have active transitions/rotations
	for(var i = 0; i < len(mObjects); i++)
	{
		var object = mObjects[i];
		
		// Case where this object is a transition object and NOT a rotation one
		if(mTransitionTypeArray[i] == 0)
		{
			// Getting some useful information from the arrays
			var currentPosition = object.GetPosition();
			var startingPosition = mStartingPositions[i];
			var distance = mDistanceArray[i];
			var direction = mDirectionsArray[i];
			var xSpeed = mXSpeedArray[i];
			var ySpeed = mYSpeedArray[i];
			var zSpeed = mZSpeedArray[i];
			
			// Computing the new position starting from the current one. I move along the given direction with the given speed, taking into account
			// the dt passed from the last frame, in order to make smooth transitions
			currentPosition.x += direction.x * dt * xSpeed * mScaleFactorArray[i];
			currentPosition.y += direction.y * dt * ySpeed * mScaleFactorArray[i];
			currentPosition.z += direction.z * dt * zSpeed * mScaleFactorArray[i];

			// Setting the new position
			object.SetPosition(currentPosition);
	
			// Now I compute the distance traveled from the starting position to the current one; if it's greater or equal than the total distance, I'm done
			if(Modulus(startingPosition - currentPosition) >= distance)
			{
				// Actually, if the objects has waypoints, I'm not done since there might be more waypoints to travel to
				if(mHasWaypointsArray[i])
				{
					// Getting all the waypoints
					var waypoints = mWaypointsArray[i];
					
					// If waypoints are inverted and we reached the first one (which now is the last) and the transition isn't looping, I end the transition
					if(mAreTransitionsInverted && mWaypointsCounterArray[i] == 0 && !mIsLoopArray[i]) 
						RemoveTransitionByIndex(i);
					// Checking if there is still at least one waypoints to travel to
					else if(mWaypointsCounterArray[i] < len(waypoints))
					{
						
						// In that case I take the new waypoint and I set as new starting position the current one
						var endpoint = waypoints[mWaypointsCounterArray[i]];
						mStartingPositions[i] = currentPosition;
						
						// I compute the new distance and direction
						distance = Modulus(endpoint - currentPosition);
						direction = Norm(endpoint - currentPosition);
										
						// I modify the previous distance and direction in the given arrays with the new ones
						mDistanceArray[i] = distance;
						mDirectionsArray[i] = direction;
						
						// I update the speeds along each axis with the new information
						xSpeed = abs((currentPosition.x - endpoint.x) / mTimeArray[i]);
						ySpeed = abs((currentPosition.y - endpoint.y) / mTimeArray[i]);
						zSpeed = abs((currentPosition.z - endpoint.z) / mTimeArray[i]);
												
						mXSpeedArray[i] = xSpeed;
						mYSpeedArray[i] = ySpeed;
						mZSpeedArray[i] = zSpeed;
						
						// If this object has also to loop, I increment the waypoint counter with the modulo, so that when it reaches the last waypoint it 
						// starts again from the starting position (which was put as element 0 in the array "waypoints" when the rotation transition was created);
						// otherwise I simply update the waypoint counter

						// Now I have to change the counter to point to the transition I will have to visit after the current one (i.e., if I have waypoints
						// X, Y and Z and I'm moving from X to Y, the counter will point to Z); this changes whether waypoints are reversed or not; in that 
						// case we must decrement the counter, otherwise increment it
						if(mAreTransitionsInverted && mWaypointsCounterArray[i] > 0)
							mWaypointsCounterArray[i]--;
						else if(mAreTransitionsInverted)
							mWaypointsCounterArray[i] = len(waypoints) - 1;
						else
							mWaypointsCounterArray[i] = mWaypointsCounterArray[i] + 1;
						
						// If we're also looping, we take the modulo of the counter so that we start from the beginning (this is only useful if we're incrementing)
						if(mIsLoopArray[i])
							mWaypointsCounterArray[i] = mWaypointsCounterArray[i] % len(waypoints);
					}
					// If it reached all waypoints and the object isn't looping, I remove it from the active transitions
					else
						RemoveTransitionByIndex(i);
				}
				// If the object doesn't have waypoints but is looping, I invert the sign of the direction and putting as starting position the current one;
				// I also save the final position in the mWaypointsArray, although technically it doesn't have waypoints.
				// The rest (distance to travel, speed and so on) obviously stays the same
				else if(mIsLoopArray[i])
			    {
				 	mDirectionsArray[i] = -mDirectionsArray[i];
				 	mWaypointsArray[i] = mStartingPositions[i];
				 	mStartingPositions[i] = currentPosition;
				}
				// If the object doesn't have waypoints and isn't looping, I simply remove it from the active transitions
				else
					RemoveTransitionByIndex(i);
			}
		}
		// If the object has not a transition but a rotation, it's a bit different
		else if(mTransitionTypeArray[i] == 1)
		{
			// Taking some useful stuff
			var speed = mXSpeedArray[i];
			var axis = mAxisArray[i];
			var startingAngle = mStartingPositions[i];
			var finalAngle = mFinalAngleArray[i];
			var currentAngle = mAngleDeltaArray[i];
			
			// The increment is set by the speed and the delta time
			var increment = speed * dt * mScaleFactorArray[i];
			
			// I rotate the object with the previously computed speed around the given axis
			object.Rotate(increment, axis);
			
			// I update the current angle with the absolute value of the current increment; I always consider the angle positive to simplify computations
			// in case the rotation is in a loop and also needs to be reversed.
			// If the transitions are inverted, I decrement
			if(!mAreTransitionsInverted)
				currentAngle += abs(increment);
			else
				currentAngle -= abs(increment);
			
			// If the transitions are inverted, we're NOT looping and the angle reached the starting angle, I end the transition
			if(mAreTransitionsInverted && !mIsLoopArray[i] && currentAngle <= startingAngle)
				RemoveTransitionByIndex(i);
			// If the current angle is greater or equal then the total angle distance it has to rotate to, we're done (almost)
			else if(currentAngle >= abs(finalAngle - startingAngle))
			{				
				// If the object has to loop and also reverse (i.e. go back from the final angle to the starting angle and repeat), I invert the speed 
				// value so that it rotates in the opposite direction and reset the delta value so I can check again the angle distance
				if(mIsLoopArray[i] && mReverseArray[i])
				{
					mXSpeedArray[i] = -speed;
					mAngleDeltaArray[i] = 0;
				}
				// If is looping but not reversing, I simply reset the delta value so that it keeps rotating forever
				else if(mIsLoopArray[i])
					mAngleDeltaArray[i] = 0;
				// If it's not looping, I remove the object from the active objects
				else
					RemoveTransitionByIndex(i);
			}
			// Otherwise, if it didn't reach the end, I update the delta value with the current angle
			else
				mAngleDeltaArray[i] = currentAngle;
		}
		// Case where we have a scaling transition
		else if(mTransitionTypeArray[i] == 2)
		{
			// Getting some useful information from the arrays
			var currentScale = object.GetScale();
			var startingScale = mStartingPositions[i];
			var distance = mDistanceArray[i];
			var xSpeed = mXSpeedArray[i];
			var ySpeed = mYSpeedArray[i];
			var zSpeed = mZSpeedArray[i];
			
			currentScale.x += dt * xSpeed * mScaleFactorArray[i];
			currentScale.y += dt * ySpeed * mScaleFactorArray[i];
			currentScale.z += dt * zSpeed * mScaleFactorArray[i];
			
			object.SetScale(currentScale);
	
			if(Modulus(startingScale - currentScale) >= distance)
			{
				if(mHasWaypointsArray[i])
				{
					var waypoints = mWaypointsArray[i];
					
					if(mAreTransitionsInverted && mWaypointsCounterArray[i] == 0 && !mIsLoopArray[i]) 
						RemoveTransitionByIndex(i);
					else if(mWaypointsCounterArray[i] < len(waypoints))
					{
						var endpoint = waypoints[mWaypointsCounterArray[i]];
						mStartingPositions[i] = currentScale;
						
						distance = Modulus(currentScale - endpoint);
										
						mDistanceArray[i] = distance;
						
						xSpeed = (endpoint.x - currentScale.x) / mTimeArray[i];
						ySpeed = (endpoint.y - currentScale.y) / mTimeArray[i];
						zSpeed = (endpoint.z - currentScale.z) / mTimeArray[i];
												
						mXSpeedArray[i] = xSpeed;
						mYSpeedArray[i] = ySpeed;
						mZSpeedArray[i] = zSpeed;

						if(mAreTransitionsInverted && mWaypointsCounterArray[i] > 0)
							mWaypointsCounterArray[i]--;
						else if(mAreTransitionsInverted)
							mWaypointsCounterArray[i] = len(waypoints) - 1;
						else
							mWaypointsCounterArray[i] = mWaypointsCounterArray[i] + 1;
						
						if(mIsLoopArray[i])
							mWaypointsCounterArray[i] = mWaypointsCounterArray[i] % len(waypoints);
					}
					else
						RemoveTransitionByIndex(i);
				}
				// If the object doesn't have waypoints but is looping, I invert the sign of the direction and putting as starting position the current one;
				// I also save the final position in the mWaypointsArray, although technically it doesn't have waypoints.
				// The rest (distance to travel, speed and so on) obviously stays the same
				else if(mIsLoopArray[i])
			    {
				 	mXSpeedArray[i] = -mXSpeedArray[i];
					mYSpeedArray[i] = -mYSpeedArray[i];
					mZSpeedArray[i] = -mZSpeedArray[i];
				 	mWaypointsArray[i] = mStartingPositions[i];
				 	mStartingPositions[i] = currentScale;
				}
				// If the object doesn't have waypoints and isn't looping, I simply remove it from the active transitions
				else
					RemoveTransitionByIndex(i);
			}
		}
		// Case where the transition has type rotation-around-point; code is very similar to the case of simple rotations
		else if(mTransitionTypeArray[i] == 3)
		{
			// Taking some useful stuff
			var speed = mXSpeedArray[i];
			var startingAngle = mAxisArray[i];
			var centerPoint = mStartingPositions[i];
			var finalAngle = mFinalAngleArray[i];
			var currentAngle = mAngleDeltaArray[i];
			var radius = mDistanceArray[i];

			// The increment is set by the speed and the delta time
			var increment = speed * dt * mScaleFactorArray[i];
			
			var currentPosition = object.GetPosition();
			
			// I update the position as if the object was a point moving around in a circle with z as the y and x as the x
			currentPosition.x = cos(currentAngle) * radius + centerPoint.x;
			currentPosition.z = sin(currentAngle) * radius + centerPoint.z;
			
			object.SetPosition(currentPosition);
						
			// I update the current angle with the absolute value of the current increment; I always consider the angle positive to simplify computations
			// in case the rotation is in a loop and also needs to be reversed.
			// If the transitions are inverted, I decrement
			if(!mAreTransitionsInverted)
				currentAngle += abs(increment);
			else
				currentAngle -= abs(increment);
							
			// If the transitions are inverted, we're NOT looping and the angle reached the starting angle, I end the transition
			if(mAreTransitionsInverted && !mIsLoopArray[i] && currentAngle <= startingAngle)
				RemoveTransitionByIndex(i);
			// If the current angle (which is in radiants, so I need to convert it to degrees) is greater or equal then the total angle distance
			// it has to rotate to, we're done (almost)
			else if(currentAngle * RAD_TO_GRAD >= abs(finalAngle - startingAngle))
			{				
				// If is looping, I simply reset the delta value so that it keeps rotating forever
				if(mIsLoopArray[i])
					mAngleDeltaArray[i] = 0;
				else
					RemoveTransitionByIndex(i);
			}
			// Otherwise, if it didn't reach the end, I update the delta value with the current angle
			else
				mAngleDeltaArray[i] = currentAngle;
		}
	}
}

/*
 * This method changes che scaling factor used when updating the objects positions. Higher values means that the objects will move faster, while lower values
 * means slower objects. The default value is 1; below 1 they get slower.
 * 
 * newFactor: (float) the new factor; must be a positive number. 
 * 					  If it's 0, the objects will be static; 
 * 					  if it's between 0 and 1, the objects will be slower;
 * 				      if it's 1, the objects will move normally;
 * 				      if it's between 1 and infinite, the objects will move faster.
 */
function Animator::ChangeScaleFactors(newFactor)
{
	// I change the scaling factor for every object
	for(var i = 0; i < len(mScaleFactorArray); i++)
		mScaleFactorArray[i] = newFactor;
}

/*
 * This method will invert the directions of EVERY transitions (both movements and rotations); calling it twice will put things as they were
 */
function Animator::InvertTransitions()
{
	// I update the boolean that tells whether we're inverting or not
	mAreTransitionsInverted = !mAreTransitionsInverted;
		
	// Scanning all the objects; we need to update some things for every type of transitions we have
	for(var i = 0; i < len(mObjects); i++)
	{
		// If it's a moving transition
		if(mTransitionTypeArray[i] == 0)
		{
			// If it has waypoints we need to change the current waypoint's starting poisition with the ending position, and invert the directions;
			// i.e., if we're moving from A to B with direction 1, we need to use as new starting position B and ending position A, with direction -1.
			// These information are needed in order to the determine where the object needs to stop; simply inverting the direction doesn't work
			if(mHasWaypointsArray[i])
			{		
				var waypoints = mWaypointsArray[i];
				
				var newStartingPosCounter = 0;
				
				// Finding the new starting point is a bit messy; the whole thing could have been handled better. Basically if we're going backwards we need
				// to take as starting position the previous one in the counter of the waypoints, but I need to make sure that if the counter is at position 0
				// it goes to the last waypoint instead. Otherwise, if we're going forward (and previously we were going backward) I simply increment
				// the counter and do the modulo operation so that we start at the beginning of the array if we're at the end
				if(mAreTransitionsInverted && mWaypointsCounterArray[i] > 0)
					newStartingPosCounter = mWaypointsCounterArray[i] - 1;
				else if(mAreTransitionsInverted)
					newStartingPosCounter = len(waypoints) - 1;
				else 
					newStartingPosCounter = (mWaypointsCounterArray[i] + 1) % len(waypoints);
					
				// Setting the new starting position from the counter we found
				mStartingPositions[i] = waypoints[newStartingPosCounter];
				
				var newWaypointsCounter = newStartingPosCounter;
				
				// Now I need to find the new counter, i.e. the index of the waypoint we're going to move to next. NEXT. Not the waypoint we're moving to now.
				// It's a bit confusing and I could have handle it better. To find the new counter we start from the index of the starting position.
				// The counter needs to point 2 indices AFTER this index, but depending whether we're reversing of going forward it's 2 indices before or after
				// this one. So I need to check the cases and make sure that the counter remains in the boundaries of the array
				if(mAreTransitionsInverted)
				{
					if(newWaypointsCounter > 1)
						newWaypointsCounter -= 2;
					else if (newWaypointsCounter == 1)
						newWaypointsCounter = len(waypoints) - 1;
					else
						newWaypointsCounter = len(waypoints) - 2;
				}
				else
					newWaypointsCounter = (newWaypointsCounter + 2) % len(waypoints);
	
				// Setting the new counter
				mWaypointsCounterArray[i] = newWaypointsCounter;
	
				// Inverting the direction, so that the object goes back where it came from
				mDirectionsArray[i] = -mDirectionsArray[i];
			}
			// If the object doesn't have waypoints...
			else
			{
				// I invert the direction
				mDirectionsArray[i] = -mDirectionsArray[i];
				
				// I swap the starting position with the ending position (which is held in the mWaypointsArray to save space), so we can check 
				// in the update method if the object reached the end of the transition or not
				var tmp = mStartingPositions[i];
			 	mStartingPositions[i] = mWaypointsArray[i];
			 	mWaypointsArray[i] = tmp;
			}
		}
		// If the object is involved in a rotation transition, I simply need to invert its speed, so it goes backward
		else if(mTransitionTypeArray[i] == 1)
			mXSpeedArray[i] = -mXSpeedArray[i];
		else if(mTransitionTypeArray[i] == 2)
		{
			if(mHasWaypointsArray[i])
			{		
				var waypoints = mWaypointsArray[i];
				
				var newStartingPosCounter = 0;
				
				// Finding the new starting point is a bit messy; the whole thing could have been handled better. Basically if we're going backwards we need
				// to take as starting position the previous one in the counter of the waypoints, but I need to make sure that if the counter is at position 0
				// it goes to the last waypoint instead. Otherwise, if we're going forward (and previously we were going backward) I simply increment
				// the counter and do the modulo operation so that we start at the beginning of the array if we're at the end
				if(mAreTransitionsInverted && mWaypointsCounterArray[i] > 0)
					newStartingPosCounter = mWaypointsCounterArray[i] - 1;
				else if(mAreTransitionsInverted)
					newStartingPosCounter = len(waypoints) - 1;
				else 
					newStartingPosCounter = (mWaypointsCounterArray[i] + 1) % len(waypoints);
					
				// Setting the new starting position from the counter we found
				mStartingPositions[i] = waypoints[newStartingPosCounter];
				
				var newWaypointsCounter = newStartingPosCounter;
				
				// Now I need to find the new counter, i.e. the index of the waypoint we're going to move to next. NEXT. Not the waypoint we're moving to now.
				// It's a bit confusing and I could have handle it better. To find the new counter we start from the index of the starting position.
				// The counter needs to point 2 indices AFTER this index, but depending whether we're reversing of going forward it's 2 indices before or after
				// this one. So I need to check the cases and make sure that the counter remains in the boundaries of the array
				if(mAreTransitionsInverted)
				{
					if(newWaypointsCounter > 1)
						newWaypointsCounter -= 2;
					else if (newWaypointsCounter == 1)
						newWaypointsCounter = len(waypoints) - 1;
					else
						newWaypointsCounter = len(waypoints) - 2;
				}
				else
					newWaypointsCounter = (newWaypointsCounter + 2) % len(waypoints);
	
				// Setting the new counter
				mWaypointsCounterArray[i] = newWaypointsCounter;
	
				// Inverting the direction, so that the object goes back where it came from
//				mDirectionsArray[i] = -mDirectionsArray[i];
				mXSpeedArray[i] = -mXSpeedArray[i];
				mYSpeedArray[i] = -mYSpeedArray[i];
				mZSpeedArray[i] = -mZSpeedArray[i];
			}
			// If the object doesn't have waypoints...
			else
			{
				// I invert the direction
//				mDirectionsArray[i] = -mDirectionsArray[i];
				mXSpeedArray[i] = -mXSpeedArray[i];
				mYSpeedArray[i] = -mYSpeedArray[i];
				mZSpeedArray[i] = -mZSpeedArray[i];
				
				// I swap the starting position with the ending position (which is held in the mWaypointsArray to save space), so we can check 
				// in the update method if the object reached the end of the transition or not
				var tmp = mStartingPositions[i];
			 	mStartingPositions[i] = mWaypointsArray[i];
			 	mWaypointsArray[i] = tmp;
			}
		}
		// If the object is involved in a rotation-around-point transition, I simply need to invert its speed, so it goes backward
		else if(mTransitionTypeArray[i] == 3)
			mXSpeedArray[i] = -mXSpeedArray[i];
	}
}

/*
 * This (public) method that removes an object from the active transitions/rotations. To use it, you have to specify the type of transition (rotating or not)
 */
function Animator::RemoveTransitionByObject(object, isType)
{
	var found = false;
	
	for(var i = 0; i < len(mObjects) && !found; i++)
	{
		found = mObjects[i] == object;
		
		if(found && mTransitionTypeArray[i] == isType)
			RemoveTransitionByIndex(i);
		else
			found = false;
	}
}

/*
 * This (private) method removes an object's informations from every array, basically deactivating it
 */
function Animator::RemoveTransitionByIndex(index)
{
	adel(mObjects, index);
	adel(mStartingPositions, index);
	adel(mIsLoopArray, index);
	adel(mTimeArray, index);
	adel(mDirectionsArray, index);
	adel(mDistanceArray, index);	
	adel(mXSpeedArray, index);
	adel(mYSpeedArray, index);
	adel(mZSpeedArray, index);
	
	adel(mScaleFactorArray, index);
	
	adel(mHasWaypointsArray, index);
	adel(mWaypointsArray, index);
	adel(mWaypointsCounterArray, index);
	
	adel(mTransitionTypeArray, index);
	adel(mFinalAngleArray, index);
	adel(mAxisArray, index);
	adel(mAngleDeltaArray, index);
	adel(mReverseArray, index);
}


