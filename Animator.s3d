
#include "Utils.s3d"

/*
 * This class handles simple transitions and rotations of CVmObj objects.
 * To use the class, the user must create a Animator object; then by calling its method he can create transitions and rotations of any CVmObject. The
 * animation will start as soon it is created.
 * The user must call "UpdateTransitions(dt)" in the logic method so that the class can update the objects positions.
 * 
 * NOTE: every transition works in the LOCAL coordinate system of the object, meaning that the starting point and ending point (or waypoints) of the transition
 * must be given in the local coordinate system of the object. If, for example, you have to move an object toward another that is in another coordinate system,
 * you first need to obtain the coordinate of this second object in the coordinate system of the first object.
 * 
 * Another way to do it would be to not use the SetPosition() of objects, but the Translate method; in that case, the user has to pass as parameters of
 * endpoints not coordinates, but translation vectors. For instance, in the example above, the user would convert both objects positions in world coordinates
 * using LocalToWorld() method, and then take the difference of the 2 positions. The result will be the translate vector to pass as endpoint
 */
class Animator
{
	// List of objects that currently have an active transition/rotation
	var mObjects;                  
	
	// List of starting positions for every transition. For rotations, it contains the starting angle   
	var mStartingPositions;           
	
	// For every object added to the class, this array contains a boolean that states whether the object's transition/rotation is looping or not
	var mIsLoopArray;
	
	// For every transition/rotation active, this array the time specified by the user for the animation
	var mTimeArray;
	
	var mScaleFactorArray;
	
	// List of distances for every transition. It contains the distance that the object must travel. For rotations, it is empty
	var mDistanceArray;
	
	// List of directions for every transition. It contains direction the object must move to. For rotations, it is empty
	var mDirectionsArray;
	
	// These arrays contain the speed of the increments for each axis that have to be used for transitions.
	// For rotations, only the mXSpeedArray is used; it would have been better to create a new array, but since the concept for rotations is similar
	// to the one for transitions, I prefered using this same array to avoid increasing the code and the memory usage
	var mXSpeedArray;
	var mYSpeedArray;
	var mZSpeedArray;
	
	// These arrays indicate whether the given object has waypoints (so its transition is a "path"), and in that case which are the waypoints 
	// and the counter that states what is the next waypoint to visit. These arrays are only used for transitions, and for rotation objects
	// their corresponding values are empty
	var mHasWaypointsArray;
	var mWaypointsArray;
	var mWaypointsCounterArray;
	
	// These arrays are used in case of rotation objects. For each element they indicate if they're a rotating object, what is the final angle they have to reach,
	// what is the delta angle (i.e. the difference between the starting angle and the current angle they're at), the axis around which they have to rotate to
	// (it's actually a vector [x, y, z]), and whether they have to reverse the rotation when they reach the limit (this is checked only if the rotation is set 
	// to be a loop). These arrays are meaningful only for rotations, so for common transitions they're empty
	var mIsRotatingArray;
	var mFinalAngleArray;
	var mAngleDeltaArray;
	var mAxisArray;
	var mReverseArray;
	
	
	var mAreWaypointsInverted;
	var mEndingPositionsArray;
	
	// Public functions
	CreateTransition(object, startingPos, endingPos, time, loop);
	RemoveTransitionByObject(object);
	CreatePathTransition(object, waypoints, time, loop);
	CreateRotatingTransition(object, startingAngle, finalAngle, axis, time, loop, reverse);
	ChangeScaleFactors(newFactor);
	
	// Private functions
	InvertDirections();
	UpdateTransitions(dt);
	RemoveTransitionByIndex(index);
};

/* Constructor */
function Animator::Animator()
{
	mObjects = {};
	mStartingPositions = {};
	mIsLoopArray = {};
	mTimeArray = {};
	mScaleFactorArray = {};
	mDirectionsArray = {};
	mDistanceArray = {};
	mXSpeedArray = {};
	mYSpeedArray = {};
	mZSpeedArray = {};
	
	mHasWaypointsArray = {};
	mWaypointsArray = {};
	mWaypointsCounterArray = {};
	
	mIsRotatingArray = {};
	mFinalAngleArray = {};
	mAxisArray = {};
	mAngleDeltaArray = {};
	mReverseArray = {};
	
	mAreWaypointsInverted = false;
	mEndingPositionsArray = {};
}

/* Method that creates a transition from startingPos to endingPos in the given time. Ending pos can be an array of positions, and if it is it will
 * create a path transition instead; in that case "time" will be the time to get from one waypoint to the other, and if "loop" is true when the object
 * will reach the last waypoint it will go back to startingPos and start the transition all over again
 * 
 * object: (CVmObj) the object to move
 * startingPos: (vector) starting position
 * endingPos: (vector or array of vectors; es.: {[0, 10, 0], [10, 10, 0]}) ending position
 * time: (float) the time it has to move from start to end (expressed in seconds)
 * loop: (boolean) whether the transition has to loop or not
 */
function Animator::CreateTransition(object, startingPos, endingPos, time, loop)
{
	// For starter, I move the object to the starting position, in case it wasn't there already
	object.SetPosition(startingPos);
	
	// Adding the things needed to update the object's position
	aadd(mObjects, object);
	aadd(mStartingPositions, startingPos);
	aadd(mIsLoopArray, loop);
	aadd(mTimeArray, time);
	aadd(mScaleFactorArray, 1.0);
	
	var endPoint = endingPos;
	
	// To incorporate both common transitions and path transitions (i.e. with waypoints), I check the type of "endingPos". In fact, if it's a common transition
	// it will be a vector, otherwise an array of vectors (actually, I'm assuming it's vectors; I'm trusting the user here).
	// So if the type is "A" (Array), I populate the waypoints' arrays with useful things
	if(valtype(endingPos) == "A")
	{
		// The first waypoint is the current end point, so I get it to do some computations soon
		endPoint = endingPos[0];
		
		// I'm creating a waypoints array that contains all waypoints, including the starting position, to make the update of the object's position easier
		var waypoints = {startingPos};
		
		// I add each waypoint to this array
		foreach(var waypoint in endingPos)
		{
			aadd(waypoints, waypoint);
		}
		
		// I state that this object has waypoints, and I'm passing the waypoints. I'm also starting the waypointsCounter (i.e. the variable that says what is
		// the next waypoint) to 2, since the first is the starting position and the second is the waypoint I'm already traveling to
		aadd(mHasWaypointsArray, true);
		aadd(mWaypointsArray, waypoints);
		aadd(mWaypointsCounterArray, 2);
	}
	else
	{		
		// If this object doesn't have transitions, I state so by putting "false" in the array; the other values in the other arrays are not meaningful
		aadd(mHasWaypointsArray, false);
		aadd(mWaypointsArray, endingPos);
		aadd(mWaypointsCounterArray, 0);
	}
	
	// Computing the distance (which is the length of the difference of the 2 vectors) and the direction it has to move to
	var distance = Modulus(endPoint - startingPos);
	var direction = Norm(endPoint - startingPos);
	
	aadd(mDistanceArray, distance);	
	aadd(mDirectionsArray, direction);
	
	// For each axis, I compute the speed the component has to increment (or decrement to); it's basically "velocity = space / time". 
	// Note: I use an absolute value after the computation in order to always have positive speeds, since I'm using the "direction" vector to find out
	// whether one of these components has to be incremented or decremented
	var xSpeed = abs((startingPos.x - endPoint.x) / time);
	var ySpeed = abs((startingPos.y - endPoint.y) / time);
	var zSpeed = abs((startingPos.z - endPoint.z) / time);
	
	aadd(mXSpeedArray, xSpeed);
	aadd(mYSpeedArray, ySpeed);
	aadd(mZSpeedArray, zSpeed);

	
	// Since this is a transition, the arrays regarding rotation are filled with random things since they won't be used. I fill them anyway in order
	// to have a 1:1 ratio between transitions and rotations array, so that I can reuse the same arrays for the things that are common between
	// transitions and rotations
	aadd(mIsRotatingArray, false);
	aadd(mAxisArray, 0);
	aadd(mFinalAngleArray, 0);
	aadd(mAngleDeltaArray, 0);
	aadd(mReverseArray, false);
}

/* Method that creates a rotation from startingAngle to finalAngle around the given axis in the given time. 
 * 
 * object: (CVmObj) the object to move
 * startingAngle: (float) starting angle
 * finalAngle: (float) final angle
 * axis: (vector) the axis around which to rotate (i.e. [0, 1, 0])
 * time: (float) the time it has to move from start to end (expressed in seconds)
 * loop: (boolean) whether the rotation has to loop or not
 * reverse: (boolean) this is only checked if loop == true; in that case if reverse is true the loop will go back and forth from startingAngle to finalAngle
 */
function Animator::CreateRotatingTransition(object, startingAngle, finalAngle, axis, time, loop, reverse)
{		
	// First off, I'm setting the starting rotation
	object.SetRotation(startingAngle, axis);
	
	aadd(mObjects, object);
	aadd(mStartingPositions, startingAngle);
	aadd(mIsLoopArray, loop);
	aadd(mTimeArray, time);
	aadd(mScaleFactorArray, 1.0);
	
	// I state that this object has a rotation
	aadd(mIsRotatingArray, true);
	
	// Computing the speed of the rotation, based on the given time
	var speed = (finalAngle - startingAngle) / (time);
	
	// I am adding the speed to the mXSpeedArray, even though the X doesn't really fit; I do so tho avoid creating a completely new array
	aadd(mXSpeedArray, speed);
		
	// Filling some useful arrays
	aadd(mFinalAngleArray, finalAngle);
	aadd(mAxisArray, axis);
	aadd(mAngleDeltaArray, 0);
	aadd(mReverseArray, reverse);
	
	// Filling the not used arrays with pseudo-random content
	aadd(mYSpeedArray, 0);
	aadd(mZSpeedArray, 0);
	aadd(mDistanceArray, 0);	
	aadd(mDirectionsArray, 0);
	aadd(mHasWaypointsArray, false);
	aadd(mWaypointsArray, 0);
	aadd(mWaypointsCounterArray, 0);
}

/*
 * This method as to be called by the caller in its "update" function, so that the objects' positions will be constantly updated
 * 
 * dt: (float) the delta time, i.e. the time from the last frame to the current frame
 */
function Animator::UpdateTransitions(dt)
{
	// Iterating over all the objects that have active transitions/rotations
	for(var i = 0; i < len(mObjects); i++)
	{
		var object = mObjects[i];
		
		// Case where this object is a transition object and NOT a rotation one
		if(!mIsRotatingArray[i])
		{
			// Getting some useful information from the arrays
			var currentPosition = object.GetPosition();
			var startingPosition = mStartingPositions[i];
			var distance = mDistanceArray[i];
			var direction = mDirectionsArray[i];
			var xSpeed = mXSpeedArray[i];
			var ySpeed = mYSpeedArray[i];
			var zSpeed = mZSpeedArray[i];
	
			// Computing the new position starting from the current one. I move along the given direction with the given speed, taking into account
			// the dt passed from the last frame, in order to make smooth transitions
			currentPosition.x += direction.x * dt * xSpeed * mScaleFactorArray[i];
			currentPosition.y += direction.y * dt * ySpeed * mScaleFactorArray[i];
			currentPosition.z += direction.z * dt * zSpeed * mScaleFactorArray[i];
			
			// Setting the new position
			object.SetPosition(currentPosition);
			
//			print({"i", "startingPosition", "currentPosition", "counter", "distanceNow", "distanceEnd"}, {i, startingPosition, currentPosition, mWaypointsCounterArray[i], Modulus(startingPosition - currentPosition), distance});
			
//			print("pos", currentPosition);
			
	
			// Now I compute the distance traveled from the starting position to the current one; if it's greater or equal than the total distance, I'm done
			if(Modulus(startingPosition - currentPosition) >= distance)
			{
				// Actually, if the objects has waypoints, I'm not done since there might be more waypoints to travel to
				if(mHasWaypointsArray[i])
				{
					// Getting all the waypoints
					var waypoints = mWaypointsArray[i];
					
					// Checking if there is still at least one waypoints to travel to
					if(mWaypointsCounterArray[i] < len(waypoints))
					{
						// In that case I take the new waypoint and I set as new starting position the current one
						var endpoint = waypoints[mWaypointsCounterArray[i]];
						mStartingPositions[i] = currentPosition;
						
						// I compute the new distance and direction
						distance = Modulus(endpoint - currentPosition);
						direction = Norm(endpoint - currentPosition);
						
						output("\nYO new direction: ");	
						output(direction);
						output("\n");
						
						// I modify the previous distance and direction in the given arrays with the new ones
						mDistanceArray[i] = distance;
						mDirectionsArray[i] = direction;
						
						// I update the speeds along each axis with the new information
						xSpeed = abs((currentPosition.x - endpoint.x) / mTimeArray[i]);
						ySpeed = abs((currentPosition.y - endpoint.y) / mTimeArray[i]);
						zSpeed = abs((currentPosition.z - endpoint.z) / mTimeArray[i]);
												
						mXSpeedArray[i] = xSpeed;
						mYSpeedArray[i] = ySpeed;
						mZSpeedArray[i] = zSpeed;
						
						// If this object has also to loop, I increment the waypoint counter with the modulo, so that when it reaches the last waypoint it 
						// starts again from the starting position (which was put as element 0 in the array "waypoints" when the rotation transition was created);
						// otherwise I simply update the waypoint counter
//						if(mIsLoopArray[i])
//							mWaypointsCounterArray[i] = (mWaypointsCounterArray[i] + 1 ) % len(waypoints);
//						else
//							mWaypointsCounterArray[i]++;
							
						if(mAreWaypointsInverted && mWaypointsCounterArray[i] > 0)
							mWaypointsCounterArray[i]--;
						else if(mAreWaypointsInverted)
							mWaypointsCounterArray[i] = len(waypoints) - 1;
						else
							mWaypointsCounterArray[i] = mWaypointsCounterArray[i] + 1;
						
						if(mIsLoopArray[i])
							mWaypointsCounterArray[i] = mWaypointsCounterArray[i] % len(waypoints);
					}
					// If it reached all waypoints and the object isn't looping, I remove it from the active transitions
					else
						RemoveTransitionByIndex(i);
				}
				// If the object doesn't have waypoints but is looping, I invert the sign of the direction and putting as starting position the current one.
				// The rest (distance to travel, speed and so on) obviously stay the same
				else if(mIsLoopArray[i])
			    {
				 	mDirectionsArray[i] = -mDirectionsArray[i];
				 	mWaypointsArray[i] = mStartingPositions[i];
				 	mStartingPositions[i] = currentPosition;
				 	
//				 	output("new starting: ");
//				 	output(mStartingPositions[i]);
//				 	output("new ending: ");
//				 	output(mWaypointsArray[i]);
//				 	output("\n");
				}
				// If the object doesn't have waypoints and isn't looping, I simply remove it from the active transitions
				else
					RemoveTransitionByIndex(i);
			}
		}
		// If the object has not a transition but a rotation, it's a bit different
		else
		{
			// Taking some useful stuff
			var speed = mXSpeedArray[i];
			var axis = mAxisArray[i];
			var startingAngle = mStartingPositions[i];
			var finalAngle = mFinalAngleArray[i];
			var currentAngle = mAngleDeltaArray[i];
			
			// The increment is set by the speed and the delta time
			var increment = speed * dt * mScaleFactorArray[i];
			
			// I rotate the object with the previously computed speed around the given axis
			object.Rotate(increment, axis);
			
			// I update the current angle with the absolute value of the current increment; I always consider the angle positive to simplify computations
			//  in case the rotation is in a loop and also needs to be reversed
			currentAngle += abs(increment);
			
			
			// If the current angle is greater or equal then the total angle distance it has to rotate to, we're done (almost)
			if(currentAngle >= abs(finalAngle - startingAngle))
			{
				// If the object has to loop and also reverse (i.e. go back from the final angle to the starting angle and repeat), I invert the speed 
				// value so that it rotates in the opposite direction and reset the delta value so I can check again the angle distance
				if(mIsLoopArray[i] && mReverseArray[i])
				{
					mXSpeedArray[i] = -speed;
					mAngleDeltaArray[i] = 0;
				}
				// If is looping but not reversing, I simply reset the delta value so that it keeps rotating forever
				else if(mIsLoopArray[i])
					mAngleDeltaArray[i] = 0;
				// If it's not looping, I remove the object from the active objects
				else
					RemoveTransitionByIndex(i);
			}
			// Otherwise, if it didn't reach the end, I update the delta value with the current angle
			else
				mAngleDeltaArray[i] = currentAngle;
		}
	}
}

function Animator::ChangeScaleFactors(newFactor)
{
	for(var i = 0; i < len(mScaleFactorArray); i++)
		mScaleFactorArray[i] = newFactor;
}

function Animator::InvertDirections()
{
	mAreWaypointsInverted = !mAreWaypointsInverted;
	
//	output("INVERTING\n");
	
	for(var i = 0; i < len(mObjects); i++)
	{
//		output(i);
//		output("\n");
		var waypoints = mWaypointsArray[i];

		if(mHasWaypointsArray[i])
		{		
			output("mAreWaypointsInverted: " );
			output(mAreWaypointsInverted);
			output("; waypoints: ");	
			output(waypoints);
			output(";\n previous counter: ");	
			output(mWaypointsCounterArray[i]);
			output("; prev distance: ");	
			output(mDistanceArray[i]);
			output("; prev endpoint: ");	
			output(waypoints[mWaypointsCounterArray[i]]);
			output("; prev direction: ");	
			output(mDirectionsArray[i]);
			output("; prev start: ");	
			output(mStartingPositions[i]);
			
			
			mStartingPositions[i] = waypoints[mWaypointsCounterArray[i]];
			
			if(mAreWaypointsInverted && mWaypointsCounterArray[i] > 0)
				mWaypointsCounterArray[i]--;
			else if(mAreWaypointsInverted)
				mWaypointsCounterArray[i] = len(waypoints) - 1;
			else
				mWaypointsCounterArray[i] = mWaypointsCounterArray[i] + 1;
			
			if(mIsLoopArray[i])
				mWaypointsCounterArray[i] = mWaypointsCounterArray[i] % len(waypoints);
			
			
			output("\n prev endpoint - mStartingPositions[i]: ");
			output(Norm(waypoints[mWaypointsCounterArray[i]] - mStartingPositions[i]));
			output("; opposite: ");
			output(Norm(mStartingPositions[i] - waypoints[mWaypointsCounterArray[i]]));
			output("\n");
			output(";\n next counter: ");	
			output(mWaypointsCounterArray[i]);

			
			
			
//			mStartingPositions[i] = mObjects[i].GetPosition();
//			var endpoint = waypoints[mWaypointsCounterArray[i]];
			
//			var distance = Modulus(endpoint - mStartingPositions[i]);
//			var direction = -Norm(endpoint - mStartingPositions[i]);
			
			// I modify the previous distance and direction in the given arrays with the new ones
//			mDistanceArray[i] = distance;
			mDirectionsArray[i] = -mDirectionsArray[i];
			
//			output("; new distance: ");	
//			output(distance);
//			output("; new endpoint: ");	
//			output(endpoint);
//			output("; new direction: ");	
//			output(direction);
//			output("; new start: ");	
//			output(mStartingPositions[i]);
//			output("\n");
//			output("endpoint - mStartingPositions[i]: ");
//			output(Norm(endpoint - mStartingPositions[i]));
//			output("; opposite: ");
//			output(Norm(mStartingPositions[i] - endpoint));
//			output("\n");
			
//			var xSpeed = abs((mStartingPositions[i].x - endpoint.x) / mTimeArray[i]);
//			var ySpeed = abs((mStartingPositions[i].y - endpoint.y) / mTimeArray[i]);
//			var zSpeed = abs((mStartingPositions[i].z - endpoint.z) / mTimeArray[i]);
//									
//			mXSpeedArray[i] = xSpeed;
//			mYSpeedArray[i] = ySpeed;
//			mZSpeedArray[i] = zSpeed;
		}
		else
		{
			
			mDirectionsArray[i] = -mDirectionsArray[i];
			
			var tmp = mStartingPositions[i];
		 	mStartingPositions[i] = mWaypointsArray[i];
		 	mWaypointsArray[i] = tmp;
		}
	}
}

/*
 * This (public) method that removes an object from the active transitions/rotations;
 * Note: if the object has more than one transition or rotation active, this method will remove only one of them, so it could be improved.
 * Or simply, if there are N transition active, the user could call this method N times in a row
 */
function Animator::RemoveTransitionByObject(object)
{
	var found = false;
	
	for(var i = 0; i < len(mObjects) && !found; i++)
	{
		found = mObjects[i] == object;
		
		if(found)
			RemoveTransitionByIndex(i);
	}
}

/*
 * This (private) method removes an object's informations from every array, basically deactivating it
 */
function Animator::RemoveTransitionByIndex(index)
{
	adel(mObjects, index);
	adel(mStartingPositions, index);
	adel(mIsLoopArray, index);
	adel(mDirectionsArray, index);
	adel(mDistanceArray, index);	
	adel(mXSpeedArray, index);
	adel(mYSpeedArray, index);
	adel(mZSpeedArray, index);
	adel(mTimeArray, index);
	adel(mScaleFactorArray, index);
	
	adel(mHasWaypointsArray, index);
	adel(mWaypointsArray, index);
	adel(mWaypointsCounterArray, index);
	
	adel(mIsRotatingArray, index);
	adel(mFinalAngleArray, index);
	adel(mAxisArray, index);
	adel(mAngleDeltaArray, index);
	
	output("yeah: ");
	output(len(mObjects));
	output("\n");
}


/* This function has a different version of the waypoints system, in which the loop is basically implemented as "reversed", meaning that
 * when the object reaches the last waypoint it doesn't go back to the starting position but visits the waypoints in the opposite order.
 * The code is kinda bad, but I leave it as a reference in case it's needed in the future
 */
 
//function Animator::UpdateTransitions(dt)
//{
//	for(var i = 0; i < len(mObjects); i++)
//	{
//		var object = mObjects[i];
//		var currentPosition = object.GetPosition();
//		var startingPosition = mStartingPositions[i];
//		var distance = mDistanceArray[i];
//		var direction = mDirectionsArray[i];
//		var xSpeed = mXSpeedArray[i];
//		var ySpeed = mYSpeedArray[i];
//		var zSpeed = mZSpeedArray[i];
//
//		currentPosition.x += direction.x * dt * xSpeed;
//		currentPosition.y += direction.y * dt * ySpeed;
//		currentPosition.z += direction.z * dt * zSpeed;
//		
//		object.SetPosition(currentPosition);
//		
//		if(Modulus(startingPosition - currentPosition) >= distance)
//		{
//			if(mHasWaypointsArray[i])
//			{
//				var waypoints = mWaypointsArray[i];
//				
//				if(mIsLoopArray[i] && mFinishedWaypointsArray[i])
//				{				
//					var endpoint = waypoints[mWaypointsCounterArray[i]];
//					mStartingPositions[i] = currentPosition;
//					
//					distance = Modulus(endpoint - currentPosition);
//					direction = Norm(endpoint - currentPosition);
//					
//					mDistanceArray[i] = distance;
//					mDirectionsArray[i] = direction;
//					
//					xSpeed = abs((currentPosition.x - endpoint.x) / mTime);
//					ySpeed = abs((currentPosition.y - endpoint.y) / mTime);
//					zSpeed = abs((currentPosition.z - endpoint.z) / mTime);
//					
//					mXSpeedArray[i] = xSpeed;
//					mYSpeedArray[i] = ySpeed;
//					mZSpeedArray[i] = zSpeed;
//										
//					mWaypointsCounterArray[i]--;
//
//					
//					if(mWaypointsCounterArray[i] < 0)
//					{
//						mFinishedWaypointsArray[i] = false;
//						mWaypointsCounterArray[i]++;
//						mWaypointsCounterArray[i]++;
//					}
//										
//					output("mWaypointsCounterArray ");
//					output(mWaypointsCounterArray);
//					output("; currentPosition ");
//					output(currentPosition);
//					output("\n");
//				}
//				else if(mWaypointsCounterArray[i] < len(waypoints) && !mFinishedWaypointsArray[i])
//				{
//					var endpoint = waypoints[mWaypointsCounterArray[i]];
//					mStartingPositions[i] = currentPosition;
//					
//					distance = Modulus(endpoint - currentPosition);
//					direction = Norm(endpoint - currentPosition);
//					
//					mDistanceArray[i] = distance;
//					mDirectionsArray[i] = direction;
//					
//					xSpeed = abs((currentPosition.x - endpoint.x) / mTime);
//					ySpeed = abs((currentPosition.y - endpoint.y) / mTime);
//					zSpeed = abs((currentPosition.z - endpoint.z) / mTime);
//					
//					mXSpeedArray[i] = xSpeed;
//					mYSpeedArray[i] = ySpeed;
//					mZSpeedArray[i] = zSpeed;
//										
//					mWaypointsCounterArray[i]++;
//					
//					if(mWaypointsCounterArray[i] == len(waypoints))
//					{
//						mFinishedWaypointsArray[i] = true;
//						mWaypointsCounterArray[i]--;
//						mWaypointsCounterArray[i]--;
//						
//						output("yeah");
//					output("\n");
//					}
//					
//				}
//				else
//				{
//					RemoveTransitionByIndex(i);
//					output("yoooo");
//					output("\n");
//					}
//			}
//			else if(mIsLoopArray[i])
//		    {
//			 	mDirectionsArray[i] = -mDirectionsArray[i];
//			 	mStartingPositions[i] = currentPosition;
//			 	
//			 	output("asdsadasd\n");
//			}
//			else
//				RemoveTransitionByIndex(i);
//		}
//	}
//}

